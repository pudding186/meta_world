#pragma once

#include "net_data.hpp"

//===============包含的其他协议文件===============
#include "StructDef.hpp"
 //===============宏定义开始===============
//===============宏定义结束===============

//===============数据定义开始===============
struct KeepAliveReq:Protocol<KeepAliveReq>
{
	unsigned int              seq; //自增长序号
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(seq);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(seq);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(seq))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(seq))
			return false;

		return true;
	}
	void Reset(void)
	{
		seq = 0;

	}
	KeepAliveReq& operator= (const KeepAliveReq& src)
	{
		seq = src.seq;

		return *this;
	}
	bool operator==(const KeepAliveReq& src) const
	{
		if (seq != src.seq)
		{
			return false;
		}

		return true;
	}
	bool operator != (const KeepAliveReq& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(KeepAliveReq& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.seq, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        KeepAliveReq& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"seq", seq);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        KeepAliveReq::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct KeepAliveAck:Protocol<KeepAliveAck>
{
	unsigned int              seq; //自增长序号
	unsigned int              tick; //回应tick值
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(seq);

		net_data.AddIntegral(tick);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(seq);

		net_data.AddIntegral(tick);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(seq))
			return false;

		if (!net_data.DelIntegral(tick))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(seq))
			return false;

		if (!net_data.DelIntegral(tick))
			return false;

		return true;
	}
	void Reset(void)
	{
		seq = 0;

		tick = 0;

	}
	KeepAliveAck& operator= (const KeepAliveAck& src)
	{
		seq = src.seq;

		tick = src.tick;

		return *this;
	}
	bool operator==(const KeepAliveAck& src) const
	{
		if (seq != src.seq)
		{
			return false;
		}

		if (tick != src.tick)
		{
			return false;
		}

		return true;
	}
	bool operator != (const KeepAliveAck& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(KeepAliveAck& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.seq, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.tick, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        KeepAliveAck& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"seq", seq);

		json_data.AddIntegral(u8"tick", tick);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        KeepAliveAck::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct AttrNtf:Protocol<AttrNtf>
{
	unsigned long long        guid; //角色guid
	DataArray<AttrData, unsigned short> attrs; //属性数据
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(guid);

		net_data.AddArray(attrs);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(guid);

		net_data.AddArray(attrs);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if(!net_data.DelArray(attrs))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if(!net_data.DelArray(attrs))
			return false;

		return true;
	}
	void Reset(void)
	{
		guid = 0;

		attrs.clear();

	}
	AttrNtf& operator= (const AttrNtf& src)
	{
		guid = src.guid;

		attrs = src.attrs;

		return *this;
	}
	bool operator==(const AttrNtf& src) const
	{
		if (guid != src.guid)
		{
			return false;
		}

		if (attrs != src.attrs)
		{
			return false;
		}

		return true;
	}
	bool operator != (const AttrNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(AttrNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_attrs_handler(m_data.attrs, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_attrs_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.guid, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            switch (m_state)
            {
            case 1:
            {
                m_assigned_bitset.set(m_state);
                return &m_attrs_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)elementCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_attrs_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        AttrNtf& m_data;
        DataArrayHandler<AttrData, unsigned short, AttrData::Handler> m_attrs_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"guid", guid);

		json_data.Writer().Key(u8"attrs", sizeof(u8"attrs") - 1);
		json_data.AddArray(attrs);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        AttrNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct PlayerAppearNtf:Protocol<PlayerAppearNtf>
{
	unsigned long long        guid; //玩家guid
	int                       sn; //用户序列号
	unsigned short            x; //x坐标
	unsigned short            y; //y坐标
	DataArray<AttrData, unsigned short> attrs; //属性数据
	DataArray<BuffData, unsigned char> buffs; //buff数据
	CustomData                custom; //自定义数据
	char                      name[256]; //玩家名字
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(guid);

		net_data.AddIntegral(sn);

		net_data.AddIntegral(x);

		net_data.AddIntegral(y);

		net_data.AddArray(attrs);

		net_data.AddArray(buffs);

		custom.EnCode(net_data);

		net_data.AddString(name, sizeof(name));

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(guid);

		net_data.AddIntegral(sn);

		net_data.AddIntegral(x);

		net_data.AddIntegral(y);

		net_data.AddArray(attrs);

		net_data.AddArray(buffs);

		custom.EnCode(net_data);

		net_data.AddString(name, sizeof(name));

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!net_data.DelIntegral(sn))
			return false;

		if (!net_data.DelIntegral(x))
			return false;

		if (!net_data.DelIntegral(y))
			return false;

		if(!net_data.DelArray(attrs))
			return false;

		if(!net_data.DelArray(buffs))
			return false;

		if (!custom.DeCode(net_data))
			return false;

		if (!net_data.DelString(name, sizeof(name)))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!net_data.DelIntegral(sn))
			return false;

		if (!net_data.DelIntegral(x))
			return false;

		if (!net_data.DelIntegral(y))
			return false;

		if(!net_data.DelArray(attrs))
			return false;

		if(!net_data.DelArray(buffs))
			return false;

		if (!custom.DeCode(net_data))
			return false;

		if (!net_data.DelString(name, sizeof(name)))
			return false;

		return true;
	}
	void Reset(void)
	{
		guid = 0;

		sn = 0;

		x = 0;

		y = 0;

		attrs.clear();

		buffs.clear();

		custom.Reset();

		name[0] = 0;

	}
	PlayerAppearNtf& operator= (const PlayerAppearNtf& src)
	{
		guid = src.guid;

		sn = src.sn;

		x = src.x;

		y = src.y;

		attrs = src.attrs;

		buffs = src.buffs;

		custom = src.custom;

		{
			size_t str_len = strnlen(src.name, sizeof(name) - 1);
			memcpy(name, src.name, str_len + 1);
			name[sizeof(name) - 1] = 0;
		}

		return *this;
	}
	bool operator==(const PlayerAppearNtf& src) const
	{
		if (guid != src.guid)
		{
			return false;
		}

		if (sn != src.sn)
		{
			return false;
		}

		if (x != src.x)
		{
			return false;
		}

		if (y != src.y)
		{
			return false;
		}

		if (attrs != src.attrs)
		{
			return false;
		}

		if (buffs != src.buffs)
		{
			return false;
		}

		if (custom != src.custom)
		{
			return false;
		}

		if (strncmp(name, src.name, sizeof(name)-1))
		{
			return false;
		}

		return true;
	}
	bool operator != (const PlayerAppearNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(PlayerAppearNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_custom_handler(m_data.custom, this),
            m_attrs_handler(m_data.attrs, this),
            m_buffs_handler(m_data.buffs, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_custom_handler.ResetState();
            m_attrs_handler.ResetState();
            m_buffs_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.guid, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.sn, str, length);
            }
            break;
            case 2:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.x, str, length);
            }
            break;
            case 3:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.y, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 7:
            {
                m_assigned_bitset.set(m_state);
                JsonDelString(m_data.name, str, length);
            }
            break;
            default:
            {
                m_state = 0;
                return true;
            }
            }

            m_state++;
            return true;
        }

        JsonHandler* StartObject() override
        {
            switch (m_state)
            {
            case 6:
            {
                m_assigned_bitset.set(m_state);
                return &m_custom_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)memberCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        JsonHandler* StartArray() override
        {
            switch (m_state)
            {
            case 4:
            {
                m_assigned_bitset.set(m_state);
                return &m_attrs_handler;
            }
            break;
            case 5:
            {
                m_assigned_bitset.set(m_state);
                return &m_buffs_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)elementCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_attrs_handler.IsAllMemberSet())
            {
                return false;
            }

            if (!m_buffs_handler.IsAllMemberSet())
            {
                return false;
            }

            if (!m_custom_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        PlayerAppearNtf& m_data;
        CustomData::Handler m_custom_handler;
        DataArrayHandler<AttrData, unsigned short, AttrData::Handler> m_attrs_handler;
        DataArrayHandler<BuffData, unsigned char, BuffData::Handler> m_buffs_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<8> m_assigned_bitset;

        static const std::bitset<8> template_assigned_bitset;
        static const char* m_key_list[8];
        static const char* m_alias_list[8];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"guid", guid);

		json_data.AddIntegral(u8"sn", sn);

		json_data.AddIntegral(u8"x", x);

		json_data.AddIntegral(u8"y", y);

		json_data.Writer().Key(u8"attrs", sizeof(u8"attrs") - 1);
		json_data.AddArray(attrs);

		json_data.Writer().Key(u8"buffs", sizeof(u8"buffs") - 1);
		json_data.AddArray(buffs);

		json_data.Writer().Key(u8"custom", sizeof(u8"custom") - 1);
		custom.ToJson(json_data);

		json_data.AddString(u8"name", name, sizeof(name));

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        PlayerAppearNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct NPCAppearNtf:Protocol<NPCAppearNtf>
{
	unsigned long long        guid; //NPC guid
	unsigned short            template_id; //模板id
	unsigned short            x; //x坐标
	unsigned short            y; //y坐标
	unsigned char             dir; //方向
	DataArray<AttrData, unsigned short> attrs; //属性数据
	CustomData                custom; //自定义数据
	char                      name[256]; //玩家名字
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(guid);

		net_data.AddIntegral(template_id);

		net_data.AddIntegral(x);

		net_data.AddIntegral(y);

		net_data.AddIntegral(dir);

		net_data.AddArray(attrs);

		custom.EnCode(net_data);

		net_data.AddString(name, sizeof(name));

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(guid);

		net_data.AddIntegral(template_id);

		net_data.AddIntegral(x);

		net_data.AddIntegral(y);

		net_data.AddIntegral(dir);

		net_data.AddArray(attrs);

		custom.EnCode(net_data);

		net_data.AddString(name, sizeof(name));

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!net_data.DelIntegral(template_id))
			return false;

		if (!net_data.DelIntegral(x))
			return false;

		if (!net_data.DelIntegral(y))
			return false;

		if (!net_data.DelIntegral(dir))
			return false;

		if(!net_data.DelArray(attrs))
			return false;

		if (!custom.DeCode(net_data))
			return false;

		if (!net_data.DelString(name, sizeof(name)))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!net_data.DelIntegral(template_id))
			return false;

		if (!net_data.DelIntegral(x))
			return false;

		if (!net_data.DelIntegral(y))
			return false;

		if (!net_data.DelIntegral(dir))
			return false;

		if(!net_data.DelArray(attrs))
			return false;

		if (!custom.DeCode(net_data))
			return false;

		if (!net_data.DelString(name, sizeof(name)))
			return false;

		return true;
	}
	void Reset(void)
	{
		guid = 0;

		template_id = 0;

		x = 0;

		y = 0;

		dir = 0;

		attrs.clear();

		custom.Reset();

		name[0] = 0;

	}
	NPCAppearNtf& operator= (const NPCAppearNtf& src)
	{
		guid = src.guid;

		template_id = src.template_id;

		x = src.x;

		y = src.y;

		dir = src.dir;

		attrs = src.attrs;

		custom = src.custom;

		{
			size_t str_len = strnlen(src.name, sizeof(name) - 1);
			memcpy(name, src.name, str_len + 1);
			name[sizeof(name) - 1] = 0;
		}

		return *this;
	}
	bool operator==(const NPCAppearNtf& src) const
	{
		if (guid != src.guid)
		{
			return false;
		}

		if (template_id != src.template_id)
		{
			return false;
		}

		if (x != src.x)
		{
			return false;
		}

		if (y != src.y)
		{
			return false;
		}

		if (dir != src.dir)
		{
			return false;
		}

		if (attrs != src.attrs)
		{
			return false;
		}

		if (custom != src.custom)
		{
			return false;
		}

		if (strncmp(name, src.name, sizeof(name)-1))
		{
			return false;
		}

		return true;
	}
	bool operator != (const NPCAppearNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(NPCAppearNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_custom_handler(m_data.custom, this),
            m_attrs_handler(m_data.attrs, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_custom_handler.ResetState();
            m_attrs_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.guid, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.template_id, str, length);
            }
            break;
            case 2:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.x, str, length);
            }
            break;
            case 3:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.y, str, length);
            }
            break;
            case 4:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.dir, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 7:
            {
                m_assigned_bitset.set(m_state);
                JsonDelString(m_data.name, str, length);
            }
            break;
            default:
            {
                m_state = 0;
                return true;
            }
            }

            m_state++;
            return true;
        }

        JsonHandler* StartObject() override
        {
            switch (m_state)
            {
            case 6:
            {
                m_assigned_bitset.set(m_state);
                return &m_custom_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)memberCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        JsonHandler* StartArray() override
        {
            switch (m_state)
            {
            case 5:
            {
                m_assigned_bitset.set(m_state);
                return &m_attrs_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)elementCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_attrs_handler.IsAllMemberSet())
            {
                return false;
            }

            if (!m_custom_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        NPCAppearNtf& m_data;
        CustomData::Handler m_custom_handler;
        DataArrayHandler<AttrData, unsigned short, AttrData::Handler> m_attrs_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<8> m_assigned_bitset;

        static const std::bitset<8> template_assigned_bitset;
        static const char* m_key_list[8];
        static const char* m_alias_list[8];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"guid", guid);

		json_data.AddIntegral(u8"template_id", template_id);

		json_data.AddIntegral(u8"x", x);

		json_data.AddIntegral(u8"y", y);

		json_data.AddIntegral(u8"dir", dir);

		json_data.Writer().Key(u8"attrs", sizeof(u8"attrs") - 1);
		json_data.AddArray(attrs);

		json_data.Writer().Key(u8"custom", sizeof(u8"custom") - 1);
		custom.ToJson(json_data);

		json_data.AddString(u8"name", name, sizeof(name));

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        NPCAppearNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct ItemAppearNtf:Protocol<ItemAppearNtf>
{
	unsigned long long        guid; //道具 guid
	unsigned short            template_id; //模板id
	unsigned short            x; //x坐标
	unsigned short            y; //y坐标
	CustomData                custom; //自定义数据
	char                      name[256]; //道具名字
	DataArray<DynAttrData, unsigned short> dyn_attrs; //动态属性数据
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(guid);

		net_data.AddIntegral(template_id);

		net_data.AddIntegral(x);

		net_data.AddIntegral(y);

		custom.EnCode(net_data);

		net_data.AddString(name, sizeof(name));

		net_data.AddArray(dyn_attrs);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(guid);

		net_data.AddIntegral(template_id);

		net_data.AddIntegral(x);

		net_data.AddIntegral(y);

		custom.EnCode(net_data);

		net_data.AddString(name, sizeof(name));

		net_data.AddArray(dyn_attrs);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!net_data.DelIntegral(template_id))
			return false;

		if (!net_data.DelIntegral(x))
			return false;

		if (!net_data.DelIntegral(y))
			return false;

		if (!custom.DeCode(net_data))
			return false;

		if (!net_data.DelString(name, sizeof(name)))
			return false;

		if(!net_data.DelArray(dyn_attrs))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!net_data.DelIntegral(template_id))
			return false;

		if (!net_data.DelIntegral(x))
			return false;

		if (!net_data.DelIntegral(y))
			return false;

		if (!custom.DeCode(net_data))
			return false;

		if (!net_data.DelString(name, sizeof(name)))
			return false;

		if(!net_data.DelArray(dyn_attrs))
			return false;

		return true;
	}
	void Reset(void)
	{
		guid = 0;

		template_id = 0;

		x = 0;

		y = 0;

		custom.Reset();

		name[0] = 0;

		dyn_attrs.clear();

	}
	ItemAppearNtf& operator= (const ItemAppearNtf& src)
	{
		guid = src.guid;

		template_id = src.template_id;

		x = src.x;

		y = src.y;

		custom = src.custom;

		{
			size_t str_len = strnlen(src.name, sizeof(name) - 1);
			memcpy(name, src.name, str_len + 1);
			name[sizeof(name) - 1] = 0;
		}

		dyn_attrs = src.dyn_attrs;

		return *this;
	}
	bool operator==(const ItemAppearNtf& src) const
	{
		if (guid != src.guid)
		{
			return false;
		}

		if (template_id != src.template_id)
		{
			return false;
		}

		if (x != src.x)
		{
			return false;
		}

		if (y != src.y)
		{
			return false;
		}

		if (custom != src.custom)
		{
			return false;
		}

		if (strncmp(name, src.name, sizeof(name)-1))
		{
			return false;
		}

		if (dyn_attrs != src.dyn_attrs)
		{
			return false;
		}

		return true;
	}
	bool operator != (const ItemAppearNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(ItemAppearNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_custom_handler(m_data.custom, this),
            m_dyn_attrs_handler(m_data.dyn_attrs, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_custom_handler.ResetState();
            m_dyn_attrs_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.guid, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.template_id, str, length);
            }
            break;
            case 2:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.x, str, length);
            }
            break;
            case 3:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.y, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 5:
            {
                m_assigned_bitset.set(m_state);
                JsonDelString(m_data.name, str, length);
            }
            break;
            default:
            {
                m_state = 0;
                return true;
            }
            }

            m_state++;
            return true;
        }

        JsonHandler* StartObject() override
        {
            switch (m_state)
            {
            case 4:
            {
                m_assigned_bitset.set(m_state);
                return &m_custom_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)memberCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        JsonHandler* StartArray() override
        {
            switch (m_state)
            {
            case 6:
            {
                m_assigned_bitset.set(m_state);
                return &m_dyn_attrs_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)elementCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_custom_handler.IsAllMemberSet())
            {
                return false;
            }

            if (!m_dyn_attrs_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        ItemAppearNtf& m_data;
        CustomData::Handler m_custom_handler;
        DataArrayHandler<DynAttrData, unsigned short, DynAttrData::Handler> m_dyn_attrs_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<7> m_assigned_bitset;

        static const std::bitset<7> template_assigned_bitset;
        static const char* m_key_list[7];
        static const char* m_alias_list[7];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"guid", guid);

		json_data.AddIntegral(u8"template_id", template_id);

		json_data.AddIntegral(u8"x", x);

		json_data.AddIntegral(u8"y", y);

		json_data.Writer().Key(u8"custom", sizeof(u8"custom") - 1);
		custom.ToJson(json_data);

		json_data.AddString(u8"name", name, sizeof(name));

		json_data.Writer().Key(u8"dyn_attrs", sizeof(u8"dyn_attrs") - 1);
		json_data.AddArray(dyn_attrs);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        ItemAppearNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct ObjDisAppearNtf:Protocol<ObjDisAppearNtf>
{
	unsigned long long        guid; //对象 guid
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(guid);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(guid);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(guid))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(guid))
			return false;

		return true;
	}
	void Reset(void)
	{
		guid = 0;

	}
	ObjDisAppearNtf& operator= (const ObjDisAppearNtf& src)
	{
		guid = src.guid;

		return *this;
	}
	bool operator==(const ObjDisAppearNtf& src) const
	{
		if (guid != src.guid)
		{
			return false;
		}

		return true;
	}
	bool operator != (const ObjDisAppearNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(ObjDisAppearNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.guid, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        ObjDisAppearNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"guid", guid);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        ObjDisAppearNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct ObjMoveNtf:Protocol<ObjMoveNtf>
{
	unsigned long long        guid; //对象 guid
	unsigned short            dst_x; //目标点x坐标
	unsigned short            dst_y; //目标点y坐标
	unsigned char             type; //移动方式 1=正常 2=跳跃
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(guid);

		net_data.AddIntegral(dst_x);

		net_data.AddIntegral(dst_y);

		net_data.AddIntegral(type);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(guid);

		net_data.AddIntegral(dst_x);

		net_data.AddIntegral(dst_y);

		net_data.AddIntegral(type);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!net_data.DelIntegral(dst_x))
			return false;

		if (!net_data.DelIntegral(dst_y))
			return false;

		if (!net_data.DelIntegral(type))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!net_data.DelIntegral(dst_x))
			return false;

		if (!net_data.DelIntegral(dst_y))
			return false;

		if (!net_data.DelIntegral(type))
			return false;

		return true;
	}
	void Reset(void)
	{
		guid = 0;

		dst_x = 0;

		dst_y = 0;

		type = 0;

	}
	ObjMoveNtf& operator= (const ObjMoveNtf& src)
	{
		guid = src.guid;

		dst_x = src.dst_x;

		dst_y = src.dst_y;

		type = src.type;

		return *this;
	}
	bool operator==(const ObjMoveNtf& src) const
	{
		if (guid != src.guid)
		{
			return false;
		}

		if (dst_x != src.dst_x)
		{
			return false;
		}

		if (dst_y != src.dst_y)
		{
			return false;
		}

		if (type != src.type)
		{
			return false;
		}

		return true;
	}
	bool operator != (const ObjMoveNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(ObjMoveNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.guid, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.dst_x, str, length);
            }
            break;
            case 2:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.dst_y, str, length);
            }
            break;
            case 3:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.type, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        ObjMoveNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<4> m_assigned_bitset;

        static const std::bitset<4> template_assigned_bitset;
        static const char* m_key_list[4];
        static const char* m_alias_list[4];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"guid", guid);

		json_data.AddIntegral(u8"dst_x", dst_x);

		json_data.AddIntegral(u8"dst_y", dst_y);

		json_data.AddIntegral(u8"type", type);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        ObjMoveNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct EnterMapNtf:Protocol<EnterMapNtf>
{
	unsigned short            template_id; //模板id
	unsigned short            dst_x; //目标点x坐标
	unsigned short            dst_y; //目标点y坐标
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(template_id);

		net_data.AddIntegral(dst_x);

		net_data.AddIntegral(dst_y);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(template_id);

		net_data.AddIntegral(dst_x);

		net_data.AddIntegral(dst_y);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(template_id))
			return false;

		if (!net_data.DelIntegral(dst_x))
			return false;

		if (!net_data.DelIntegral(dst_y))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(template_id))
			return false;

		if (!net_data.DelIntegral(dst_x))
			return false;

		if (!net_data.DelIntegral(dst_y))
			return false;

		return true;
	}
	void Reset(void)
	{
		template_id = 0;

		dst_x = 0;

		dst_y = 0;

	}
	EnterMapNtf& operator= (const EnterMapNtf& src)
	{
		template_id = src.template_id;

		dst_x = src.dst_x;

		dst_y = src.dst_y;

		return *this;
	}
	bool operator==(const EnterMapNtf& src) const
	{
		if (template_id != src.template_id)
		{
			return false;
		}

		if (dst_x != src.dst_x)
		{
			return false;
		}

		if (dst_y != src.dst_y)
		{
			return false;
		}

		return true;
	}
	bool operator != (const EnterMapNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(EnterMapNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.template_id, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.dst_x, str, length);
            }
            break;
            case 2:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.dst_y, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        EnterMapNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<3> m_assigned_bitset;

        static const std::bitset<3> template_assigned_bitset;
        static const char* m_key_list[3];
        static const char* m_alias_list[3];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"template_id", template_id);

		json_data.AddIntegral(u8"dst_x", dst_x);

		json_data.AddIntegral(u8"dst_y", dst_y);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        EnterMapNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct MoveReq:Protocol<MoveReq>
{
	unsigned short            dst_x; //目标点x
	unsigned short            dst_y; //目标点y
	unsigned short            cur_x; //当前点x
	unsigned short            cur_y; //当前点y
	unsigned int              idx; //客户端序列号
	unsigned int              tick; //gate收到此包的tick
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(dst_x);

		net_data.AddIntegral(dst_y);

		net_data.AddIntegral(cur_x);

		net_data.AddIntegral(cur_y);

		net_data.AddIntegral(idx);

		net_data.AddIntegral(tick);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(dst_x);

		net_data.AddIntegral(dst_y);

		net_data.AddIntegral(cur_x);

		net_data.AddIntegral(cur_y);

		net_data.AddIntegral(idx);

		net_data.AddIntegral(tick);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(dst_x))
			return false;

		if (!net_data.DelIntegral(dst_y))
			return false;

		if (!net_data.DelIntegral(cur_x))
			return false;

		if (!net_data.DelIntegral(cur_y))
			return false;

		if (!net_data.DelIntegral(idx))
			return false;

		if (!net_data.DelIntegral(tick))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(dst_x))
			return false;

		if (!net_data.DelIntegral(dst_y))
			return false;

		if (!net_data.DelIntegral(cur_x))
			return false;

		if (!net_data.DelIntegral(cur_y))
			return false;

		if (!net_data.DelIntegral(idx))
			return false;

		if (!net_data.DelIntegral(tick))
			return false;

		return true;
	}
	void Reset(void)
	{
		dst_x = 0;

		dst_y = 0;

		cur_x = 0;

		cur_y = 0;

		idx = 0;

		tick = 0;

	}
	MoveReq& operator= (const MoveReq& src)
	{
		dst_x = src.dst_x;

		dst_y = src.dst_y;

		cur_x = src.cur_x;

		cur_y = src.cur_y;

		idx = src.idx;

		tick = src.tick;

		return *this;
	}
	bool operator==(const MoveReq& src) const
	{
		if (dst_x != src.dst_x)
		{
			return false;
		}

		if (dst_y != src.dst_y)
		{
			return false;
		}

		if (cur_x != src.cur_x)
		{
			return false;
		}

		if (cur_y != src.cur_y)
		{
			return false;
		}

		if (idx != src.idx)
		{
			return false;
		}

		if (tick != src.tick)
		{
			return false;
		}

		return true;
	}
	bool operator != (const MoveReq& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(MoveReq& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.dst_x, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.dst_y, str, length);
            }
            break;
            case 2:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.cur_x, str, length);
            }
            break;
            case 3:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.cur_y, str, length);
            }
            break;
            case 4:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.idx, str, length);
            }
            break;
            case 5:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.tick, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        MoveReq& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<6> m_assigned_bitset;

        static const std::bitset<6> template_assigned_bitset;
        static const char* m_key_list[6];
        static const char* m_alias_list[6];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"dst_x", dst_x);

		json_data.AddIntegral(u8"dst_y", dst_y);

		json_data.AddIntegral(u8"cur_x", cur_x);

		json_data.AddIntegral(u8"cur_y", cur_y);

		json_data.AddIntegral(u8"idx", idx);

		json_data.AddIntegral(u8"tick", tick);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        MoveReq::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct MoveAck:Protocol<MoveAck>
{
	int                       errcode; //0=成功, 其他表示错误码
	unsigned short            dst_x; //当前的坐标点x
	unsigned short            dst_y; //当前的坐标点y
	unsigned int              idx; //客户端序列号
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(errcode);

		net_data.AddIntegral(dst_x);

		net_data.AddIntegral(dst_y);

		net_data.AddIntegral(idx);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(errcode);

		net_data.AddIntegral(dst_x);

		net_data.AddIntegral(dst_y);

		net_data.AddIntegral(idx);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(errcode))
			return false;

		if (!net_data.DelIntegral(dst_x))
			return false;

		if (!net_data.DelIntegral(dst_y))
			return false;

		if (!net_data.DelIntegral(idx))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(errcode))
			return false;

		if (!net_data.DelIntegral(dst_x))
			return false;

		if (!net_data.DelIntegral(dst_y))
			return false;

		if (!net_data.DelIntegral(idx))
			return false;

		return true;
	}
	void Reset(void)
	{
		errcode = 0;

		dst_x = 0;

		dst_y = 0;

		idx = 0;

	}
	MoveAck& operator= (const MoveAck& src)
	{
		errcode = src.errcode;

		dst_x = src.dst_x;

		dst_y = src.dst_y;

		idx = src.idx;

		return *this;
	}
	bool operator==(const MoveAck& src) const
	{
		if (errcode != src.errcode)
		{
			return false;
		}

		if (dst_x != src.dst_x)
		{
			return false;
		}

		if (dst_y != src.dst_y)
		{
			return false;
		}

		if (idx != src.idx)
		{
			return false;
		}

		return true;
	}
	bool operator != (const MoveAck& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(MoveAck& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.errcode, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.dst_x, str, length);
            }
            break;
            case 2:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.dst_y, str, length);
            }
            break;
            case 3:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.idx, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        MoveAck& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<4> m_assigned_bitset;

        static const std::bitset<4> template_assigned_bitset;
        static const char* m_key_list[4];
        static const char* m_alias_list[4];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"errcode", errcode);

		json_data.AddIntegral(u8"dst_x", dst_x);

		json_data.AddIntegral(u8"dst_y", dst_y);

		json_data.AddIntegral(u8"idx", idx);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        MoveAck::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct JumpMapReq:Protocol<JumpMapReq>
{
	unsigned int              idx; //跳转区索引 静态跳转区idx 小于 65535 动态跳转区 idx 大于 65535 
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(idx);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(idx);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(idx))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(idx))
			return false;

		return true;
	}
	void Reset(void)
	{
		idx = 0;

	}
	JumpMapReq& operator= (const JumpMapReq& src)
	{
		idx = src.idx;

		return *this;
	}
	bool operator==(const JumpMapReq& src) const
	{
		if (idx != src.idx)
		{
			return false;
		}

		return true;
	}
	bool operator != (const JumpMapReq& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(JumpMapReq& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.idx, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        JumpMapReq& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"idx", idx);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        JumpMapReq::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct JumpMapAck:Protocol<JumpMapAck>
{
	int                       errcode; //0=成功, 其他表示错误码
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(errcode);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(errcode);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(errcode))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(errcode))
			return false;

		return true;
	}
	void Reset(void)
	{
		errcode = 0;

	}
	JumpMapAck& operator= (const JumpMapAck& src)
	{
		errcode = src.errcode;

		return *this;
	}
	bool operator==(const JumpMapAck& src) const
	{
		if (errcode != src.errcode)
		{
			return false;
		}

		return true;
	}
	bool operator != (const JumpMapAck& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(JumpMapAck& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.errcode, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        JumpMapAck& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"errcode", errcode);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        JumpMapAck::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct AddJumpMapRegionNtf:Protocol<AddJumpMapRegionNtf>
{
	unsigned int              idx; //跳转区索引 静态跳转区idx 小于 65535 动态跳转区 idx 大于 65535 
	MapRegion                 jump_region; //起跳区域
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(idx);

		jump_region.EnCode(net_data);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(idx);

		jump_region.EnCode(net_data);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(idx))
			return false;

		if (!jump_region.DeCode(net_data))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(idx))
			return false;

		if (!jump_region.DeCode(net_data))
			return false;

		return true;
	}
	void Reset(void)
	{
		idx = 0;

		jump_region.Reset();

	}
	AddJumpMapRegionNtf& operator= (const AddJumpMapRegionNtf& src)
	{
		idx = src.idx;

		jump_region = src.jump_region;

		return *this;
	}
	bool operator==(const AddJumpMapRegionNtf& src) const
	{
		if (idx != src.idx)
		{
			return false;
		}

		if (jump_region != src.jump_region)
		{
			return false;
		}

		return true;
	}
	bool operator != (const AddJumpMapRegionNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(AddJumpMapRegionNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_jump_region_handler(m_data.jump_region, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_jump_region_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.idx, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            switch (m_state)
            {
            case 1:
            {
                m_assigned_bitset.set(m_state);
                return &m_jump_region_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)memberCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_jump_region_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        AddJumpMapRegionNtf& m_data;
        MapRegion::Handler m_jump_region_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"idx", idx);

		json_data.Writer().Key(u8"jump_region", sizeof(u8"jump_region") - 1);
		jump_region.ToJson(json_data);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        AddJumpMapRegionNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct DelJumpMapRegionNtf:Protocol<DelJumpMapRegionNtf>
{
	unsigned int              idx; //跳转区索引
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(idx);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(idx);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(idx))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(idx))
			return false;

		return true;
	}
	void Reset(void)
	{
		idx = 0;

	}
	DelJumpMapRegionNtf& operator= (const DelJumpMapRegionNtf& src)
	{
		idx = src.idx;

		return *this;
	}
	bool operator==(const DelJumpMapRegionNtf& src) const
	{
		if (idx != src.idx)
		{
			return false;
		}

		return true;
	}
	bool operator != (const DelJumpMapRegionNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(DelJumpMapRegionNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.idx, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        DelJumpMapRegionNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"idx", idx);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        DelJumpMapRegionNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct ItemAddNtf:Protocol<ItemAddNtf>
{
	unsigned long long        guid; //容器属于谁(玩家、宠物)
	unsigned short            container_type; //item容器类型
	DataArray<ItemData, unsigned short> items; //物品列表
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(guid);

		net_data.AddIntegral(container_type);

		net_data.AddArray(items);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(guid);

		net_data.AddIntegral(container_type);

		net_data.AddArray(items);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!net_data.DelIntegral(container_type))
			return false;

		if(!net_data.DelArray(items))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!net_data.DelIntegral(container_type))
			return false;

		if(!net_data.DelArray(items))
			return false;

		return true;
	}
	void Reset(void)
	{
		guid = 0;

		container_type = 0;

		items.clear();

	}
	ItemAddNtf& operator= (const ItemAddNtf& src)
	{
		guid = src.guid;

		container_type = src.container_type;

		items = src.items;

		return *this;
	}
	bool operator==(const ItemAddNtf& src) const
	{
		if (guid != src.guid)
		{
			return false;
		}

		if (container_type != src.container_type)
		{
			return false;
		}

		if (items != src.items)
		{
			return false;
		}

		return true;
	}
	bool operator != (const ItemAddNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(ItemAddNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_items_handler(m_data.items, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_items_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.guid, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.container_type, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            switch (m_state)
            {
            case 2:
            {
                m_assigned_bitset.set(m_state);
                return &m_items_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)elementCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_items_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        ItemAddNtf& m_data;
        DataArrayHandler<ItemData, unsigned short, ItemData::Handler> m_items_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<3> m_assigned_bitset;

        static const std::bitset<3> template_assigned_bitset;
        static const char* m_key_list[3];
        static const char* m_alias_list[3];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"guid", guid);

		json_data.AddIntegral(u8"container_type", container_type);

		json_data.Writer().Key(u8"items", sizeof(u8"items") - 1);
		json_data.AddArray(items);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        ItemAddNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct ItemUpdateNtf:Protocol<ItemUpdateNtf>
{
	unsigned long long        guid; //容器属于谁(玩家、宠物)
	unsigned short            container_type; //item容器类型
	DataArray<ItemAttrValueList, unsigned short> attrs; //变更属性列表
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(guid);

		net_data.AddIntegral(container_type);

		net_data.AddArray(attrs);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(guid);

		net_data.AddIntegral(container_type);

		net_data.AddArray(attrs);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!net_data.DelIntegral(container_type))
			return false;

		if(!net_data.DelArray(attrs))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!net_data.DelIntegral(container_type))
			return false;

		if(!net_data.DelArray(attrs))
			return false;

		return true;
	}
	void Reset(void)
	{
		guid = 0;

		container_type = 0;

		attrs.clear();

	}
	ItemUpdateNtf& operator= (const ItemUpdateNtf& src)
	{
		guid = src.guid;

		container_type = src.container_type;

		attrs = src.attrs;

		return *this;
	}
	bool operator==(const ItemUpdateNtf& src) const
	{
		if (guid != src.guid)
		{
			return false;
		}

		if (container_type != src.container_type)
		{
			return false;
		}

		if (attrs != src.attrs)
		{
			return false;
		}

		return true;
	}
	bool operator != (const ItemUpdateNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(ItemUpdateNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_attrs_handler(m_data.attrs, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_attrs_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.guid, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.container_type, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            switch (m_state)
            {
            case 2:
            {
                m_assigned_bitset.set(m_state);
                return &m_attrs_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)elementCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_attrs_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        ItemUpdateNtf& m_data;
        DataArrayHandler<ItemAttrValueList, unsigned short, ItemAttrValueList::Handler> m_attrs_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<3> m_assigned_bitset;

        static const std::bitset<3> template_assigned_bitset;
        static const char* m_key_list[3];
        static const char* m_alias_list[3];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"guid", guid);

		json_data.AddIntegral(u8"container_type", container_type);

		json_data.Writer().Key(u8"attrs", sizeof(u8"attrs") - 1);
		json_data.AddArray(attrs);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        ItemUpdateNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct ItemDestroyNtf:Protocol<ItemDestroyNtf>
{
	unsigned long long        guid; //容器属于谁(玩家、宠物)
	unsigned short            container_type; //item容器类型
	DataArray<unsigned long long, unsigned short> item_guids; //物品GUID列表
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(guid);

		net_data.AddIntegral(container_type);

		net_data.AddArray(item_guids);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(guid);

		net_data.AddIntegral(container_type);

		net_data.AddArray(item_guids);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!net_data.DelIntegral(container_type))
			return false;

		if(!net_data.DelArray(item_guids))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!net_data.DelIntegral(container_type))
			return false;

		if(!net_data.DelArray(item_guids))
			return false;

		return true;
	}
	void Reset(void)
	{
		guid = 0;

		container_type = 0;

		item_guids.clear();

	}
	ItemDestroyNtf& operator= (const ItemDestroyNtf& src)
	{
		guid = src.guid;

		container_type = src.container_type;

		item_guids = src.item_guids;

		return *this;
	}
	bool operator==(const ItemDestroyNtf& src) const
	{
		if (guid != src.guid)
		{
			return false;
		}

		if (container_type != src.container_type)
		{
			return false;
		}

		if (item_guids != src.item_guids)
		{
			return false;
		}

		return true;
	}
	bool operator != (const ItemDestroyNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(ItemDestroyNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_item_guids_handler(m_data.item_guids, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.guid, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.container_type, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            switch (m_state)
            {
            case 2:
            {
                m_assigned_bitset.set(m_state);
                return &m_item_guids_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)elementCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_item_guids_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        ItemDestroyNtf& m_data;
        DataArrayHandler<unsigned long long, unsigned short> m_item_guids_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<3> m_assigned_bitset;

        static const std::bitset<3> template_assigned_bitset;
        static const char* m_key_list[3];
        static const char* m_alias_list[3];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"guid", guid);

		json_data.AddIntegral(u8"container_type", container_type);

		json_data.Writer().Key(u8"item_guids", sizeof(u8"item_guids") - 1);
		json_data.AddArray(item_guids);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        ItemDestroyNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct TipsMsgNtf:Protocol<TipsMsgNtf>
{
	DataArray<unsigned char, unsigned short> msg; //消息内容
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddArray(msg);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddArray(msg);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if(!net_data.DelArray(msg))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if(!net_data.DelArray(msg))
			return false;

		return true;
	}
	void Reset(void)
	{
		msg.clear();

	}
	TipsMsgNtf& operator= (const TipsMsgNtf& src)
	{
		msg = src.msg;

		return *this;
	}
	bool operator==(const TipsMsgNtf& src) const
	{
		if (msg != src.msg)
		{
			return false;
		}

		return true;
	}
	bool operator != (const TipsMsgNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(TipsMsgNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                DataArrayHandler<unsigned char, unsigned short> handler(m_data.msg, this);
                handler.String(str, length, copy);
            }
            break;
            default:
            {
                m_state = 0;
                return true;
            }
            }

            m_state++;
            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        TipsMsgNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.Writer().Key(u8"msg", sizeof(u8"msg") - 1);
		json_data.AddArray(msg);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        TipsMsgNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct TopMsgNtf:Protocol<TopMsgNtf>
{
	unsigned char             foreground; //消息前景颜色ID
	unsigned char             background; //消息背景颜色ID
	unsigned char             count; //消息滚动次数
	DataArray<unsigned char, unsigned short> msg; //消息内容
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(foreground);

		net_data.AddIntegral(background);

		net_data.AddIntegral(count);

		net_data.AddArray(msg);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(foreground);

		net_data.AddIntegral(background);

		net_data.AddIntegral(count);

		net_data.AddArray(msg);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(foreground))
			return false;

		if (!net_data.DelIntegral(background))
			return false;

		if (!net_data.DelIntegral(count))
			return false;

		if(!net_data.DelArray(msg))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(foreground))
			return false;

		if (!net_data.DelIntegral(background))
			return false;

		if (!net_data.DelIntegral(count))
			return false;

		if(!net_data.DelArray(msg))
			return false;

		return true;
	}
	void Reset(void)
	{
		foreground = 0;

		background = 0;

		count = 0;

		msg.clear();

	}
	TopMsgNtf& operator= (const TopMsgNtf& src)
	{
		foreground = src.foreground;

		background = src.background;

		count = src.count;

		msg = src.msg;

		return *this;
	}
	bool operator==(const TopMsgNtf& src) const
	{
		if (foreground != src.foreground)
		{
			return false;
		}

		if (background != src.background)
		{
			return false;
		}

		if (count != src.count)
		{
			return false;
		}

		if (msg != src.msg)
		{
			return false;
		}

		return true;
	}
	bool operator != (const TopMsgNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(TopMsgNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.foreground, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.background, str, length);
            }
            break;
            case 2:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.count, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 3:
            {
                m_assigned_bitset.set(m_state);
                DataArrayHandler<unsigned char, unsigned short> handler(m_data.msg, this);
                handler.String(str, length, copy);
            }
            break;
            default:
            {
                m_state = 0;
                return true;
            }
            }

            m_state++;
            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        TopMsgNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<4> m_assigned_bitset;

        static const std::bitset<4> template_assigned_bitset;
        static const char* m_key_list[4];
        static const char* m_alias_list[4];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"foreground", foreground);

		json_data.AddIntegral(u8"background", background);

		json_data.AddIntegral(u8"count", count);

		json_data.Writer().Key(u8"msg", sizeof(u8"msg") - 1);
		json_data.AddArray(msg);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        TopMsgNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct SysMsgNtf:Protocol<SysMsgNtf>
{
	unsigned char             foreground; //消息前景颜色ID
	unsigned char             background; //消息背景颜色ID
	DataArray<unsigned char, unsigned short> msg; //消息内容
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(foreground);

		net_data.AddIntegral(background);

		net_data.AddArray(msg);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(foreground);

		net_data.AddIntegral(background);

		net_data.AddArray(msg);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(foreground))
			return false;

		if (!net_data.DelIntegral(background))
			return false;

		if(!net_data.DelArray(msg))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(foreground))
			return false;

		if (!net_data.DelIntegral(background))
			return false;

		if(!net_data.DelArray(msg))
			return false;

		return true;
	}
	void Reset(void)
	{
		foreground = 0;

		background = 0;

		msg.clear();

	}
	SysMsgNtf& operator= (const SysMsgNtf& src)
	{
		foreground = src.foreground;

		background = src.background;

		msg = src.msg;

		return *this;
	}
	bool operator==(const SysMsgNtf& src) const
	{
		if (foreground != src.foreground)
		{
			return false;
		}

		if (background != src.background)
		{
			return false;
		}

		if (msg != src.msg)
		{
			return false;
		}

		return true;
	}
	bool operator != (const SysMsgNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(SysMsgNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.foreground, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.background, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 2:
            {
                m_assigned_bitset.set(m_state);
                DataArrayHandler<unsigned char, unsigned short> handler(m_data.msg, this);
                handler.String(str, length, copy);
            }
            break;
            default:
            {
                m_state = 0;
                return true;
            }
            }

            m_state++;
            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        SysMsgNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<3> m_assigned_bitset;

        static const std::bitset<3> template_assigned_bitset;
        static const char* m_key_list[3];
        static const char* m_alias_list[3];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"foreground", foreground);

		json_data.AddIntegral(u8"background", background);

		json_data.Writer().Key(u8"msg", sizeof(u8"msg") - 1);
		json_data.AddArray(msg);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        SysMsgNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct PopupMsgNtf:Protocol<PopupMsgNtf>
{
	unsigned char             type; //消息类型 0:通用 1:任务
	DataArray<unsigned char, unsigned short> msg; //消息内容
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(type);

		net_data.AddArray(msg);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(type);

		net_data.AddArray(msg);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(type))
			return false;

		if(!net_data.DelArray(msg))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(type))
			return false;

		if(!net_data.DelArray(msg))
			return false;

		return true;
	}
	void Reset(void)
	{
		type = 0;

		msg.clear();

	}
	PopupMsgNtf& operator= (const PopupMsgNtf& src)
	{
		type = src.type;

		msg = src.msg;

		return *this;
	}
	bool operator==(const PopupMsgNtf& src) const
	{
		if (type != src.type)
		{
			return false;
		}

		if (msg != src.msg)
		{
			return false;
		}

		return true;
	}
	bool operator != (const PopupMsgNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(PopupMsgNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.type, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 1:
            {
                m_assigned_bitset.set(m_state);
                DataArrayHandler<unsigned char, unsigned short> handler(m_data.msg, this);
                handler.String(str, length, copy);
            }
            break;
            default:
            {
                m_state = 0;
                return true;
            }
            }

            m_state++;
            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        PopupMsgNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"type", type);

		json_data.Writer().Key(u8"msg", sizeof(u8"msg") - 1);
		json_data.AddArray(msg);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        PopupMsgNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct ItemContainerNtf:Protocol<ItemContainerNtf>
{
	unsigned long long        guid; //容器属于谁(玩家、宠物)
	unsigned short            container_type; //item容器类型
	unsigned short            capacity; //item容器容量
	DataArray<ItemData, unsigned short> items; //物品列表
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(guid);

		net_data.AddIntegral(container_type);

		net_data.AddIntegral(capacity);

		net_data.AddArray(items);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(guid);

		net_data.AddIntegral(container_type);

		net_data.AddIntegral(capacity);

		net_data.AddArray(items);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!net_data.DelIntegral(container_type))
			return false;

		if (!net_data.DelIntegral(capacity))
			return false;

		if(!net_data.DelArray(items))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!net_data.DelIntegral(container_type))
			return false;

		if (!net_data.DelIntegral(capacity))
			return false;

		if(!net_data.DelArray(items))
			return false;

		return true;
	}
	void Reset(void)
	{
		guid = 0;

		container_type = 0;

		capacity = 0;

		items.clear();

	}
	ItemContainerNtf& operator= (const ItemContainerNtf& src)
	{
		guid = src.guid;

		container_type = src.container_type;

		capacity = src.capacity;

		items = src.items;

		return *this;
	}
	bool operator==(const ItemContainerNtf& src) const
	{
		if (guid != src.guid)
		{
			return false;
		}

		if (container_type != src.container_type)
		{
			return false;
		}

		if (capacity != src.capacity)
		{
			return false;
		}

		if (items != src.items)
		{
			return false;
		}

		return true;
	}
	bool operator != (const ItemContainerNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(ItemContainerNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_items_handler(m_data.items, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_items_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.guid, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.container_type, str, length);
            }
            break;
            case 2:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.capacity, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            switch (m_state)
            {
            case 3:
            {
                m_assigned_bitset.set(m_state);
                return &m_items_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)elementCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_items_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        ItemContainerNtf& m_data;
        DataArrayHandler<ItemData, unsigned short, ItemData::Handler> m_items_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<4> m_assigned_bitset;

        static const std::bitset<4> template_assigned_bitset;
        static const char* m_key_list[4];
        static const char* m_alias_list[4];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"guid", guid);

		json_data.AddIntegral(u8"container_type", container_type);

		json_data.AddIntegral(u8"capacity", capacity);

		json_data.Writer().Key(u8"items", sizeof(u8"items") - 1);
		json_data.AddArray(items);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        ItemContainerNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct ItemContainerUpdateNtf:Protocol<ItemContainerUpdateNtf>
{
	unsigned long long        guid; //容器属于谁(玩家、宠物)
	unsigned short            container_type; //item容器类型
	unsigned short            capacity; //item容器容量
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(guid);

		net_data.AddIntegral(container_type);

		net_data.AddIntegral(capacity);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(guid);

		net_data.AddIntegral(container_type);

		net_data.AddIntegral(capacity);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!net_data.DelIntegral(container_type))
			return false;

		if (!net_data.DelIntegral(capacity))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!net_data.DelIntegral(container_type))
			return false;

		if (!net_data.DelIntegral(capacity))
			return false;

		return true;
	}
	void Reset(void)
	{
		guid = 0;

		container_type = 0;

		capacity = 0;

	}
	ItemContainerUpdateNtf& operator= (const ItemContainerUpdateNtf& src)
	{
		guid = src.guid;

		container_type = src.container_type;

		capacity = src.capacity;

		return *this;
	}
	bool operator==(const ItemContainerUpdateNtf& src) const
	{
		if (guid != src.guid)
		{
			return false;
		}

		if (container_type != src.container_type)
		{
			return false;
		}

		if (capacity != src.capacity)
		{
			return false;
		}

		return true;
	}
	bool operator != (const ItemContainerUpdateNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(ItemContainerUpdateNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.guid, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.container_type, str, length);
            }
            break;
            case 2:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.capacity, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        ItemContainerUpdateNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<3> m_assigned_bitset;

        static const std::bitset<3> template_assigned_bitset;
        static const char* m_key_list[3];
        static const char* m_alias_list[3];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"guid", guid);

		json_data.AddIntegral(u8"container_type", container_type);

		json_data.AddIntegral(u8"capacity", capacity);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        ItemContainerUpdateNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct SubmitForm:Protocol<SubmitForm>
{
	char                      form[256]; //表单table
	char                      func[256]; //表单函数
	DataArray<ParamData, unsigned char> args; //脚本命令参数
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddString(form, sizeof(form));

		net_data.AddString(func, sizeof(func));

		net_data.AddArray(args);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddString(form, sizeof(form));

		net_data.AddString(func, sizeof(func));

		net_data.AddArray(args);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelString(form, sizeof(form)))
			return false;

		if (!net_data.DelString(func, sizeof(func)))
			return false;

		if(!net_data.DelArray(args))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelString(form, sizeof(form)))
			return false;

		if (!net_data.DelString(func, sizeof(func)))
			return false;

		if(!net_data.DelArray(args))
			return false;

		return true;
	}
	void Reset(void)
	{
		form[0] = 0;

		func[0] = 0;

		args.clear();

	}
	SubmitForm& operator= (const SubmitForm& src)
	{
		{
			size_t str_len = strnlen(src.form, sizeof(form) - 1);
			memcpy(form, src.form, str_len + 1);
			form[sizeof(form) - 1] = 0;
		}

		{
			size_t str_len = strnlen(src.func, sizeof(func) - 1);
			memcpy(func, src.func, str_len + 1);
			func[sizeof(func) - 1] = 0;
		}

		args = src.args;

		return *this;
	}
	bool operator==(const SubmitForm& src) const
	{
		if (strncmp(form, src.form, sizeof(form)-1))
		{
			return false;
		}

		if (strncmp(func, src.func, sizeof(func)-1))
		{
			return false;
		}

		if (args != src.args)
		{
			return false;
		}

		return true;
	}
	bool operator != (const SubmitForm& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(SubmitForm& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_args_handler(m_data.args, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_args_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelString(m_data.form, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelString(m_data.func, str, length);
            }
            break;
            default:
            {
                m_state = 0;
                return true;
            }
            }

            m_state++;
            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            switch (m_state)
            {
            case 2:
            {
                m_assigned_bitset.set(m_state);
                return &m_args_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)elementCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_args_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        SubmitForm& m_data;
        DataArrayHandler<ParamData, unsigned char, ParamData::Handler> m_args_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<3> m_assigned_bitset;

        static const std::bitset<3> template_assigned_bitset;
        static const char* m_key_list[3];
        static const char* m_alias_list[3];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddString(u8"form", form, sizeof(form));

		json_data.AddString(u8"func", func, sizeof(func));

		json_data.Writer().Key(u8"args", sizeof(u8"args") - 1);
		json_data.AddArray(args);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        SubmitForm::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct ShowFormNtf:Protocol<ShowFormNtf>
{
	char                      form[256]; //表单名称
	unsigned char             compressed; //是否压缩：1-压缩，0-未压缩
	DataArray<unsigned char, unsigned short> context; //表单内容
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddString(form, sizeof(form));

		net_data.AddIntegral(compressed);

		net_data.AddArray(context);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddString(form, sizeof(form));

		net_data.AddIntegral(compressed);

		net_data.AddArray(context);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelString(form, sizeof(form)))
			return false;

		if (!net_data.DelIntegral(compressed))
			return false;

		if(!net_data.DelArray(context))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelString(form, sizeof(form)))
			return false;

		if (!net_data.DelIntegral(compressed))
			return false;

		if(!net_data.DelArray(context))
			return false;

		return true;
	}
	void Reset(void)
	{
		form[0] = 0;

		compressed = 0;

		context.clear();

	}
	ShowFormNtf& operator= (const ShowFormNtf& src)
	{
		{
			size_t str_len = strnlen(src.form, sizeof(form) - 1);
			memcpy(form, src.form, str_len + 1);
			form[sizeof(form) - 1] = 0;
		}

		compressed = src.compressed;

		context = src.context;

		return *this;
	}
	bool operator==(const ShowFormNtf& src) const
	{
		if (strncmp(form, src.form, sizeof(form)-1))
		{
			return false;
		}

		if (compressed != src.compressed)
		{
			return false;
		}

		if (context != src.context)
		{
			return false;
		}

		return true;
	}
	bool operator != (const ShowFormNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(ShowFormNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.compressed, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelString(m_data.form, str, length);
            }
            break;
            case 2:
            {
                m_assigned_bitset.set(m_state);
                DataArrayHandler<unsigned char, unsigned short> handler(m_data.context, this);
                handler.String(str, length, copy);
            }
            break;
            default:
            {
                m_state = 0;
                return true;
            }
            }

            m_state++;
            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        ShowFormNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<3> m_assigned_bitset;

        static const std::bitset<3> template_assigned_bitset;
        static const char* m_key_list[3];
        static const char* m_alias_list[3];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddString(u8"form", form, sizeof(form));

		json_data.AddIntegral(u8"compressed", compressed);

		json_data.Writer().Key(u8"context", sizeof(u8"context") - 1);
		json_data.AddArray(context);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        ShowFormNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct ExecuteGMReq:Protocol<ExecuteGMReq>
{
	char                      cmd[256]; //GM命令
	char                      arg[256]; //GM命令参数
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddString(cmd, sizeof(cmd));

		net_data.AddString(arg, sizeof(arg));

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddString(cmd, sizeof(cmd));

		net_data.AddString(arg, sizeof(arg));

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelString(cmd, sizeof(cmd)))
			return false;

		if (!net_data.DelString(arg, sizeof(arg)))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelString(cmd, sizeof(cmd)))
			return false;

		if (!net_data.DelString(arg, sizeof(arg)))
			return false;

		return true;
	}
	void Reset(void)
	{
		cmd[0] = 0;

		arg[0] = 0;

	}
	ExecuteGMReq& operator= (const ExecuteGMReq& src)
	{
		{
			size_t str_len = strnlen(src.cmd, sizeof(cmd) - 1);
			memcpy(cmd, src.cmd, str_len + 1);
			cmd[sizeof(cmd) - 1] = 0;
		}

		{
			size_t str_len = strnlen(src.arg, sizeof(arg) - 1);
			memcpy(arg, src.arg, str_len + 1);
			arg[sizeof(arg) - 1] = 0;
		}

		return *this;
	}
	bool operator==(const ExecuteGMReq& src) const
	{
		if (strncmp(cmd, src.cmd, sizeof(cmd)-1))
		{
			return false;
		}

		if (strncmp(arg, src.arg, sizeof(arg)-1))
		{
			return false;
		}

		return true;
	}
	bool operator != (const ExecuteGMReq& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(ExecuteGMReq& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelString(m_data.cmd, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelString(m_data.arg, str, length);
            }
            break;
            default:
            {
                m_state = 0;
                return true;
            }
            }

            m_state++;
            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        ExecuteGMReq& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddString(u8"cmd", cmd, sizeof(cmd));

		json_data.AddString(u8"arg", arg, sizeof(arg));

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        ExecuteGMReq::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct FightBeginNtf:Protocol<FightBeginNtf>
{
	DataArray<FightGroupData, unsigned char> groups; //战斗组信息
	unsigned char             self_group; //自己所属的组
	unsigned char             is_pvp; //是否pvp战斗
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddArray(groups);

		net_data.AddIntegral(self_group);

		net_data.AddIntegral(is_pvp);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddArray(groups);

		net_data.AddIntegral(self_group);

		net_data.AddIntegral(is_pvp);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if(!net_data.DelArray(groups))
			return false;

		if (!net_data.DelIntegral(self_group))
			return false;

		if (!net_data.DelIntegral(is_pvp))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if(!net_data.DelArray(groups))
			return false;

		if (!net_data.DelIntegral(self_group))
			return false;

		if (!net_data.DelIntegral(is_pvp))
			return false;

		return true;
	}
	void Reset(void)
	{
		groups.clear();

		self_group = 0;

		is_pvp = 0;

	}
	FightBeginNtf& operator= (const FightBeginNtf& src)
	{
		groups = src.groups;

		self_group = src.self_group;

		is_pvp = src.is_pvp;

		return *this;
	}
	bool operator==(const FightBeginNtf& src) const
	{
		if (groups != src.groups)
		{
			return false;
		}

		if (self_group != src.self_group)
		{
			return false;
		}

		if (is_pvp != src.is_pvp)
		{
			return false;
		}

		return true;
	}
	bool operator != (const FightBeginNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(FightBeginNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_groups_handler(m_data.groups, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_groups_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.self_group, str, length);
            }
            break;
            case 2:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.is_pvp, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                return &m_groups_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)elementCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_groups_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        FightBeginNtf& m_data;
        DataArrayHandler<FightGroupData, unsigned char, FightGroupData::Handler> m_groups_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<3> m_assigned_bitset;

        static const std::bitset<3> template_assigned_bitset;
        static const char* m_key_list[3];
        static const char* m_alias_list[3];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.Writer().Key(u8"groups", sizeof(u8"groups") - 1);
		json_data.AddArray(groups);

		json_data.AddIntegral(u8"self_group", self_group);

		json_data.AddIntegral(u8"is_pvp", is_pvp);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        FightBeginNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct TurnRoundNtf:Protocol<TurnRoundNtf>
{
	unsigned short            round; //回合数
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(round);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(round);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(round))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(round))
			return false;

		return true;
	}
	void Reset(void)
	{
		round = 0;

	}
	TurnRoundNtf& operator= (const TurnRoundNtf& src)
	{
		round = src.round;

		return *this;
	}
	bool operator==(const TurnRoundNtf& src) const
	{
		if (round != src.round)
		{
			return false;
		}

		return true;
	}
	bool operator != (const TurnRoundNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(TurnRoundNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.round, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        TurnRoundNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"round", round);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        TurnRoundNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct FightOperateListNtf:Protocol<FightOperateListNtf>
{
	DataArray<unsigned char, unsigned char> player_operates; //玩家允许操作的指令列表
	DataArray<unsigned char, unsigned char> pet_operates; //宠物允许操作的指令列表
	unsigned short            count_down; //倒计时 单位:毫秒
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddArray(player_operates);

		net_data.AddArray(pet_operates);

		net_data.AddIntegral(count_down);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddArray(player_operates);

		net_data.AddArray(pet_operates);

		net_data.AddIntegral(count_down);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if(!net_data.DelArray(player_operates))
			return false;

		if(!net_data.DelArray(pet_operates))
			return false;

		if (!net_data.DelIntegral(count_down))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if(!net_data.DelArray(player_operates))
			return false;

		if(!net_data.DelArray(pet_operates))
			return false;

		if (!net_data.DelIntegral(count_down))
			return false;

		return true;
	}
	void Reset(void)
	{
		player_operates.clear();

		pet_operates.clear();

		count_down = 0;

	}
	FightOperateListNtf& operator= (const FightOperateListNtf& src)
	{
		player_operates = src.player_operates;

		pet_operates = src.pet_operates;

		count_down = src.count_down;

		return *this;
	}
	bool operator==(const FightOperateListNtf& src) const
	{
		if (player_operates != src.player_operates)
		{
			return false;
		}

		if (pet_operates != src.pet_operates)
		{
			return false;
		}

		if (count_down != src.count_down)
		{
			return false;
		}

		return true;
	}
	bool operator != (const FightOperateListNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(FightOperateListNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 2:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.count_down, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                DataArrayHandler<unsigned char, unsigned char> handler(m_data.player_operates, this);
                handler.String(str, length, copy);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                DataArrayHandler<unsigned char, unsigned char> handler(m_data.pet_operates, this);
                handler.String(str, length, copy);
            }
            break;
            default:
            {
                m_state = 0;
                return true;
            }
            }

            m_state++;
            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        FightOperateListNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<3> m_assigned_bitset;

        static const std::bitset<3> template_assigned_bitset;
        static const char* m_key_list[3];
        static const char* m_alias_list[3];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.Writer().Key(u8"player_operates", sizeof(u8"player_operates") - 1);
		json_data.AddArray(player_operates);

		json_data.Writer().Key(u8"pet_operates", sizeof(u8"pet_operates") - 1);
		json_data.AddArray(pet_operates);

		json_data.AddIntegral(u8"count_down", count_down);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        FightOperateListNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct FightOperateReq:Protocol<FightOperateReq>
{
	FightOperateData          operate; //操作数据
	bool EnCode(NetEnCode& net_data)
	{
		operate.EnCode(net_data);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		operate.EnCode(net_data);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!operate.DeCode(net_data))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!operate.DeCode(net_data))
			return false;

		return true;
	}
	void Reset(void)
	{
		operate.Reset();

	}
	FightOperateReq& operator= (const FightOperateReq& src)
	{
		operate = src.operate;

		return *this;
	}
	bool operator==(const FightOperateReq& src) const
	{
		if (operate != src.operate)
		{
			return false;
		}

		return true;
	}
	bool operator != (const FightOperateReq& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(FightOperateReq& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_operate_handler(m_data.operate, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_operate_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                return &m_operate_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)memberCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_operate_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        FightOperateReq& m_data;
        FightOperateData::Handler m_operate_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.Writer().Key(u8"operate", sizeof(u8"operate") - 1);
		operate.ToJson(json_data);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        FightOperateReq::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct FightOperateAck:Protocol<FightOperateAck>
{
	int                       errcode; //错误码
	char                      errmsg[256]; //错误描述
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(errcode);

		net_data.AddString(errmsg, sizeof(errmsg));

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(errcode);

		net_data.AddString(errmsg, sizeof(errmsg));

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(errcode))
			return false;

		if (!net_data.DelString(errmsg, sizeof(errmsg)))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(errcode))
			return false;

		if (!net_data.DelString(errmsg, sizeof(errmsg)))
			return false;

		return true;
	}
	void Reset(void)
	{
		errcode = 0;

		errmsg[0] = 0;

	}
	FightOperateAck& operator= (const FightOperateAck& src)
	{
		errcode = src.errcode;

		{
			size_t str_len = strnlen(src.errmsg, sizeof(errmsg) - 1);
			memcpy(errmsg, src.errmsg, str_len + 1);
			errmsg[sizeof(errmsg) - 1] = 0;
		}

		return *this;
	}
	bool operator==(const FightOperateAck& src) const
	{
		if (errcode != src.errcode)
		{
			return false;
		}

		if (strncmp(errmsg, src.errmsg, sizeof(errmsg)-1))
		{
			return false;
		}

		return true;
	}
	bool operator != (const FightOperateAck& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(FightOperateAck& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.errcode, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelString(m_data.errmsg, str, length);
            }
            break;
            default:
            {
                m_state = 0;
                return true;
            }
            }

            m_state++;
            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        FightOperateAck& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"errcode", errcode);

		json_data.AddString(u8"errmsg", errmsg, sizeof(errmsg));

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        FightOperateAck::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct FightOperateNtf:Protocol<FightOperateNtf>
{
	unsigned short            fighter_id; //战斗者id
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(fighter_id);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(fighter_id);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(fighter_id))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(fighter_id))
			return false;

		return true;
	}
	void Reset(void)
	{
		fighter_id = 0;

	}
	FightOperateNtf& operator= (const FightOperateNtf& src)
	{
		fighter_id = src.fighter_id;

		return *this;
	}
	bool operator==(const FightOperateNtf& src) const
	{
		if (fighter_id != src.fighter_id)
		{
			return false;
		}

		return true;
	}
	bool operator != (const FightOperateNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(FightOperateNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.fighter_id, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        FightOperateNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"fighter_id", fighter_id);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        FightOperateNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct FightDisplayNtf:Protocol<FightDisplayNtf>
{
	DataArray<unsigned char, unsigned int> data; //显示数据
	DataArray<unsigned char, unsigned char> crypto; //加密串,显示完成时原样返回
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddArray(data);

		net_data.AddArray(crypto);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddArray(data);

		net_data.AddArray(crypto);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if(!net_data.DelArray(data))
			return false;

		if(!net_data.DelArray(crypto))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if(!net_data.DelArray(data))
			return false;

		if(!net_data.DelArray(crypto))
			return false;

		return true;
	}
	void Reset(void)
	{
		data.clear();

		crypto.clear();

	}
	FightDisplayNtf& operator= (const FightDisplayNtf& src)
	{
		data = src.data;

		crypto = src.crypto;

		return *this;
	}
	bool operator==(const FightDisplayNtf& src) const
	{
		if (data != src.data)
		{
			return false;
		}

		if (crypto != src.crypto)
		{
			return false;
		}

		return true;
	}
	bool operator != (const FightDisplayNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(FightDisplayNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                DataArrayHandler<unsigned char, unsigned int> handler(m_data.data, this);
                handler.String(str, length, copy);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                DataArrayHandler<unsigned char, unsigned char> handler(m_data.crypto, this);
                handler.String(str, length, copy);
            }
            break;
            default:
            {
                m_state = 0;
                return true;
            }
            }

            m_state++;
            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        FightDisplayNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.Writer().Key(u8"data", sizeof(u8"data") - 1);
		json_data.AddArray(data);

		json_data.Writer().Key(u8"crypto", sizeof(u8"crypto") - 1);
		json_data.AddArray(crypto);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        FightDisplayNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct FightDisplayCompleteNtf:Protocol<FightDisplayCompleteNtf>
{
	DataArray<unsigned char, unsigned char> crypto; //加密串
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddArray(crypto);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddArray(crypto);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if(!net_data.DelArray(crypto))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if(!net_data.DelArray(crypto))
			return false;

		return true;
	}
	void Reset(void)
	{
		crypto.clear();

	}
	FightDisplayCompleteNtf& operator= (const FightDisplayCompleteNtf& src)
	{
		crypto = src.crypto;

		return *this;
	}
	bool operator==(const FightDisplayCompleteNtf& src) const
	{
		if (crypto != src.crypto)
		{
			return false;
		}

		return true;
	}
	bool operator != (const FightDisplayCompleteNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(FightDisplayCompleteNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                DataArrayHandler<unsigned char, unsigned char> handler(m_data.crypto, this);
                handler.String(str, length, copy);
            }
            break;
            default:
            {
                m_state = 0;
                return true;
            }
            }

            m_state++;
            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        FightDisplayCompleteNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.Writer().Key(u8"crypto", sizeof(u8"crypto") - 1);
		json_data.AddArray(crypto);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        FightDisplayCompleteNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct FightAutoReq:Protocol<FightAutoReq>
{
	unsigned char             is_auto; //0:关闭 1:开启
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(is_auto);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(is_auto);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(is_auto))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(is_auto))
			return false;

		return true;
	}
	void Reset(void)
	{
		is_auto = 0;

	}
	FightAutoReq& operator= (const FightAutoReq& src)
	{
		is_auto = src.is_auto;

		return *this;
	}
	bool operator==(const FightAutoReq& src) const
	{
		if (is_auto != src.is_auto)
		{
			return false;
		}

		return true;
	}
	bool operator != (const FightAutoReq& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(FightAutoReq& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.is_auto, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        FightAutoReq& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"is_auto", is_auto);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        FightAutoReq::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct FightAutoAck:Protocol<FightAutoAck>
{
	unsigned char             is_auto; //0:关闭 1:开启
	int                       errcode; //错误码
	char                      errmsg[256]; //错误描述
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(is_auto);

		net_data.AddIntegral(errcode);

		net_data.AddString(errmsg, sizeof(errmsg));

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(is_auto);

		net_data.AddIntegral(errcode);

		net_data.AddString(errmsg, sizeof(errmsg));

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(is_auto))
			return false;

		if (!net_data.DelIntegral(errcode))
			return false;

		if (!net_data.DelString(errmsg, sizeof(errmsg)))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(is_auto))
			return false;

		if (!net_data.DelIntegral(errcode))
			return false;

		if (!net_data.DelString(errmsg, sizeof(errmsg)))
			return false;

		return true;
	}
	void Reset(void)
	{
		is_auto = 0;

		errcode = 0;

		errmsg[0] = 0;

	}
	FightAutoAck& operator= (const FightAutoAck& src)
	{
		is_auto = src.is_auto;

		errcode = src.errcode;

		{
			size_t str_len = strnlen(src.errmsg, sizeof(errmsg) - 1);
			memcpy(errmsg, src.errmsg, str_len + 1);
			errmsg[sizeof(errmsg) - 1] = 0;
		}

		return *this;
	}
	bool operator==(const FightAutoAck& src) const
	{
		if (is_auto != src.is_auto)
		{
			return false;
		}

		if (errcode != src.errcode)
		{
			return false;
		}

		if (strncmp(errmsg, src.errmsg, sizeof(errmsg)-1))
		{
			return false;
		}

		return true;
	}
	bool operator != (const FightAutoAck& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(FightAutoAck& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.is_auto, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.errcode, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 2:
            {
                m_assigned_bitset.set(m_state);
                JsonDelString(m_data.errmsg, str, length);
            }
            break;
            default:
            {
                m_state = 0;
                return true;
            }
            }

            m_state++;
            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        FightAutoAck& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<3> m_assigned_bitset;

        static const std::bitset<3> template_assigned_bitset;
        static const char* m_key_list[3];
        static const char* m_alias_list[3];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"is_auto", is_auto);

		json_data.AddIntegral(u8"errcode", errcode);

		json_data.AddString(u8"errmsg", errmsg, sizeof(errmsg));

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        FightAutoAck::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct FightAutoNtf:Protocol<FightAutoNtf>
{
	unsigned short            fighter_id; //战斗者id
	unsigned char             is_auto; //0:关闭 1:开启
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(fighter_id);

		net_data.AddIntegral(is_auto);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(fighter_id);

		net_data.AddIntegral(is_auto);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(fighter_id))
			return false;

		if (!net_data.DelIntegral(is_auto))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(fighter_id))
			return false;

		if (!net_data.DelIntegral(is_auto))
			return false;

		return true;
	}
	void Reset(void)
	{
		fighter_id = 0;

		is_auto = 0;

	}
	FightAutoNtf& operator= (const FightAutoNtf& src)
	{
		fighter_id = src.fighter_id;

		is_auto = src.is_auto;

		return *this;
	}
	bool operator==(const FightAutoNtf& src) const
	{
		if (fighter_id != src.fighter_id)
		{
			return false;
		}

		if (is_auto != src.is_auto)
		{
			return false;
		}

		return true;
	}
	bool operator != (const FightAutoNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(FightAutoNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.fighter_id, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.is_auto, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        FightAutoNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"fighter_id", fighter_id);

		json_data.AddIntegral(u8"is_auto", is_auto);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        FightAutoNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct FightAutoSkillReq:Protocol<FightAutoSkillReq>
{
	unsigned long long        actor; //发起者guid 玩家自己:填0 宠物:填宠物guid
	unsigned short            skillid; //技能id
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(actor);

		net_data.AddIntegral(skillid);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(actor);

		net_data.AddIntegral(skillid);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(actor))
			return false;

		if (!net_data.DelIntegral(skillid))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(actor))
			return false;

		if (!net_data.DelIntegral(skillid))
			return false;

		return true;
	}
	void Reset(void)
	{
		actor = 0;

		skillid = 0;

	}
	FightAutoSkillReq& operator= (const FightAutoSkillReq& src)
	{
		actor = src.actor;

		skillid = src.skillid;

		return *this;
	}
	bool operator==(const FightAutoSkillReq& src) const
	{
		if (actor != src.actor)
		{
			return false;
		}

		if (skillid != src.skillid)
		{
			return false;
		}

		return true;
	}
	bool operator != (const FightAutoSkillReq& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(FightAutoSkillReq& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.actor, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.skillid, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        FightAutoSkillReq& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"actor", actor);

		json_data.AddIntegral(u8"skillid", skillid);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        FightAutoSkillReq::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct FightAutoSkillAck:Protocol<FightAutoSkillAck>
{
	unsigned long long        actor; //发起者guid 玩家自己:填0 宠物:填宠物guid
	unsigned short            skillid; //技能id
	int                       errcode; //错误码
	char                      errmsg[256]; //错误描述
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(actor);

		net_data.AddIntegral(skillid);

		net_data.AddIntegral(errcode);

		net_data.AddString(errmsg, sizeof(errmsg));

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(actor);

		net_data.AddIntegral(skillid);

		net_data.AddIntegral(errcode);

		net_data.AddString(errmsg, sizeof(errmsg));

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(actor))
			return false;

		if (!net_data.DelIntegral(skillid))
			return false;

		if (!net_data.DelIntegral(errcode))
			return false;

		if (!net_data.DelString(errmsg, sizeof(errmsg)))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(actor))
			return false;

		if (!net_data.DelIntegral(skillid))
			return false;

		if (!net_data.DelIntegral(errcode))
			return false;

		if (!net_data.DelString(errmsg, sizeof(errmsg)))
			return false;

		return true;
	}
	void Reset(void)
	{
		actor = 0;

		skillid = 0;

		errcode = 0;

		errmsg[0] = 0;

	}
	FightAutoSkillAck& operator= (const FightAutoSkillAck& src)
	{
		actor = src.actor;

		skillid = src.skillid;

		errcode = src.errcode;

		{
			size_t str_len = strnlen(src.errmsg, sizeof(errmsg) - 1);
			memcpy(errmsg, src.errmsg, str_len + 1);
			errmsg[sizeof(errmsg) - 1] = 0;
		}

		return *this;
	}
	bool operator==(const FightAutoSkillAck& src) const
	{
		if (actor != src.actor)
		{
			return false;
		}

		if (skillid != src.skillid)
		{
			return false;
		}

		if (errcode != src.errcode)
		{
			return false;
		}

		if (strncmp(errmsg, src.errmsg, sizeof(errmsg)-1))
		{
			return false;
		}

		return true;
	}
	bool operator != (const FightAutoSkillAck& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(FightAutoSkillAck& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.actor, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.skillid, str, length);
            }
            break;
            case 2:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.errcode, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 3:
            {
                m_assigned_bitset.set(m_state);
                JsonDelString(m_data.errmsg, str, length);
            }
            break;
            default:
            {
                m_state = 0;
                return true;
            }
            }

            m_state++;
            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        FightAutoSkillAck& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<4> m_assigned_bitset;

        static const std::bitset<4> template_assigned_bitset;
        static const char* m_key_list[4];
        static const char* m_alias_list[4];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"actor", actor);

		json_data.AddIntegral(u8"skillid", skillid);

		json_data.AddIntegral(u8"errcode", errcode);

		json_data.AddString(u8"errmsg", errmsg, sizeof(errmsg));

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        FightAutoSkillAck::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct FightEndNtf:Protocol<FightEndNtf>
{
	unsigned char             result; //战斗结果
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(result);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(result);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(result))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(result))
			return false;

		return true;
	}
	void Reset(void)
	{
		result = 0;

	}
	FightEndNtf& operator= (const FightEndNtf& src)
	{
		result = src.result;

		return *this;
	}
	bool operator==(const FightEndNtf& src) const
	{
		if (result != src.result)
		{
			return false;
		}

		return true;
	}
	bool operator != (const FightEndNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(FightEndNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.result, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        FightEndNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"result", result);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        FightEndNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct AddFighterNtf:Protocol<AddFighterNtf>
{
	FighterData               data; //战斗者信息
	unsigned char             group; //自己所属的组
	bool EnCode(NetEnCode& net_data)
	{
		data.EnCode(net_data);

		net_data.AddIntegral(group);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		data.EnCode(net_data);

		net_data.AddIntegral(group);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!data.DeCode(net_data))
			return false;

		if (!net_data.DelIntegral(group))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!data.DeCode(net_data))
			return false;

		if (!net_data.DelIntegral(group))
			return false;

		return true;
	}
	void Reset(void)
	{
		data.Reset();

		group = 0;

	}
	AddFighterNtf& operator= (const AddFighterNtf& src)
	{
		data = src.data;

		group = src.group;

		return *this;
	}
	bool operator==(const AddFighterNtf& src) const
	{
		if (data != src.data)
		{
			return false;
		}

		if (group != src.group)
		{
			return false;
		}

		return true;
	}
	bool operator != (const AddFighterNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(AddFighterNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_data_handler(m_data.data, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_data_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.group, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                return &m_data_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)memberCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_data_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        AddFighterNtf& m_data;
        FighterData::Handler m_data_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.Writer().Key(u8"data", sizeof(u8"data") - 1);
		data.ToJson(json_data);

		json_data.AddIntegral(u8"group", group);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        AddFighterNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct DelFighterNtf:Protocol<DelFighterNtf>
{
	unsigned short            fighter_id; //战斗者id
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(fighter_id);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(fighter_id);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(fighter_id))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(fighter_id))
			return false;

		return true;
	}
	void Reset(void)
	{
		fighter_id = 0;

	}
	DelFighterNtf& operator= (const DelFighterNtf& src)
	{
		fighter_id = src.fighter_id;

		return *this;
	}
	bool operator==(const DelFighterNtf& src) const
	{
		if (fighter_id != src.fighter_id)
		{
			return false;
		}

		return true;
	}
	bool operator != (const DelFighterNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(DelFighterNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.fighter_id, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        DelFighterNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"fighter_id", fighter_id);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        DelFighterNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct AddFightPetData:Protocol<AddFightPetData>
{
	FightPetData              pet; //战斗宠物数据
	bool EnCode(NetEnCode& net_data)
	{
		pet.EnCode(net_data);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		pet.EnCode(net_data);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!pet.DeCode(net_data))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!pet.DeCode(net_data))
			return false;

		return true;
	}
	void Reset(void)
	{
		pet.Reset();

	}
	AddFightPetData& operator= (const AddFightPetData& src)
	{
		pet = src.pet;

		return *this;
	}
	bool operator==(const AddFightPetData& src) const
	{
		if (pet != src.pet)
		{
			return false;
		}

		return true;
	}
	bool operator != (const AddFightPetData& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(AddFightPetData& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_pet_handler(m_data.pet, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_pet_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                return &m_pet_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)memberCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_pet_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        AddFightPetData& m_data;
        FightPetData::Handler m_pet_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.Writer().Key(u8"pet", sizeof(u8"pet") - 1);
		pet.ToJson(json_data);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        AddFightPetData::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct UpdateFightPetData:Protocol<UpdateFightPetData>
{
	FightPetData              pet; //战斗宠物数据
	bool EnCode(NetEnCode& net_data)
	{
		pet.EnCode(net_data);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		pet.EnCode(net_data);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!pet.DeCode(net_data))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!pet.DeCode(net_data))
			return false;

		return true;
	}
	void Reset(void)
	{
		pet.Reset();

	}
	UpdateFightPetData& operator= (const UpdateFightPetData& src)
	{
		pet = src.pet;

		return *this;
	}
	bool operator==(const UpdateFightPetData& src) const
	{
		if (pet != src.pet)
		{
			return false;
		}

		return true;
	}
	bool operator != (const UpdateFightPetData& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(UpdateFightPetData& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_pet_handler(m_data.pet, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_pet_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                return &m_pet_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)memberCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_pet_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        UpdateFightPetData& m_data;
        FightPetData::Handler m_pet_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.Writer().Key(u8"pet", sizeof(u8"pet") - 1);
		pet.ToJson(json_data);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        UpdateFightPetData::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct PlayerKillReq:Protocol<PlayerKillReq>
{
	unsigned long long        target; //玩家guid
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(target);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(target);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(target))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(target))
			return false;

		return true;
	}
	void Reset(void)
	{
		target = 0;

	}
	PlayerKillReq& operator= (const PlayerKillReq& src)
	{
		target = src.target;

		return *this;
	}
	bool operator==(const PlayerKillReq& src) const
	{
		if (target != src.target)
		{
			return false;
		}

		return true;
	}
	bool operator != (const PlayerKillReq& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(PlayerKillReq& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.target, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        PlayerKillReq& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"target", target);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        PlayerKillReq::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct PlayerKillAck:Protocol<PlayerKillAck>
{
	unsigned long long        target; //玩家guid
	int                       errcode; //错误码
	char                      errmsg[256]; //错误描述
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(target);

		net_data.AddIntegral(errcode);

		net_data.AddString(errmsg, sizeof(errmsg));

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(target);

		net_data.AddIntegral(errcode);

		net_data.AddString(errmsg, sizeof(errmsg));

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(target))
			return false;

		if (!net_data.DelIntegral(errcode))
			return false;

		if (!net_data.DelString(errmsg, sizeof(errmsg)))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(target))
			return false;

		if (!net_data.DelIntegral(errcode))
			return false;

		if (!net_data.DelString(errmsg, sizeof(errmsg)))
			return false;

		return true;
	}
	void Reset(void)
	{
		target = 0;

		errcode = 0;

		errmsg[0] = 0;

	}
	PlayerKillAck& operator= (const PlayerKillAck& src)
	{
		target = src.target;

		errcode = src.errcode;

		{
			size_t str_len = strnlen(src.errmsg, sizeof(errmsg) - 1);
			memcpy(errmsg, src.errmsg, str_len + 1);
			errmsg[sizeof(errmsg) - 1] = 0;
		}

		return *this;
	}
	bool operator==(const PlayerKillAck& src) const
	{
		if (target != src.target)
		{
			return false;
		}

		if (errcode != src.errcode)
		{
			return false;
		}

		if (strncmp(errmsg, src.errmsg, sizeof(errmsg)-1))
		{
			return false;
		}

		return true;
	}
	bool operator != (const PlayerKillAck& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(PlayerKillAck& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.target, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.errcode, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 2:
            {
                m_assigned_bitset.set(m_state);
                JsonDelString(m_data.errmsg, str, length);
            }
            break;
            default:
            {
                m_state = 0;
                return true;
            }
            }

            m_state++;
            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        PlayerKillAck& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<3> m_assigned_bitset;

        static const std::bitset<3> template_assigned_bitset;
        static const char* m_key_list[3];
        static const char* m_alias_list[3];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"target", target);

		json_data.AddIntegral(u8"errcode", errcode);

		json_data.AddString(u8"errmsg", errmsg, sizeof(errmsg));

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        PlayerKillAck::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct EnterFightViewReq:Protocol<EnterFightViewReq>
{
	unsigned long long        target; //观战目标guid
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(target);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(target);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(target))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(target))
			return false;

		return true;
	}
	void Reset(void)
	{
		target = 0;

	}
	EnterFightViewReq& operator= (const EnterFightViewReq& src)
	{
		target = src.target;

		return *this;
	}
	bool operator==(const EnterFightViewReq& src) const
	{
		if (target != src.target)
		{
			return false;
		}

		return true;
	}
	bool operator != (const EnterFightViewReq& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(EnterFightViewReq& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.target, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        EnterFightViewReq& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"target", target);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        EnterFightViewReq::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct EnterFightViewAck:Protocol<EnterFightViewAck>
{
	unsigned long long        target; //观战目标guid
	int                       errcode; //错误码
	char                      errmsg[256]; //错误描述
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(target);

		net_data.AddIntegral(errcode);

		net_data.AddString(errmsg, sizeof(errmsg));

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(target);

		net_data.AddIntegral(errcode);

		net_data.AddString(errmsg, sizeof(errmsg));

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(target))
			return false;

		if (!net_data.DelIntegral(errcode))
			return false;

		if (!net_data.DelString(errmsg, sizeof(errmsg)))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(target))
			return false;

		if (!net_data.DelIntegral(errcode))
			return false;

		if (!net_data.DelString(errmsg, sizeof(errmsg)))
			return false;

		return true;
	}
	void Reset(void)
	{
		target = 0;

		errcode = 0;

		errmsg[0] = 0;

	}
	EnterFightViewAck& operator= (const EnterFightViewAck& src)
	{
		target = src.target;

		errcode = src.errcode;

		{
			size_t str_len = strnlen(src.errmsg, sizeof(errmsg) - 1);
			memcpy(errmsg, src.errmsg, str_len + 1);
			errmsg[sizeof(errmsg) - 1] = 0;
		}

		return *this;
	}
	bool operator==(const EnterFightViewAck& src) const
	{
		if (target != src.target)
		{
			return false;
		}

		if (errcode != src.errcode)
		{
			return false;
		}

		if (strncmp(errmsg, src.errmsg, sizeof(errmsg)-1))
		{
			return false;
		}

		return true;
	}
	bool operator != (const EnterFightViewAck& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(EnterFightViewAck& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.target, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.errcode, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 2:
            {
                m_assigned_bitset.set(m_state);
                JsonDelString(m_data.errmsg, str, length);
            }
            break;
            default:
            {
                m_state = 0;
                return true;
            }
            }

            m_state++;
            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        EnterFightViewAck& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<3> m_assigned_bitset;

        static const std::bitset<3> template_assigned_bitset;
        static const char* m_key_list[3];
        static const char* m_alias_list[3];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"target", target);

		json_data.AddIntegral(u8"errcode", errcode);

		json_data.AddString(u8"errmsg", errmsg, sizeof(errmsg));

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        EnterFightViewAck::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct LeaveFightViewReq:Protocol<LeaveFightViewReq>
{
	bool EnCode(NetEnCode& net_data)
	{
		(void)(net_data);
		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		(void)(net_data);
		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		(void)(net_data);
		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		(void)(net_data);
		return true;
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(LeaveFightViewReq& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            return true;
        }
    private:
        LeaveFightViewReq& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        LeaveFightViewReq::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct LeaveFightViewAck:Protocol<LeaveFightViewAck>
{
	int                       errcode; //错误码
	char                      errmsg[256]; //错误描述
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(errcode);

		net_data.AddString(errmsg, sizeof(errmsg));

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(errcode);

		net_data.AddString(errmsg, sizeof(errmsg));

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(errcode))
			return false;

		if (!net_data.DelString(errmsg, sizeof(errmsg)))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(errcode))
			return false;

		if (!net_data.DelString(errmsg, sizeof(errmsg)))
			return false;

		return true;
	}
	void Reset(void)
	{
		errcode = 0;

		errmsg[0] = 0;

	}
	LeaveFightViewAck& operator= (const LeaveFightViewAck& src)
	{
		errcode = src.errcode;

		{
			size_t str_len = strnlen(src.errmsg, sizeof(errmsg) - 1);
			memcpy(errmsg, src.errmsg, str_len + 1);
			errmsg[sizeof(errmsg) - 1] = 0;
		}

		return *this;
	}
	bool operator==(const LeaveFightViewAck& src) const
	{
		if (errcode != src.errcode)
		{
			return false;
		}

		if (strncmp(errmsg, src.errmsg, sizeof(errmsg)-1))
		{
			return false;
		}

		return true;
	}
	bool operator != (const LeaveFightViewAck& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(LeaveFightViewAck& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.errcode, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelString(m_data.errmsg, str, length);
            }
            break;
            default:
            {
                m_state = 0;
                return true;
            }
            }

            m_state++;
            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        LeaveFightViewAck& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"errcode", errcode);

		json_data.AddString(u8"errmsg", errmsg, sizeof(errmsg));

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        LeaveFightViewAck::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct TeamLeaderOprReq:Protocol<TeamLeaderOprReq>
{
	unsigned char             opr; //队长操作
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(opr);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(opr);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(opr))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(opr))
			return false;

		return true;
	}
	void Reset(void)
	{
		opr = 0;

	}
	TeamLeaderOprReq& operator= (const TeamLeaderOprReq& src)
	{
		opr = src.opr;

		return *this;
	}
	bool operator==(const TeamLeaderOprReq& src) const
	{
		if (opr != src.opr)
		{
			return false;
		}

		return true;
	}
	bool operator != (const TeamLeaderOprReq& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(TeamLeaderOprReq& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.opr, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        TeamLeaderOprReq& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"opr", opr);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        TeamLeaderOprReq::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct TeamNtf:Protocol<TeamNtf>
{
	unsigned long long        team_guid; //队伍GUID
	unsigned short            target; //目标ID
	unsigned short            permission; //1=开启队友招人权限 0=关闭
	unsigned short            min_require_level; //最低要求等级
	unsigned short            max_require_level; //最高要求等级
	unsigned long long        leader_guid; //队长GUID
	DataArray<unsigned long long, unsigned char> leader_guards; //队长侍从GUID列表
	DataArray<MemberData, unsigned char> members; //队伍成员
	unsigned short            min_require_reinc; //最低要求转生次数
	unsigned short            max_require_reinc; //最高要求转生次数
	CustomData                customs; //自定义
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(team_guid);

		net_data.AddIntegral(target);

		net_data.AddIntegral(permission);

		net_data.AddIntegral(min_require_level);

		net_data.AddIntegral(max_require_level);

		net_data.AddIntegral(leader_guid);

		net_data.AddArray(leader_guards);

		net_data.AddArray(members);

		net_data.AddIntegral(min_require_reinc);

		net_data.AddIntegral(max_require_reinc);

		customs.EnCode(net_data);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(team_guid);

		net_data.AddIntegral(target);

		net_data.AddIntegral(permission);

		net_data.AddIntegral(min_require_level);

		net_data.AddIntegral(max_require_level);

		net_data.AddIntegral(leader_guid);

		net_data.AddArray(leader_guards);

		net_data.AddArray(members);

		net_data.AddIntegral(min_require_reinc);

		net_data.AddIntegral(max_require_reinc);

		customs.EnCode(net_data);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(team_guid))
			return false;

		if (!net_data.DelIntegral(target))
			return false;

		if (!net_data.DelIntegral(permission))
			return false;

		if (!net_data.DelIntegral(min_require_level))
			return false;

		if (!net_data.DelIntegral(max_require_level))
			return false;

		if (!net_data.DelIntegral(leader_guid))
			return false;

		if(!net_data.DelArray(leader_guards))
			return false;

		if(!net_data.DelArray(members))
			return false;

		if (!net_data.DelIntegral(min_require_reinc))
			return false;

		if (!net_data.DelIntegral(max_require_reinc))
			return false;

		if (!customs.DeCode(net_data))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(team_guid))
			return false;

		if (!net_data.DelIntegral(target))
			return false;

		if (!net_data.DelIntegral(permission))
			return false;

		if (!net_data.DelIntegral(min_require_level))
			return false;

		if (!net_data.DelIntegral(max_require_level))
			return false;

		if (!net_data.DelIntegral(leader_guid))
			return false;

		if(!net_data.DelArray(leader_guards))
			return false;

		if(!net_data.DelArray(members))
			return false;

		if (!net_data.DelIntegral(min_require_reinc))
			return false;

		if (!net_data.DelIntegral(max_require_reinc))
			return false;

		if (!customs.DeCode(net_data))
			return false;

		return true;
	}
	void Reset(void)
	{
		team_guid = 0;

		target = 0;

		permission = 0;

		min_require_level = 0;

		max_require_level = 0;

		leader_guid = 0;

		leader_guards.clear();

		members.clear();

		min_require_reinc = 0;

		max_require_reinc = 0;

		customs.Reset();

	}
	TeamNtf& operator= (const TeamNtf& src)
	{
		team_guid = src.team_guid;

		target = src.target;

		permission = src.permission;

		min_require_level = src.min_require_level;

		max_require_level = src.max_require_level;

		leader_guid = src.leader_guid;

		leader_guards = src.leader_guards;

		members = src.members;

		min_require_reinc = src.min_require_reinc;

		max_require_reinc = src.max_require_reinc;

		customs = src.customs;

		return *this;
	}
	bool operator==(const TeamNtf& src) const
	{
		if (team_guid != src.team_guid)
		{
			return false;
		}

		if (target != src.target)
		{
			return false;
		}

		if (permission != src.permission)
		{
			return false;
		}

		if (min_require_level != src.min_require_level)
		{
			return false;
		}

		if (max_require_level != src.max_require_level)
		{
			return false;
		}

		if (leader_guid != src.leader_guid)
		{
			return false;
		}

		if (leader_guards != src.leader_guards)
		{
			return false;
		}

		if (members != src.members)
		{
			return false;
		}

		if (min_require_reinc != src.min_require_reinc)
		{
			return false;
		}

		if (max_require_reinc != src.max_require_reinc)
		{
			return false;
		}

		if (customs != src.customs)
		{
			return false;
		}

		return true;
	}
	bool operator != (const TeamNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(TeamNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_customs_handler(m_data.customs, this),
            m_leader_guards_handler(m_data.leader_guards, this),
            m_members_handler(m_data.members, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_customs_handler.ResetState();
            m_members_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.team_guid, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.target, str, length);
            }
            break;
            case 2:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.permission, str, length);
            }
            break;
            case 3:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.min_require_level, str, length);
            }
            break;
            case 4:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.max_require_level, str, length);
            }
            break;
            case 5:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.leader_guid, str, length);
            }
            break;
            case 8:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.min_require_reinc, str, length);
            }
            break;
            case 9:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.max_require_reinc, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            switch (m_state)
            {
            case 10:
            {
                m_assigned_bitset.set(m_state);
                return &m_customs_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)memberCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        JsonHandler* StartArray() override
        {
            switch (m_state)
            {
            case 6:
            {
                m_assigned_bitset.set(m_state);
                return &m_leader_guards_handler;
            }
            break;
            case 7:
            {
                m_assigned_bitset.set(m_state);
                return &m_members_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)elementCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_leader_guards_handler.IsAllMemberSet())
            {
                return false;
            }

            if (!m_members_handler.IsAllMemberSet())
            {
                return false;
            }

            if (!m_customs_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        TeamNtf& m_data;
        CustomData::Handler m_customs_handler;
        DataArrayHandler<unsigned long long, unsigned char> m_leader_guards_handler;
        DataArrayHandler<MemberData, unsigned char, MemberData::Handler> m_members_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<11> m_assigned_bitset;

        static const std::bitset<11> template_assigned_bitset;
        static const char* m_key_list[11];
        static const char* m_alias_list[11];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"team_guid", team_guid);

		json_data.AddIntegral(u8"target", target);

		json_data.AddIntegral(u8"permission", permission);

		json_data.AddIntegral(u8"min_require_level", min_require_level);

		json_data.AddIntegral(u8"max_require_level", max_require_level);

		json_data.AddIntegral(u8"leader_guid", leader_guid);

		json_data.Writer().Key(u8"leader_guards", sizeof(u8"leader_guards") - 1);
		json_data.AddArray(leader_guards);

		json_data.Writer().Key(u8"members", sizeof(u8"members") - 1);
		json_data.AddArray(members);

		json_data.AddIntegral(u8"min_require_reinc", min_require_reinc);

		json_data.AddIntegral(u8"max_require_reinc", max_require_reinc);

		json_data.Writer().Key(u8"customs", sizeof(u8"customs") - 1);
		customs.ToJson(json_data);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        TeamNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct TeamLeaderNtf:Protocol<TeamLeaderNtf>
{
	unsigned long long        leader_guid; //队长GUID
	DataArray<unsigned long long, unsigned char> leader_guards; //队长侍从GUID列表
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(leader_guid);

		net_data.AddArray(leader_guards);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(leader_guid);

		net_data.AddArray(leader_guards);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(leader_guid))
			return false;

		if(!net_data.DelArray(leader_guards))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(leader_guid))
			return false;

		if(!net_data.DelArray(leader_guards))
			return false;

		return true;
	}
	void Reset(void)
	{
		leader_guid = 0;

		leader_guards.clear();

	}
	TeamLeaderNtf& operator= (const TeamLeaderNtf& src)
	{
		leader_guid = src.leader_guid;

		leader_guards = src.leader_guards;

		return *this;
	}
	bool operator==(const TeamLeaderNtf& src) const
	{
		if (leader_guid != src.leader_guid)
		{
			return false;
		}

		if (leader_guards != src.leader_guards)
		{
			return false;
		}

		return true;
	}
	bool operator != (const TeamLeaderNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(TeamLeaderNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_leader_guards_handler(m_data.leader_guards, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.leader_guid, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            switch (m_state)
            {
            case 1:
            {
                m_assigned_bitset.set(m_state);
                return &m_leader_guards_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)elementCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_leader_guards_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        TeamLeaderNtf& m_data;
        DataArrayHandler<unsigned long long, unsigned char> m_leader_guards_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"leader_guid", leader_guid);

		json_data.Writer().Key(u8"leader_guards", sizeof(u8"leader_guards") - 1);
		json_data.AddArray(leader_guards);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        TeamLeaderNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct TeamDestroyNtf:Protocol<TeamDestroyNtf>
{
	unsigned long long        team_guid; //队伍GUID
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(team_guid);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(team_guid);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(team_guid))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(team_guid))
			return false;

		return true;
	}
	void Reset(void)
	{
		team_guid = 0;

	}
	TeamDestroyNtf& operator= (const TeamDestroyNtf& src)
	{
		team_guid = src.team_guid;

		return *this;
	}
	bool operator==(const TeamDestroyNtf& src) const
	{
		if (team_guid != src.team_guid)
		{
			return false;
		}

		return true;
	}
	bool operator != (const TeamDestroyNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(TeamDestroyNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.team_guid, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        TeamDestroyNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"team_guid", team_guid);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        TeamDestroyNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct TeamMemberNtf:Protocol<TeamMemberNtf>
{
	MemberData                member; //队伍成员信息
	bool EnCode(NetEnCode& net_data)
	{
		member.EnCode(net_data);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		member.EnCode(net_data);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!member.DeCode(net_data))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!member.DeCode(net_data))
			return false;

		return true;
	}
	void Reset(void)
	{
		member.Reset();

	}
	TeamMemberNtf& operator= (const TeamMemberNtf& src)
	{
		member = src.member;

		return *this;
	}
	bool operator==(const TeamMemberNtf& src) const
	{
		if (member != src.member)
		{
			return false;
		}

		return true;
	}
	bool operator != (const TeamMemberNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(TeamMemberNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_member_handler(m_data.member, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_member_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                return &m_member_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)memberCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_member_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        TeamMemberNtf& m_data;
        MemberData::Handler m_member_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.Writer().Key(u8"member", sizeof(u8"member") - 1);
		member.ToJson(json_data);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        TeamMemberNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct TeamMemberLeaveNtf:Protocol<TeamMemberLeaveNtf>
{
	unsigned char             action; //1=被踢，2=主动退出, 3=暂离, 4=归队
	unsigned long long        player_guid; //成员guid
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(action);

		net_data.AddIntegral(player_guid);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(action);

		net_data.AddIntegral(player_guid);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(action))
			return false;

		if (!net_data.DelIntegral(player_guid))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(action))
			return false;

		if (!net_data.DelIntegral(player_guid))
			return false;

		return true;
	}
	void Reset(void)
	{
		action = 0;

		player_guid = 0;

	}
	TeamMemberLeaveNtf& operator= (const TeamMemberLeaveNtf& src)
	{
		action = src.action;

		player_guid = src.player_guid;

		return *this;
	}
	bool operator==(const TeamMemberLeaveNtf& src) const
	{
		if (action != src.action)
		{
			return false;
		}

		if (player_guid != src.player_guid)
		{
			return false;
		}

		return true;
	}
	bool operator != (const TeamMemberLeaveNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(TeamMemberLeaveNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.action, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.player_guid, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        TeamMemberLeaveNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"action", action);

		json_data.AddIntegral(u8"player_guid", player_guid);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        TeamMemberLeaveNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct NpcSelectReq:Protocol<NpcSelectReq>
{
	unsigned long long        npc_guid; //NPC guid
	unsigned short            select_id; //选择项id 0表示获取初始选项
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(npc_guid);

		net_data.AddIntegral(select_id);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(npc_guid);

		net_data.AddIntegral(select_id);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(npc_guid))
			return false;

		if (!net_data.DelIntegral(select_id))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(npc_guid))
			return false;

		if (!net_data.DelIntegral(select_id))
			return false;

		return true;
	}
	void Reset(void)
	{
		npc_guid = 0;

		select_id = 0;

	}
	NpcSelectReq& operator= (const NpcSelectReq& src)
	{
		npc_guid = src.npc_guid;

		select_id = src.select_id;

		return *this;
	}
	bool operator==(const NpcSelectReq& src) const
	{
		if (npc_guid != src.npc_guid)
		{
			return false;
		}

		if (select_id != src.select_id)
		{
			return false;
		}

		return true;
	}
	bool operator != (const NpcSelectReq& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(NpcSelectReq& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.npc_guid, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.select_id, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        NpcSelectReq& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"npc_guid", npc_guid);

		json_data.AddIntegral(u8"select_id", select_id);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        NpcSelectReq::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct NpcSelectAck:Protocol<NpcSelectAck>
{
	unsigned long long        npc_guid; //NPC guid
	DataArray<OptionData, unsigned short> options; //NPC选项
	char                      msg[4096]; //回应消息,没有就从npc表中读取
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(npc_guid);

		net_data.AddArray(options);

		net_data.AddString(msg, sizeof(msg));

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(npc_guid);

		net_data.AddArray(options);

		net_data.AddString(msg, sizeof(msg));

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(npc_guid))
			return false;

		if(!net_data.DelArray(options))
			return false;

		if (!net_data.DelString(msg, sizeof(msg)))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(npc_guid))
			return false;

		if(!net_data.DelArray(options))
			return false;

		if (!net_data.DelString(msg, sizeof(msg)))
			return false;

		return true;
	}
	void Reset(void)
	{
		npc_guid = 0;

		options.clear();

		msg[0] = 0;

	}
	NpcSelectAck& operator= (const NpcSelectAck& src)
	{
		npc_guid = src.npc_guid;

		options = src.options;

		{
			size_t str_len = strnlen(src.msg, sizeof(msg) - 1);
			memcpy(msg, src.msg, str_len + 1);
			msg[sizeof(msg) - 1] = 0;
		}

		return *this;
	}
	bool operator==(const NpcSelectAck& src) const
	{
		if (npc_guid != src.npc_guid)
		{
			return false;
		}

		if (options != src.options)
		{
			return false;
		}

		if (strncmp(msg, src.msg, sizeof(msg)-1))
		{
			return false;
		}

		return true;
	}
	bool operator != (const NpcSelectAck& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(NpcSelectAck& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_options_handler(m_data.options, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_options_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.npc_guid, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 2:
            {
                m_assigned_bitset.set(m_state);
                JsonDelString(m_data.msg, str, length);
            }
            break;
            default:
            {
                m_state = 0;
                return true;
            }
            }

            m_state++;
            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            switch (m_state)
            {
            case 1:
            {
                m_assigned_bitset.set(m_state);
                return &m_options_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)elementCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_options_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        NpcSelectAck& m_data;
        DataArrayHandler<OptionData, unsigned short, OptionData::Handler> m_options_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<3> m_assigned_bitset;

        static const std::bitset<3> template_assigned_bitset;
        static const char* m_key_list[3];
        static const char* m_alias_list[3];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"npc_guid", npc_guid);

		json_data.Writer().Key(u8"options", sizeof(u8"options") - 1);
		json_data.AddArray(options);

		json_data.AddString(u8"msg", msg, sizeof(msg));

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        NpcSelectAck::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct NpcTalkReq:Protocol<NpcTalkReq>
{
	unsigned long long        npc_guid; //NPC guid
	unsigned char             compressed; //是否压缩：1-压缩，0-未压缩
	DataArray<unsigned char, unsigned short> talk; //对话内容
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(npc_guid);

		net_data.AddIntegral(compressed);

		net_data.AddArray(talk);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(npc_guid);

		net_data.AddIntegral(compressed);

		net_data.AddArray(talk);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(npc_guid))
			return false;

		if (!net_data.DelIntegral(compressed))
			return false;

		if(!net_data.DelArray(talk))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(npc_guid))
			return false;

		if (!net_data.DelIntegral(compressed))
			return false;

		if(!net_data.DelArray(talk))
			return false;

		return true;
	}
	void Reset(void)
	{
		npc_guid = 0;

		compressed = 0;

		talk.clear();

	}
	NpcTalkReq& operator= (const NpcTalkReq& src)
	{
		npc_guid = src.npc_guid;

		compressed = src.compressed;

		talk = src.talk;

		return *this;
	}
	bool operator==(const NpcTalkReq& src) const
	{
		if (npc_guid != src.npc_guid)
		{
			return false;
		}

		if (compressed != src.compressed)
		{
			return false;
		}

		if (talk != src.talk)
		{
			return false;
		}

		return true;
	}
	bool operator != (const NpcTalkReq& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(NpcTalkReq& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.npc_guid, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.compressed, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 2:
            {
                m_assigned_bitset.set(m_state);
                DataArrayHandler<unsigned char, unsigned short> handler(m_data.talk, this);
                handler.String(str, length, copy);
            }
            break;
            default:
            {
                m_state = 0;
                return true;
            }
            }

            m_state++;
            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        NpcTalkReq& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<3> m_assigned_bitset;

        static const std::bitset<3> template_assigned_bitset;
        static const char* m_key_list[3];
        static const char* m_alias_list[3];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"npc_guid", npc_guid);

		json_data.AddIntegral(u8"compressed", compressed);

		json_data.Writer().Key(u8"talk", sizeof(u8"talk") - 1);
		json_data.AddArray(talk);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        NpcTalkReq::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct NpcTalkAck:Protocol<NpcTalkAck>
{
	unsigned long long        npc_guid; //NPC guid
	unsigned char             compressed; //是否压缩：1-压缩，0-未压缩
	DataArray<unsigned char, unsigned short> talk; //对话内容
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(npc_guid);

		net_data.AddIntegral(compressed);

		net_data.AddArray(talk);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(npc_guid);

		net_data.AddIntegral(compressed);

		net_data.AddArray(talk);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(npc_guid))
			return false;

		if (!net_data.DelIntegral(compressed))
			return false;

		if(!net_data.DelArray(talk))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(npc_guid))
			return false;

		if (!net_data.DelIntegral(compressed))
			return false;

		if(!net_data.DelArray(talk))
			return false;

		return true;
	}
	void Reset(void)
	{
		npc_guid = 0;

		compressed = 0;

		talk.clear();

	}
	NpcTalkAck& operator= (const NpcTalkAck& src)
	{
		npc_guid = src.npc_guid;

		compressed = src.compressed;

		talk = src.talk;

		return *this;
	}
	bool operator==(const NpcTalkAck& src) const
	{
		if (npc_guid != src.npc_guid)
		{
			return false;
		}

		if (compressed != src.compressed)
		{
			return false;
		}

		if (talk != src.talk)
		{
			return false;
		}

		return true;
	}
	bool operator != (const NpcTalkAck& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(NpcTalkAck& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.npc_guid, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.compressed, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 2:
            {
                m_assigned_bitset.set(m_state);
                DataArrayHandler<unsigned char, unsigned short> handler(m_data.talk, this);
                handler.String(str, length, copy);
            }
            break;
            default:
            {
                m_state = 0;
                return true;
            }
            }

            m_state++;
            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        NpcTalkAck& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<3> m_assigned_bitset;

        static const std::bitset<3> template_assigned_bitset;
        static const char* m_key_list[3];
        static const char* m_alias_list[3];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"npc_guid", npc_guid);

		json_data.AddIntegral(u8"compressed", compressed);

		json_data.Writer().Key(u8"talk", sizeof(u8"talk") - 1);
		json_data.AddArray(talk);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        NpcTalkAck::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct InviteMsgNtf:Protocol<InviteMsgNtf>
{
	unsigned long long        inviter_guid; //邀请人guid
	unsigned long long        type; //邀请类型
	DataArray<unsigned char, unsigned short> msg; //邀请内容
	unsigned int              interval; //邀请有效时长：秒
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(inviter_guid);

		net_data.AddIntegral(type);

		net_data.AddArray(msg);

		net_data.AddIntegral(interval);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(inviter_guid);

		net_data.AddIntegral(type);

		net_data.AddArray(msg);

		net_data.AddIntegral(interval);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(inviter_guid))
			return false;

		if (!net_data.DelIntegral(type))
			return false;

		if(!net_data.DelArray(msg))
			return false;

		if (!net_data.DelIntegral(interval))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(inviter_guid))
			return false;

		if (!net_data.DelIntegral(type))
			return false;

		if(!net_data.DelArray(msg))
			return false;

		if (!net_data.DelIntegral(interval))
			return false;

		return true;
	}
	void Reset(void)
	{
		inviter_guid = 0;

		type = 0;

		msg.clear();

		interval = 0;

	}
	InviteMsgNtf& operator= (const InviteMsgNtf& src)
	{
		inviter_guid = src.inviter_guid;

		type = src.type;

		msg = src.msg;

		interval = src.interval;

		return *this;
	}
	bool operator==(const InviteMsgNtf& src) const
	{
		if (inviter_guid != src.inviter_guid)
		{
			return false;
		}

		if (type != src.type)
		{
			return false;
		}

		if (msg != src.msg)
		{
			return false;
		}

		if (interval != src.interval)
		{
			return false;
		}

		return true;
	}
	bool operator != (const InviteMsgNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(InviteMsgNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.inviter_guid, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.type, str, length);
            }
            break;
            case 3:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.interval, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 2:
            {
                m_assigned_bitset.set(m_state);
                DataArrayHandler<unsigned char, unsigned short> handler(m_data.msg, this);
                handler.String(str, length, copy);
            }
            break;
            default:
            {
                m_state = 0;
                return true;
            }
            }

            m_state++;
            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        InviteMsgNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<4> m_assigned_bitset;

        static const std::bitset<4> template_assigned_bitset;
        static const char* m_key_list[4];
        static const char* m_alias_list[4];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"inviter_guid", inviter_guid);

		json_data.AddIntegral(u8"type", type);

		json_data.Writer().Key(u8"msg", sizeof(u8"msg") - 1);
		json_data.AddArray(msg);

		json_data.AddIntegral(u8"interval", interval);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        InviteMsgNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct ReplyInvite:Protocol<ReplyInvite>
{
	unsigned long long        inviter_guid; //邀请人guid
	unsigned int              type; //邀请类型
	unsigned char             agreed; //1:表示同意邀请 0:表示不同意
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(inviter_guid);

		net_data.AddIntegral(type);

		net_data.AddIntegral(agreed);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(inviter_guid);

		net_data.AddIntegral(type);

		net_data.AddIntegral(agreed);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(inviter_guid))
			return false;

		if (!net_data.DelIntegral(type))
			return false;

		if (!net_data.DelIntegral(agreed))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(inviter_guid))
			return false;

		if (!net_data.DelIntegral(type))
			return false;

		if (!net_data.DelIntegral(agreed))
			return false;

		return true;
	}
	void Reset(void)
	{
		inviter_guid = 0;

		type = 0;

		agreed = 0;

	}
	ReplyInvite& operator= (const ReplyInvite& src)
	{
		inviter_guid = src.inviter_guid;

		type = src.type;

		agreed = src.agreed;

		return *this;
	}
	bool operator==(const ReplyInvite& src) const
	{
		if (inviter_guid != src.inviter_guid)
		{
			return false;
		}

		if (type != src.type)
		{
			return false;
		}

		if (agreed != src.agreed)
		{
			return false;
		}

		return true;
	}
	bool operator != (const ReplyInvite& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(ReplyInvite& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.inviter_guid, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.type, str, length);
            }
            break;
            case 2:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.agreed, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        ReplyInvite& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<3> m_assigned_bitset;

        static const std::bitset<3> template_assigned_bitset;
        static const char* m_key_list[3];
        static const char* m_alias_list[3];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"inviter_guid", inviter_guid);

		json_data.AddIntegral(u8"type", type);

		json_data.AddIntegral(u8"agreed", agreed);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        ReplyInvite::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct MoveItem:Protocol<MoveItem>
{
	unsigned long long        item_guid; //物品guid
	unsigned short            container_type; //item容器类型
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(item_guid);

		net_data.AddIntegral(container_type);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(item_guid);

		net_data.AddIntegral(container_type);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(item_guid))
			return false;

		if (!net_data.DelIntegral(container_type))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(item_guid))
			return false;

		if (!net_data.DelIntegral(container_type))
			return false;

		return true;
	}
	void Reset(void)
	{
		item_guid = 0;

		container_type = 0;

	}
	MoveItem& operator= (const MoveItem& src)
	{
		item_guid = src.item_guid;

		container_type = src.container_type;

		return *this;
	}
	bool operator==(const MoveItem& src) const
	{
		if (item_guid != src.item_guid)
		{
			return false;
		}

		if (container_type != src.container_type)
		{
			return false;
		}

		return true;
	}
	bool operator != (const MoveItem& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(MoveItem& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.item_guid, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.container_type, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        MoveItem& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"item_guid", item_guid);

		json_data.AddIntegral(u8"container_type", container_type);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        MoveItem::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct UseItem:Protocol<UseItem>
{
	unsigned long long        item_guid; //物品guid
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(item_guid);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(item_guid);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(item_guid))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(item_guid))
			return false;

		return true;
	}
	void Reset(void)
	{
		item_guid = 0;

	}
	UseItem& operator= (const UseItem& src)
	{
		item_guid = src.item_guid;

		return *this;
	}
	bool operator==(const UseItem& src) const
	{
		if (item_guid != src.item_guid)
		{
			return false;
		}

		return true;
	}
	bool operator != (const UseItem& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(UseItem& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.item_guid, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        UseItem& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"item_guid", item_guid);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        UseItem::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct RearrangeItem:Protocol<RearrangeItem>
{
	unsigned short            container_type; //item容器类型
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(container_type);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(container_type);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(container_type))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(container_type))
			return false;

		return true;
	}
	void Reset(void)
	{
		container_type = 0;

	}
	RearrangeItem& operator= (const RearrangeItem& src)
	{
		container_type = src.container_type;

		return *this;
	}
	bool operator==(const RearrangeItem& src) const
	{
		if (container_type != src.container_type)
		{
			return false;
		}

		return true;
	}
	bool operator != (const RearrangeItem& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(RearrangeItem& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.container_type, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        RearrangeItem& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"container_type", container_type);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        RearrangeItem::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct SkillContainerNtf:Protocol<SkillContainerNtf>
{
	unsigned long long        guid; //技能容器属于谁(玩家、宠物)
	DataArray<SkillData, unsigned short> skills; //技能列表
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(guid);

		net_data.AddArray(skills);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(guid);

		net_data.AddArray(skills);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if(!net_data.DelArray(skills))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if(!net_data.DelArray(skills))
			return false;

		return true;
	}
	void Reset(void)
	{
		guid = 0;

		skills.clear();

	}
	SkillContainerNtf& operator= (const SkillContainerNtf& src)
	{
		guid = src.guid;

		skills = src.skills;

		return *this;
	}
	bool operator==(const SkillContainerNtf& src) const
	{
		if (guid != src.guid)
		{
			return false;
		}

		if (skills != src.skills)
		{
			return false;
		}

		return true;
	}
	bool operator != (const SkillContainerNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(SkillContainerNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_skills_handler(m_data.skills, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_skills_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.guid, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            switch (m_state)
            {
            case 1:
            {
                m_assigned_bitset.set(m_state);
                return &m_skills_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)elementCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_skills_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        SkillContainerNtf& m_data;
        DataArrayHandler<SkillData, unsigned short, SkillData::Handler> m_skills_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"guid", guid);

		json_data.Writer().Key(u8"skills", sizeof(u8"skills") - 1);
		json_data.AddArray(skills);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        SkillContainerNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct AddSkillNtf:Protocol<AddSkillNtf>
{
	unsigned long long        guid; //技能属于谁(玩家、宠物)
	SkillData                 skill; //技能数据
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(guid);

		skill.EnCode(net_data);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(guid);

		skill.EnCode(net_data);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!skill.DeCode(net_data))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!skill.DeCode(net_data))
			return false;

		return true;
	}
	void Reset(void)
	{
		guid = 0;

		skill.Reset();

	}
	AddSkillNtf& operator= (const AddSkillNtf& src)
	{
		guid = src.guid;

		skill = src.skill;

		return *this;
	}
	bool operator==(const AddSkillNtf& src) const
	{
		if (guid != src.guid)
		{
			return false;
		}

		if (skill != src.skill)
		{
			return false;
		}

		return true;
	}
	bool operator != (const AddSkillNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(AddSkillNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_skill_handler(m_data.skill, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_skill_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.guid, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            switch (m_state)
            {
            case 1:
            {
                m_assigned_bitset.set(m_state);
                return &m_skill_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)memberCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_skill_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        AddSkillNtf& m_data;
        SkillData::Handler m_skill_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"guid", guid);

		json_data.Writer().Key(u8"skill", sizeof(u8"skill") - 1);
		skill.ToJson(json_data);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        AddSkillNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct UpdateSkillNtf:Protocol<UpdateSkillNtf>
{
	unsigned long long        guid; //技能属于谁(玩家、宠物)
	unsigned short            id; //技能id
	unsigned short            attr; //技能属性名 1:当前熟练度 2:最大熟练度 3:是否激活
	unsigned int              value; //技能属性值
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(guid);

		net_data.AddIntegral(id);

		net_data.AddIntegral(attr);

		net_data.AddIntegral(value);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(guid);

		net_data.AddIntegral(id);

		net_data.AddIntegral(attr);

		net_data.AddIntegral(value);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!net_data.DelIntegral(id))
			return false;

		if (!net_data.DelIntegral(attr))
			return false;

		if (!net_data.DelIntegral(value))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!net_data.DelIntegral(id))
			return false;

		if (!net_data.DelIntegral(attr))
			return false;

		if (!net_data.DelIntegral(value))
			return false;

		return true;
	}
	void Reset(void)
	{
		guid = 0;

		id = 0;

		attr = 0;

		value = 0;

	}
	UpdateSkillNtf& operator= (const UpdateSkillNtf& src)
	{
		guid = src.guid;

		id = src.id;

		attr = src.attr;

		value = src.value;

		return *this;
	}
	bool operator==(const UpdateSkillNtf& src) const
	{
		if (guid != src.guid)
		{
			return false;
		}

		if (id != src.id)
		{
			return false;
		}

		if (attr != src.attr)
		{
			return false;
		}

		if (value != src.value)
		{
			return false;
		}

		return true;
	}
	bool operator != (const UpdateSkillNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(UpdateSkillNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.guid, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.id, str, length);
            }
            break;
            case 2:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.attr, str, length);
            }
            break;
            case 3:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.value, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        UpdateSkillNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<4> m_assigned_bitset;

        static const std::bitset<4> template_assigned_bitset;
        static const char* m_key_list[4];
        static const char* m_alias_list[4];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"guid", guid);

		json_data.AddIntegral(u8"id", id);

		json_data.AddIntegral(u8"attr", attr);

		json_data.AddIntegral(u8"value", value);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        UpdateSkillNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct DelSkillNtf:Protocol<DelSkillNtf>
{
	unsigned long long        guid; //技能属于谁(玩家、宠物)
	unsigned short            id; //技能id
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(guid);

		net_data.AddIntegral(id);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(guid);

		net_data.AddIntegral(id);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!net_data.DelIntegral(id))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!net_data.DelIntegral(id))
			return false;

		return true;
	}
	void Reset(void)
	{
		guid = 0;

		id = 0;

	}
	DelSkillNtf& operator= (const DelSkillNtf& src)
	{
		guid = src.guid;

		id = src.id;

		return *this;
	}
	bool operator==(const DelSkillNtf& src) const
	{
		if (guid != src.guid)
		{
			return false;
		}

		if (id != src.id)
		{
			return false;
		}

		return true;
	}
	bool operator != (const DelSkillNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(DelSkillNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.guid, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.id, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        DelSkillNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"guid", guid);

		json_data.AddIntegral(u8"id", id);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        DelSkillNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct PetAppearNtf:Protocol<PetAppearNtf>
{
	unsigned long long        guid; //宠物guid
	char                      name[256]; //宠物名字
	unsigned short            x; //x坐标
	unsigned short            y; //y坐标
	DataArray<AttrData, unsigned short> attrs; //属性数据
	CustomData                custom; //自定义数据
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(guid);

		net_data.AddString(name, sizeof(name));

		net_data.AddIntegral(x);

		net_data.AddIntegral(y);

		net_data.AddArray(attrs);

		custom.EnCode(net_data);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(guid);

		net_data.AddString(name, sizeof(name));

		net_data.AddIntegral(x);

		net_data.AddIntegral(y);

		net_data.AddArray(attrs);

		custom.EnCode(net_data);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!net_data.DelString(name, sizeof(name)))
			return false;

		if (!net_data.DelIntegral(x))
			return false;

		if (!net_data.DelIntegral(y))
			return false;

		if(!net_data.DelArray(attrs))
			return false;

		if (!custom.DeCode(net_data))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!net_data.DelString(name, sizeof(name)))
			return false;

		if (!net_data.DelIntegral(x))
			return false;

		if (!net_data.DelIntegral(y))
			return false;

		if(!net_data.DelArray(attrs))
			return false;

		if (!custom.DeCode(net_data))
			return false;

		return true;
	}
	void Reset(void)
	{
		guid = 0;

		name[0] = 0;

		x = 0;

		y = 0;

		attrs.clear();

		custom.Reset();

	}
	PetAppearNtf& operator= (const PetAppearNtf& src)
	{
		guid = src.guid;

		{
			size_t str_len = strnlen(src.name, sizeof(name) - 1);
			memcpy(name, src.name, str_len + 1);
			name[sizeof(name) - 1] = 0;
		}

		x = src.x;

		y = src.y;

		attrs = src.attrs;

		custom = src.custom;

		return *this;
	}
	bool operator==(const PetAppearNtf& src) const
	{
		if (guid != src.guid)
		{
			return false;
		}

		if (strncmp(name, src.name, sizeof(name)-1))
		{
			return false;
		}

		if (x != src.x)
		{
			return false;
		}

		if (y != src.y)
		{
			return false;
		}

		if (attrs != src.attrs)
		{
			return false;
		}

		if (custom != src.custom)
		{
			return false;
		}

		return true;
	}
	bool operator != (const PetAppearNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(PetAppearNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_custom_handler(m_data.custom, this),
            m_attrs_handler(m_data.attrs, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_custom_handler.ResetState();
            m_attrs_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.guid, str, length);
            }
            break;
            case 2:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.x, str, length);
            }
            break;
            case 3:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.y, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelString(m_data.name, str, length);
            }
            break;
            default:
            {
                m_state = 0;
                return true;
            }
            }

            m_state++;
            return true;
        }

        JsonHandler* StartObject() override
        {
            switch (m_state)
            {
            case 5:
            {
                m_assigned_bitset.set(m_state);
                return &m_custom_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)memberCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        JsonHandler* StartArray() override
        {
            switch (m_state)
            {
            case 4:
            {
                m_assigned_bitset.set(m_state);
                return &m_attrs_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)elementCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_attrs_handler.IsAllMemberSet())
            {
                return false;
            }

            if (!m_custom_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        PetAppearNtf& m_data;
        CustomData::Handler m_custom_handler;
        DataArrayHandler<AttrData, unsigned short, AttrData::Handler> m_attrs_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<6> m_assigned_bitset;

        static const std::bitset<6> template_assigned_bitset;
        static const char* m_key_list[6];
        static const char* m_alias_list[6];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"guid", guid);

		json_data.AddString(u8"name", name, sizeof(name));

		json_data.AddIntegral(u8"x", x);

		json_data.AddIntegral(u8"y", y);

		json_data.Writer().Key(u8"attrs", sizeof(u8"attrs") - 1);
		json_data.AddArray(attrs);

		json_data.Writer().Key(u8"custom", sizeof(u8"custom") - 1);
		custom.ToJson(json_data);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        PetAppearNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct PetContainerNtf:Protocol<PetContainerNtf>
{
	unsigned short            container_type; //pet容器类型
	unsigned short            capacity; //pet容器容量
	DataArray<PetData, unsigned short> pets; //宠物列表
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(container_type);

		net_data.AddIntegral(capacity);

		net_data.AddArray(pets);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(container_type);

		net_data.AddIntegral(capacity);

		net_data.AddArray(pets);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(container_type))
			return false;

		if (!net_data.DelIntegral(capacity))
			return false;

		if(!net_data.DelArray(pets))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(container_type))
			return false;

		if (!net_data.DelIntegral(capacity))
			return false;

		if(!net_data.DelArray(pets))
			return false;

		return true;
	}
	void Reset(void)
	{
		container_type = 0;

		capacity = 0;

		pets.clear();

	}
	PetContainerNtf& operator= (const PetContainerNtf& src)
	{
		container_type = src.container_type;

		capacity = src.capacity;

		pets = src.pets;

		return *this;
	}
	bool operator==(const PetContainerNtf& src) const
	{
		if (container_type != src.container_type)
		{
			return false;
		}

		if (capacity != src.capacity)
		{
			return false;
		}

		if (pets != src.pets)
		{
			return false;
		}

		return true;
	}
	bool operator != (const PetContainerNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(PetContainerNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_pets_handler(m_data.pets, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_pets_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.container_type, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.capacity, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            switch (m_state)
            {
            case 2:
            {
                m_assigned_bitset.set(m_state);
                return &m_pets_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)elementCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_pets_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        PetContainerNtf& m_data;
        DataArrayHandler<PetData, unsigned short, PetData::Handler> m_pets_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<3> m_assigned_bitset;

        static const std::bitset<3> template_assigned_bitset;
        static const char* m_key_list[3];
        static const char* m_alias_list[3];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"container_type", container_type);

		json_data.AddIntegral(u8"capacity", capacity);

		json_data.Writer().Key(u8"pets", sizeof(u8"pets") - 1);
		json_data.AddArray(pets);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        PetContainerNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct PetContainerUpdateNtf:Protocol<PetContainerUpdateNtf>
{
	unsigned short            container_type; //pet容器类型
	unsigned short            capacity; //pet容器容量
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(container_type);

		net_data.AddIntegral(capacity);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(container_type);

		net_data.AddIntegral(capacity);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(container_type))
			return false;

		if (!net_data.DelIntegral(capacity))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(container_type))
			return false;

		if (!net_data.DelIntegral(capacity))
			return false;

		return true;
	}
	void Reset(void)
	{
		container_type = 0;

		capacity = 0;

	}
	PetContainerUpdateNtf& operator= (const PetContainerUpdateNtf& src)
	{
		container_type = src.container_type;

		capacity = src.capacity;

		return *this;
	}
	bool operator==(const PetContainerUpdateNtf& src) const
	{
		if (container_type != src.container_type)
		{
			return false;
		}

		if (capacity != src.capacity)
		{
			return false;
		}

		return true;
	}
	bool operator != (const PetContainerUpdateNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(PetContainerUpdateNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.container_type, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.capacity, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        PetContainerUpdateNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"container_type", container_type);

		json_data.AddIntegral(u8"capacity", capacity);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        PetContainerUpdateNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct PetAddNtf:Protocol<PetAddNtf>
{
	unsigned short            container_type; //pet容器类型
	PetData                   pet; //物品列表
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(container_type);

		pet.EnCode(net_data);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(container_type);

		pet.EnCode(net_data);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(container_type))
			return false;

		if (!pet.DeCode(net_data))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(container_type))
			return false;

		if (!pet.DeCode(net_data))
			return false;

		return true;
	}
	void Reset(void)
	{
		container_type = 0;

		pet.Reset();

	}
	PetAddNtf& operator= (const PetAddNtf& src)
	{
		container_type = src.container_type;

		pet = src.pet;

		return *this;
	}
	bool operator==(const PetAddNtf& src) const
	{
		if (container_type != src.container_type)
		{
			return false;
		}

		if (pet != src.pet)
		{
			return false;
		}

		return true;
	}
	bool operator != (const PetAddNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(PetAddNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_pet_handler(m_data.pet, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_pet_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.container_type, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            switch (m_state)
            {
            case 1:
            {
                m_assigned_bitset.set(m_state);
                return &m_pet_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)memberCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_pet_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        PetAddNtf& m_data;
        PetData::Handler m_pet_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"container_type", container_type);

		json_data.Writer().Key(u8"pet", sizeof(u8"pet") - 1);
		pet.ToJson(json_data);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        PetAddNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct PetDestroyNtf:Protocol<PetDestroyNtf>
{
	unsigned short            container_type; //pet容器类型
	unsigned long long        guid; //宠物guid
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(container_type);

		net_data.AddIntegral(guid);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(container_type);

		net_data.AddIntegral(guid);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(container_type))
			return false;

		if (!net_data.DelIntegral(guid))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(container_type))
			return false;

		if (!net_data.DelIntegral(guid))
			return false;

		return true;
	}
	void Reset(void)
	{
		container_type = 0;

		guid = 0;

	}
	PetDestroyNtf& operator= (const PetDestroyNtf& src)
	{
		container_type = src.container_type;

		guid = src.guid;

		return *this;
	}
	bool operator==(const PetDestroyNtf& src) const
	{
		if (container_type != src.container_type)
		{
			return false;
		}

		if (guid != src.guid)
		{
			return false;
		}

		return true;
	}
	bool operator != (const PetDestroyNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(PetDestroyNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.container_type, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.guid, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        PetDestroyNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"container_type", container_type);

		json_data.AddIntegral(u8"guid", guid);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        PetDestroyNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct SetPetLineup:Protocol<SetPetLineup>
{
	unsigned long long        guid; //宠物guid
	unsigned char             lineup; //上阵：0 下阵，1 上阵
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(guid);

		net_data.AddIntegral(lineup);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(guid);

		net_data.AddIntegral(lineup);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!net_data.DelIntegral(lineup))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!net_data.DelIntegral(lineup))
			return false;

		return true;
	}
	void Reset(void)
	{
		guid = 0;

		lineup = 0;

	}
	SetPetLineup& operator= (const SetPetLineup& src)
	{
		guid = src.guid;

		lineup = src.lineup;

		return *this;
	}
	bool operator==(const SetPetLineup& src) const
	{
		if (guid != src.guid)
		{
			return false;
		}

		if (lineup != src.lineup)
		{
			return false;
		}

		return true;
	}
	bool operator != (const SetPetLineup& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(SetPetLineup& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.guid, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.lineup, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        SetPetLineup& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"guid", guid);

		json_data.AddIntegral(u8"lineup", lineup);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        SetPetLineup::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct ShowPet:Protocol<ShowPet>
{
	unsigned long long        guid; //宠物guid
	unsigned char             show; //显示：0 隐藏，1 显示
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(guid);

		net_data.AddIntegral(show);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(guid);

		net_data.AddIntegral(show);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!net_data.DelIntegral(show))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!net_data.DelIntegral(show))
			return false;

		return true;
	}
	void Reset(void)
	{
		guid = 0;

		show = 0;

	}
	ShowPet& operator= (const ShowPet& src)
	{
		guid = src.guid;

		show = src.show;

		return *this;
	}
	bool operator==(const ShowPet& src) const
	{
		if (guid != src.guid)
		{
			return false;
		}

		if (show != src.show)
		{
			return false;
		}

		return true;
	}
	bool operator != (const ShowPet& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(ShowPet& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.guid, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.show, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        ShowPet& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"guid", guid);

		json_data.AddIntegral(u8"show", show);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        ShowPet::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct ReleasePet:Protocol<ReleasePet>
{
	unsigned long long        guid; //宠物guid
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(guid);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(guid);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(guid))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(guid))
			return false;

		return true;
	}
	void Reset(void)
	{
		guid = 0;

	}
	ReleasePet& operator= (const ReleasePet& src)
	{
		guid = src.guid;

		return *this;
	}
	bool operator==(const ReleasePet& src) const
	{
		if (guid != src.guid)
		{
			return false;
		}

		return true;
	}
	bool operator != (const ReleasePet& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(ReleasePet& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.guid, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        ReleasePet& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"guid", guid);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        ReleasePet::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct MovePet:Protocol<MovePet>
{
	unsigned long long        guid; //宠物guid
	unsigned short            container_type; //pet容器类型
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(guid);

		net_data.AddIntegral(container_type);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(guid);

		net_data.AddIntegral(container_type);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!net_data.DelIntegral(container_type))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!net_data.DelIntegral(container_type))
			return false;

		return true;
	}
	void Reset(void)
	{
		guid = 0;

		container_type = 0;

	}
	MovePet& operator= (const MovePet& src)
	{
		guid = src.guid;

		container_type = src.container_type;

		return *this;
	}
	bool operator==(const MovePet& src) const
	{
		if (guid != src.guid)
		{
			return false;
		}

		if (container_type != src.container_type)
		{
			return false;
		}

		return true;
	}
	bool operator != (const MovePet& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(MovePet& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.guid, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.container_type, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        MovePet& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"guid", guid);

		json_data.AddIntegral(u8"container_type", container_type);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        MovePet::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct ShopOpenNtf:Protocol<ShopOpenNtf>
{
	unsigned short            shop_id; //商店id
	unsigned short            def_item_id; //默认选中商品id
	unsigned char             type; //商店类型0=宠物商店 1=道具商店 2=随身商店
	DataArray<ShopItemData, unsigned short> shop_item_list; //商品列表
	DataArray<ItemData, unsigned short> buy_back_list; //回购列表
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(shop_id);

		net_data.AddIntegral(def_item_id);

		net_data.AddIntegral(type);

		net_data.AddArray(shop_item_list);

		net_data.AddArray(buy_back_list);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(shop_id);

		net_data.AddIntegral(def_item_id);

		net_data.AddIntegral(type);

		net_data.AddArray(shop_item_list);

		net_data.AddArray(buy_back_list);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(shop_id))
			return false;

		if (!net_data.DelIntegral(def_item_id))
			return false;

		if (!net_data.DelIntegral(type))
			return false;

		if(!net_data.DelArray(shop_item_list))
			return false;

		if(!net_data.DelArray(buy_back_list))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(shop_id))
			return false;

		if (!net_data.DelIntegral(def_item_id))
			return false;

		if (!net_data.DelIntegral(type))
			return false;

		if(!net_data.DelArray(shop_item_list))
			return false;

		if(!net_data.DelArray(buy_back_list))
			return false;

		return true;
	}
	void Reset(void)
	{
		shop_id = 0;

		def_item_id = 0;

		type = 0;

		shop_item_list.clear();

		buy_back_list.clear();

	}
	ShopOpenNtf& operator= (const ShopOpenNtf& src)
	{
		shop_id = src.shop_id;

		def_item_id = src.def_item_id;

		type = src.type;

		shop_item_list = src.shop_item_list;

		buy_back_list = src.buy_back_list;

		return *this;
	}
	bool operator==(const ShopOpenNtf& src) const
	{
		if (shop_id != src.shop_id)
		{
			return false;
		}

		if (def_item_id != src.def_item_id)
		{
			return false;
		}

		if (type != src.type)
		{
			return false;
		}

		if (shop_item_list != src.shop_item_list)
		{
			return false;
		}

		if (buy_back_list != src.buy_back_list)
		{
			return false;
		}

		return true;
	}
	bool operator != (const ShopOpenNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(ShopOpenNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_shop_item_list_handler(m_data.shop_item_list, this),
            m_buy_back_list_handler(m_data.buy_back_list, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_shop_item_list_handler.ResetState();
            m_buy_back_list_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.shop_id, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.def_item_id, str, length);
            }
            break;
            case 2:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.type, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            switch (m_state)
            {
            case 3:
            {
                m_assigned_bitset.set(m_state);
                return &m_shop_item_list_handler;
            }
            break;
            case 4:
            {
                m_assigned_bitset.set(m_state);
                return &m_buy_back_list_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)elementCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_shop_item_list_handler.IsAllMemberSet())
            {
                return false;
            }

            if (!m_buy_back_list_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        ShopOpenNtf& m_data;
        DataArrayHandler<ShopItemData, unsigned short, ShopItemData::Handler> m_shop_item_list_handler;
        DataArrayHandler<ItemData, unsigned short, ItemData::Handler> m_buy_back_list_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<5> m_assigned_bitset;

        static const std::bitset<5> template_assigned_bitset;
        static const char* m_key_list[5];
        static const char* m_alias_list[5];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"shop_id", shop_id);

		json_data.AddIntegral(u8"def_item_id", def_item_id);

		json_data.AddIntegral(u8"type", type);

		json_data.Writer().Key(u8"shop_item_list", sizeof(u8"shop_item_list") - 1);
		json_data.AddArray(shop_item_list);

		json_data.Writer().Key(u8"buy_back_list", sizeof(u8"buy_back_list") - 1);
		json_data.AddArray(buy_back_list);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        ShopOpenNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct ShopBuyNtf:Protocol<ShopBuyNtf>
{
	unsigned short            shop_id; //商店id
	unsigned short            shop_item_id; //商品id
	unsigned short            shop_item_num; //商品数量
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(shop_id);

		net_data.AddIntegral(shop_item_id);

		net_data.AddIntegral(shop_item_num);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(shop_id);

		net_data.AddIntegral(shop_item_id);

		net_data.AddIntegral(shop_item_num);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(shop_id))
			return false;

		if (!net_data.DelIntegral(shop_item_id))
			return false;

		if (!net_data.DelIntegral(shop_item_num))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(shop_id))
			return false;

		if (!net_data.DelIntegral(shop_item_id))
			return false;

		if (!net_data.DelIntegral(shop_item_num))
			return false;

		return true;
	}
	void Reset(void)
	{
		shop_id = 0;

		shop_item_id = 0;

		shop_item_num = 0;

	}
	ShopBuyNtf& operator= (const ShopBuyNtf& src)
	{
		shop_id = src.shop_id;

		shop_item_id = src.shop_item_id;

		shop_item_num = src.shop_item_num;

		return *this;
	}
	bool operator==(const ShopBuyNtf& src) const
	{
		if (shop_id != src.shop_id)
		{
			return false;
		}

		if (shop_item_id != src.shop_item_id)
		{
			return false;
		}

		if (shop_item_num != src.shop_item_num)
		{
			return false;
		}

		return true;
	}
	bool operator != (const ShopBuyNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(ShopBuyNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.shop_id, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.shop_item_id, str, length);
            }
            break;
            case 2:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.shop_item_num, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        ShopBuyNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<3> m_assigned_bitset;

        static const std::bitset<3> template_assigned_bitset;
        static const char* m_key_list[3];
        static const char* m_alias_list[3];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"shop_id", shop_id);

		json_data.AddIntegral(u8"shop_item_id", shop_item_id);

		json_data.AddIntegral(u8"shop_item_num", shop_item_num);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        ShopBuyNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct SellNtf:Protocol<SellNtf>
{
	DataArray<SellItemData, unsigned short> sell_items; //出售物品列表
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddArray(sell_items);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddArray(sell_items);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if(!net_data.DelArray(sell_items))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if(!net_data.DelArray(sell_items))
			return false;

		return true;
	}
	void Reset(void)
	{
		sell_items.clear();

	}
	SellNtf& operator= (const SellNtf& src)
	{
		sell_items = src.sell_items;

		return *this;
	}
	bool operator==(const SellNtf& src) const
	{
		if (sell_items != src.sell_items)
		{
			return false;
		}

		return true;
	}
	bool operator != (const SellNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(SellNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_sell_items_handler(m_data.sell_items, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_sell_items_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                return &m_sell_items_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)elementCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_sell_items_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        SellNtf& m_data;
        DataArrayHandler<SellItemData, unsigned short, SellItemData::Handler> m_sell_items_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.Writer().Key(u8"sell_items", sizeof(u8"sell_items") - 1);
		json_data.AddArray(sell_items);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        SellNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct BuyBackNtf:Protocol<BuyBackNtf>
{
	unsigned long long        buy_guid; //出售物品guid
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(buy_guid);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(buy_guid);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(buy_guid))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(buy_guid))
			return false;

		return true;
	}
	void Reset(void)
	{
		buy_guid = 0;

	}
	BuyBackNtf& operator= (const BuyBackNtf& src)
	{
		buy_guid = src.buy_guid;

		return *this;
	}
	bool operator==(const BuyBackNtf& src) const
	{
		if (buy_guid != src.buy_guid)
		{
			return false;
		}

		return true;
	}
	bool operator != (const BuyBackNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(BuyBackNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.buy_guid, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        BuyBackNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"buy_guid", buy_guid);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        BuyBackNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct BuyBackListNtf:Protocol<BuyBackListNtf>
{
	DataArray<ItemData, unsigned short> buy_back_list; //回购列表
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddArray(buy_back_list);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddArray(buy_back_list);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if(!net_data.DelArray(buy_back_list))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if(!net_data.DelArray(buy_back_list))
			return false;

		return true;
	}
	void Reset(void)
	{
		buy_back_list.clear();

	}
	BuyBackListNtf& operator= (const BuyBackListNtf& src)
	{
		buy_back_list = src.buy_back_list;

		return *this;
	}
	bool operator==(const BuyBackListNtf& src) const
	{
		if (buy_back_list != src.buy_back_list)
		{
			return false;
		}

		return true;
	}
	bool operator != (const BuyBackListNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(BuyBackListNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_buy_back_list_handler(m_data.buy_back_list, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_buy_back_list_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                return &m_buy_back_list_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)elementCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_buy_back_list_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        BuyBackListNtf& m_data;
        DataArrayHandler<ItemData, unsigned short, ItemData::Handler> m_buy_back_list_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.Writer().Key(u8"buy_back_list", sizeof(u8"buy_back_list") - 1);
		json_data.AddArray(buy_back_list);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        BuyBackListNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct TeamAttrNtf:Protocol<TeamAttrNtf>
{
	unsigned long long        guid; //角色guid
	DataArray<AttrData, unsigned short> attrs; //属性数据
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(guid);

		net_data.AddArray(attrs);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(guid);

		net_data.AddArray(attrs);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if(!net_data.DelArray(attrs))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if(!net_data.DelArray(attrs))
			return false;

		return true;
	}
	void Reset(void)
	{
		guid = 0;

		attrs.clear();

	}
	TeamAttrNtf& operator= (const TeamAttrNtf& src)
	{
		guid = src.guid;

		attrs = src.attrs;

		return *this;
	}
	bool operator==(const TeamAttrNtf& src) const
	{
		if (guid != src.guid)
		{
			return false;
		}

		if (attrs != src.attrs)
		{
			return false;
		}

		return true;
	}
	bool operator != (const TeamAttrNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(TeamAttrNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_attrs_handler(m_data.attrs, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_attrs_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.guid, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            switch (m_state)
            {
            case 1:
            {
                m_assigned_bitset.set(m_state);
                return &m_attrs_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)elementCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_attrs_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        TeamAttrNtf& m_data;
        DataArrayHandler<AttrData, unsigned short, AttrData::Handler> m_attrs_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"guid", guid);

		json_data.Writer().Key(u8"attrs", sizeof(u8"attrs") - 1);
		json_data.AddArray(attrs);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        TeamAttrNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct TipsMsgExNtf:Protocol<TipsMsgExNtf>
{
	DataArray<unsigned char, unsigned short> msg; //消息内容
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddArray(msg);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddArray(msg);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if(!net_data.DelArray(msg))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if(!net_data.DelArray(msg))
			return false;

		return true;
	}
	void Reset(void)
	{
		msg.clear();

	}
	TipsMsgExNtf& operator= (const TipsMsgExNtf& src)
	{
		msg = src.msg;

		return *this;
	}
	bool operator==(const TipsMsgExNtf& src) const
	{
		if (msg != src.msg)
		{
			return false;
		}

		return true;
	}
	bool operator != (const TipsMsgExNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(TipsMsgExNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                DataArrayHandler<unsigned char, unsigned short> handler(m_data.msg, this);
                handler.String(str, length, copy);
            }
            break;
            default:
            {
                m_state = 0;
                return true;
            }
            }

            m_state++;
            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        TipsMsgExNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.Writer().Key(u8"msg", sizeof(u8"msg") - 1);
		json_data.AddArray(msg);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        TipsMsgExNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct ItemNewAddNtf:Protocol<ItemNewAddNtf>
{
	unsigned long long        item_guid; //物品GUID
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(item_guid);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(item_guid);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(item_guid))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(item_guid))
			return false;

		return true;
	}
	void Reset(void)
	{
		item_guid = 0;

	}
	ItemNewAddNtf& operator= (const ItemNewAddNtf& src)
	{
		item_guid = src.item_guid;

		return *this;
	}
	bool operator==(const ItemNewAddNtf& src) const
	{
		if (item_guid != src.item_guid)
		{
			return false;
		}

		return true;
	}
	bool operator != (const ItemNewAddNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(ItemNewAddNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.item_guid, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        ItemNewAddNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"item_guid", item_guid);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        ItemNewAddNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct QuestContainerNtf:Protocol<QuestContainerNtf>
{
	DataArray<unsigned char, unsigned short> buffer; //任务列表: QuestClientData[]
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddArray(buffer);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddArray(buffer);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if(!net_data.DelArray(buffer))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if(!net_data.DelArray(buffer))
			return false;

		return true;
	}
	void Reset(void)
	{
		buffer.clear();

	}
	QuestContainerNtf& operator= (const QuestContainerNtf& src)
	{
		buffer = src.buffer;

		return *this;
	}
	bool operator==(const QuestContainerNtf& src) const
	{
		if (buffer != src.buffer)
		{
			return false;
		}

		return true;
	}
	bool operator != (const QuestContainerNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(QuestContainerNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                DataArrayHandler<unsigned char, unsigned short> handler(m_data.buffer, this);
                handler.String(str, length, copy);
            }
            break;
            default:
            {
                m_state = 0;
                return true;
            }
            }

            m_state++;
            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        QuestContainerNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.Writer().Key(u8"buffer", sizeof(u8"buffer") - 1);
		json_data.AddArray(buffer);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        QuestContainerNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct QuestAddNtf:Protocol<QuestAddNtf>
{
	DataArray<unsigned char, unsigned short> buffer; //任务列表: QuestClientData
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddArray(buffer);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddArray(buffer);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if(!net_data.DelArray(buffer))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if(!net_data.DelArray(buffer))
			return false;

		return true;
	}
	void Reset(void)
	{
		buffer.clear();

	}
	QuestAddNtf& operator= (const QuestAddNtf& src)
	{
		buffer = src.buffer;

		return *this;
	}
	bool operator==(const QuestAddNtf& src) const
	{
		if (buffer != src.buffer)
		{
			return false;
		}

		return true;
	}
	bool operator != (const QuestAddNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(QuestAddNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                DataArrayHandler<unsigned char, unsigned short> handler(m_data.buffer, this);
                handler.String(str, length, copy);
            }
            break;
            default:
            {
                m_state = 0;
                return true;
            }
            }

            m_state++;
            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        QuestAddNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.Writer().Key(u8"buffer", sizeof(u8"buffer") - 1);
		json_data.AddArray(buffer);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        QuestAddNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct QuestStateNtf:Protocol<QuestStateNtf>
{
	unsigned int              quest_id; //任务ID
	unsigned char             quest_state; //任务状态
	unsigned int              changed_time; //状态改变时间
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(quest_id);

		net_data.AddIntegral(quest_state);

		net_data.AddIntegral(changed_time);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(quest_id);

		net_data.AddIntegral(quest_state);

		net_data.AddIntegral(changed_time);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(quest_id))
			return false;

		if (!net_data.DelIntegral(quest_state))
			return false;

		if (!net_data.DelIntegral(changed_time))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(quest_id))
			return false;

		if (!net_data.DelIntegral(quest_state))
			return false;

		if (!net_data.DelIntegral(changed_time))
			return false;

		return true;
	}
	void Reset(void)
	{
		quest_id = 0;

		quest_state = 0;

		changed_time = 0;

	}
	QuestStateNtf& operator= (const QuestStateNtf& src)
	{
		quest_id = src.quest_id;

		quest_state = src.quest_state;

		changed_time = src.changed_time;

		return *this;
	}
	bool operator==(const QuestStateNtf& src) const
	{
		if (quest_id != src.quest_id)
		{
			return false;
		}

		if (quest_state != src.quest_state)
		{
			return false;
		}

		if (changed_time != src.changed_time)
		{
			return false;
		}

		return true;
	}
	bool operator != (const QuestStateNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(QuestStateNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.quest_id, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.quest_state, str, length);
            }
            break;
            case 2:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.changed_time, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        QuestStateNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<3> m_assigned_bitset;

        static const std::bitset<3> template_assigned_bitset;
        static const char* m_key_list[3];
        static const char* m_alias_list[3];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"quest_id", quest_id);

		json_data.AddIntegral(u8"quest_state", quest_state);

		json_data.AddIntegral(u8"changed_time", changed_time);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        QuestStateNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct QuestNpcStateNtf:Protocol<QuestNpcStateNtf>
{
	unsigned int              npc_id; //npc id
	unsigned char             state; //任务状态
	unsigned long long        logo; //任务logo
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(npc_id);

		net_data.AddIntegral(state);

		net_data.AddIntegral(logo);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(npc_id);

		net_data.AddIntegral(state);

		net_data.AddIntegral(logo);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(npc_id))
			return false;

		if (!net_data.DelIntegral(state))
			return false;

		if (!net_data.DelIntegral(logo))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(npc_id))
			return false;

		if (!net_data.DelIntegral(state))
			return false;

		if (!net_data.DelIntegral(logo))
			return false;

		return true;
	}
	void Reset(void)
	{
		npc_id = 0;

		state = 0;

		logo = 0;

	}
	QuestNpcStateNtf& operator= (const QuestNpcStateNtf& src)
	{
		npc_id = src.npc_id;

		state = src.state;

		logo = src.logo;

		return *this;
	}
	bool operator==(const QuestNpcStateNtf& src) const
	{
		if (npc_id != src.npc_id)
		{
			return false;
		}

		if (state != src.state)
		{
			return false;
		}

		if (logo != src.logo)
		{
			return false;
		}

		return true;
	}
	bool operator != (const QuestNpcStateNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(QuestNpcStateNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.npc_id, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.state, str, length);
            }
            break;
            case 2:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.logo, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        QuestNpcStateNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<3> m_assigned_bitset;

        static const std::bitset<3> template_assigned_bitset;
        static const char* m_key_list[3];
        static const char* m_alias_list[3];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"npc_id", npc_id);

		json_data.AddIntegral(u8"state", state);

		json_data.AddIntegral(u8"logo", logo);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        QuestNpcStateNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct QuestTrackCountNtf:Protocol<QuestTrackCountNtf>
{
	unsigned int              quest_id; //任务ID
	unsigned int              track_id; //追踪目标ID
	unsigned int              track_count; //追踪数量
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(quest_id);

		net_data.AddIntegral(track_id);

		net_data.AddIntegral(track_count);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(quest_id);

		net_data.AddIntegral(track_id);

		net_data.AddIntegral(track_count);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(quest_id))
			return false;

		if (!net_data.DelIntegral(track_id))
			return false;

		if (!net_data.DelIntegral(track_count))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(quest_id))
			return false;

		if (!net_data.DelIntegral(track_id))
			return false;

		if (!net_data.DelIntegral(track_count))
			return false;

		return true;
	}
	void Reset(void)
	{
		quest_id = 0;

		track_id = 0;

		track_count = 0;

	}
	QuestTrackCountNtf& operator= (const QuestTrackCountNtf& src)
	{
		quest_id = src.quest_id;

		track_id = src.track_id;

		track_count = src.track_count;

		return *this;
	}
	bool operator==(const QuestTrackCountNtf& src) const
	{
		if (quest_id != src.quest_id)
		{
			return false;
		}

		if (track_id != src.track_id)
		{
			return false;
		}

		if (track_count != src.track_count)
		{
			return false;
		}

		return true;
	}
	bool operator != (const QuestTrackCountNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(QuestTrackCountNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.quest_id, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.track_id, str, length);
            }
            break;
            case 2:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.track_count, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        QuestTrackCountNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<3> m_assigned_bitset;

        static const std::bitset<3> template_assigned_bitset;
        static const char* m_key_list[3];
        static const char* m_alias_list[3];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"quest_id", quest_id);

		json_data.AddIntegral(u8"track_id", track_id);

		json_data.AddIntegral(u8"track_count", track_count);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        QuestTrackCountNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct QuestTalkSelectReq:Protocol<QuestTalkSelectReq>
{
	unsigned long long        npc_guid; //NPC guid
	unsigned int              quest_id; //任务ID
	unsigned int              option_id; //对话选项ID
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(npc_guid);

		net_data.AddIntegral(quest_id);

		net_data.AddIntegral(option_id);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(npc_guid);

		net_data.AddIntegral(quest_id);

		net_data.AddIntegral(option_id);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(npc_guid))
			return false;

		if (!net_data.DelIntegral(quest_id))
			return false;

		if (!net_data.DelIntegral(option_id))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(npc_guid))
			return false;

		if (!net_data.DelIntegral(quest_id))
			return false;

		if (!net_data.DelIntegral(option_id))
			return false;

		return true;
	}
	void Reset(void)
	{
		npc_guid = 0;

		quest_id = 0;

		option_id = 0;

	}
	QuestTalkSelectReq& operator= (const QuestTalkSelectReq& src)
	{
		npc_guid = src.npc_guid;

		quest_id = src.quest_id;

		option_id = src.option_id;

		return *this;
	}
	bool operator==(const QuestTalkSelectReq& src) const
	{
		if (npc_guid != src.npc_guid)
		{
			return false;
		}

		if (quest_id != src.quest_id)
		{
			return false;
		}

		if (option_id != src.option_id)
		{
			return false;
		}

		return true;
	}
	bool operator != (const QuestTalkSelectReq& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(QuestTalkSelectReq& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.npc_guid, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.quest_id, str, length);
            }
            break;
            case 2:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.option_id, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        QuestTalkSelectReq& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<3> m_assigned_bitset;

        static const std::bitset<3> template_assigned_bitset;
        static const char* m_key_list[3];
        static const char* m_alias_list[3];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"npc_guid", npc_guid);

		json_data.AddIntegral(u8"quest_id", quest_id);

		json_data.AddIntegral(u8"option_id", option_id);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        QuestTalkSelectReq::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct QuestTalkSelectAck:Protocol<QuestTalkSelectAck>
{
	unsigned long long        npc_guid; //NPC guid
	unsigned int              quest_id; //任务ID
	DataArray<unsigned char, unsigned short> talk; //npc对话压缩: QuestTalkData[]
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(npc_guid);

		net_data.AddIntegral(quest_id);

		net_data.AddArray(talk);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(npc_guid);

		net_data.AddIntegral(quest_id);

		net_data.AddArray(talk);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(npc_guid))
			return false;

		if (!net_data.DelIntegral(quest_id))
			return false;

		if(!net_data.DelArray(talk))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(npc_guid))
			return false;

		if (!net_data.DelIntegral(quest_id))
			return false;

		if(!net_data.DelArray(talk))
			return false;

		return true;
	}
	void Reset(void)
	{
		npc_guid = 0;

		quest_id = 0;

		talk.clear();

	}
	QuestTalkSelectAck& operator= (const QuestTalkSelectAck& src)
	{
		npc_guid = src.npc_guid;

		quest_id = src.quest_id;

		talk = src.talk;

		return *this;
	}
	bool operator==(const QuestTalkSelectAck& src) const
	{
		if (npc_guid != src.npc_guid)
		{
			return false;
		}

		if (quest_id != src.quest_id)
		{
			return false;
		}

		if (talk != src.talk)
		{
			return false;
		}

		return true;
	}
	bool operator != (const QuestTalkSelectAck& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(QuestTalkSelectAck& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.npc_guid, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.quest_id, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 2:
            {
                m_assigned_bitset.set(m_state);
                DataArrayHandler<unsigned char, unsigned short> handler(m_data.talk, this);
                handler.String(str, length, copy);
            }
            break;
            default:
            {
                m_state = 0;
                return true;
            }
            }

            m_state++;
            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        QuestTalkSelectAck& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<3> m_assigned_bitset;

        static const std::bitset<3> template_assigned_bitset;
        static const char* m_key_list[3];
        static const char* m_alias_list[3];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"npc_guid", npc_guid);

		json_data.AddIntegral(u8"quest_id", quest_id);

		json_data.Writer().Key(u8"talk", sizeof(u8"talk") - 1);
		json_data.AddArray(talk);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        QuestTalkSelectAck::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct ObjStrCustomNtf:Protocol<ObjStrCustomNtf>
{
	unsigned long long        guid; //角色guid
	CustomStrData             custom; //自定义变量
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(guid);

		custom.EnCode(net_data);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(guid);

		custom.EnCode(net_data);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!custom.DeCode(net_data))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!custom.DeCode(net_data))
			return false;

		return true;
	}
	void Reset(void)
	{
		guid = 0;

		custom.Reset();

	}
	ObjStrCustomNtf& operator= (const ObjStrCustomNtf& src)
	{
		guid = src.guid;

		custom = src.custom;

		return *this;
	}
	bool operator==(const ObjStrCustomNtf& src) const
	{
		if (guid != src.guid)
		{
			return false;
		}

		if (custom != src.custom)
		{
			return false;
		}

		return true;
	}
	bool operator != (const ObjStrCustomNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(ObjStrCustomNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_custom_handler(m_data.custom, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_custom_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.guid, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            switch (m_state)
            {
            case 1:
            {
                m_assigned_bitset.set(m_state);
                return &m_custom_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)memberCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_custom_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        ObjStrCustomNtf& m_data;
        CustomStrData::Handler m_custom_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"guid", guid);

		json_data.Writer().Key(u8"custom", sizeof(u8"custom") - 1);
		custom.ToJson(json_data);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        ObjStrCustomNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct ObjIntCustomNtf:Protocol<ObjIntCustomNtf>
{
	unsigned long long        guid; //角色guid
	CustomIntData             custom; //自定义变量
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(guid);

		custom.EnCode(net_data);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(guid);

		custom.EnCode(net_data);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!custom.DeCode(net_data))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!custom.DeCode(net_data))
			return false;

		return true;
	}
	void Reset(void)
	{
		guid = 0;

		custom.Reset();

	}
	ObjIntCustomNtf& operator= (const ObjIntCustomNtf& src)
	{
		guid = src.guid;

		custom = src.custom;

		return *this;
	}
	bool operator==(const ObjIntCustomNtf& src) const
	{
		if (guid != src.guid)
		{
			return false;
		}

		if (custom != src.custom)
		{
			return false;
		}

		return true;
	}
	bool operator != (const ObjIntCustomNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(ObjIntCustomNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_custom_handler(m_data.custom, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_custom_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.guid, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            switch (m_state)
            {
            case 1:
            {
                m_assigned_bitset.set(m_state);
                return &m_custom_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)memberCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_custom_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        ObjIntCustomNtf& m_data;
        CustomIntData::Handler m_custom_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"guid", guid);

		json_data.Writer().Key(u8"custom", sizeof(u8"custom") - 1);
		custom.ToJson(json_data);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        ObjIntCustomNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct ObjDynAttrNtf:Protocol<ObjDynAttrNtf>
{
	unsigned long long        guid; //角色guid
	DynAttrData               dyn_attr; //动态属性
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(guid);

		dyn_attr.EnCode(net_data);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(guid);

		dyn_attr.EnCode(net_data);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!dyn_attr.DeCode(net_data))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!dyn_attr.DeCode(net_data))
			return false;

		return true;
	}
	void Reset(void)
	{
		guid = 0;

		dyn_attr.Reset();

	}
	ObjDynAttrNtf& operator= (const ObjDynAttrNtf& src)
	{
		guid = src.guid;

		dyn_attr = src.dyn_attr;

		return *this;
	}
	bool operator==(const ObjDynAttrNtf& src) const
	{
		if (guid != src.guid)
		{
			return false;
		}

		if (dyn_attr != src.dyn_attr)
		{
			return false;
		}

		return true;
	}
	bool operator != (const ObjDynAttrNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(ObjDynAttrNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_dyn_attr_handler(m_data.dyn_attr, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_dyn_attr_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.guid, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            switch (m_state)
            {
            case 1:
            {
                m_assigned_bitset.set(m_state);
                return &m_dyn_attr_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)memberCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_dyn_attr_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        ObjDynAttrNtf& m_data;
        DynAttrData::Handler m_dyn_attr_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"guid", guid);

		json_data.Writer().Key(u8"dyn_attr", sizeof(u8"dyn_attr") - 1);
		dyn_attr.ToJson(json_data);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        ObjDynAttrNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct CommitQuestItemRsp:Protocol<CommitQuestItemRsp>
{
	unsigned int              quest_id; //任务ID
	DataArray<GUIDCountData, unsigned char> items; //上交物品
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(quest_id);

		net_data.AddArray(items);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(quest_id);

		net_data.AddArray(items);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(quest_id))
			return false;

		if(!net_data.DelArray(items))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(quest_id))
			return false;

		if(!net_data.DelArray(items))
			return false;

		return true;
	}
	void Reset(void)
	{
		quest_id = 0;

		items.clear();

	}
	CommitQuestItemRsp& operator= (const CommitQuestItemRsp& src)
	{
		quest_id = src.quest_id;

		items = src.items;

		return *this;
	}
	bool operator==(const CommitQuestItemRsp& src) const
	{
		if (quest_id != src.quest_id)
		{
			return false;
		}

		if (items != src.items)
		{
			return false;
		}

		return true;
	}
	bool operator != (const CommitQuestItemRsp& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(CommitQuestItemRsp& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_items_handler(m_data.items, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_items_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.quest_id, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            switch (m_state)
            {
            case 1:
            {
                m_assigned_bitset.set(m_state);
                return &m_items_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)elementCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_items_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        CommitQuestItemRsp& m_data;
        DataArrayHandler<GUIDCountData, unsigned char, GUIDCountData::Handler> m_items_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"quest_id", quest_id);

		json_data.Writer().Key(u8"items", sizeof(u8"items") - 1);
		json_data.AddArray(items);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        CommitQuestItemRsp::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct CommitQuestItemNtf:Protocol<CommitQuestItemNtf>
{
	unsigned int              quest_id; //任务ID
	DataArray<IDCountData, unsigned char> items; //上交物品
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(quest_id);

		net_data.AddArray(items);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(quest_id);

		net_data.AddArray(items);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(quest_id))
			return false;

		if(!net_data.DelArray(items))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(quest_id))
			return false;

		if(!net_data.DelArray(items))
			return false;

		return true;
	}
	void Reset(void)
	{
		quest_id = 0;

		items.clear();

	}
	CommitQuestItemNtf& operator= (const CommitQuestItemNtf& src)
	{
		quest_id = src.quest_id;

		items = src.items;

		return *this;
	}
	bool operator==(const CommitQuestItemNtf& src) const
	{
		if (quest_id != src.quest_id)
		{
			return false;
		}

		if (items != src.items)
		{
			return false;
		}

		return true;
	}
	bool operator != (const CommitQuestItemNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(CommitQuestItemNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_items_handler(m_data.items, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_items_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.quest_id, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            switch (m_state)
            {
            case 1:
            {
                m_assigned_bitset.set(m_state);
                return &m_items_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)elementCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_items_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        CommitQuestItemNtf& m_data;
        DataArrayHandler<IDCountData, unsigned char, IDCountData::Handler> m_items_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"quest_id", quest_id);

		json_data.Writer().Key(u8"items", sizeof(u8"items") - 1);
		json_data.AddArray(items);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        CommitQuestItemNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct CommitQuestPetRsp:Protocol<CommitQuestPetRsp>
{
	unsigned int              quest_id; //任务ID
	DataArray<GUIDCountData, unsigned char> pets; //上交宠物
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(quest_id);

		net_data.AddArray(pets);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(quest_id);

		net_data.AddArray(pets);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(quest_id))
			return false;

		if(!net_data.DelArray(pets))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(quest_id))
			return false;

		if(!net_data.DelArray(pets))
			return false;

		return true;
	}
	void Reset(void)
	{
		quest_id = 0;

		pets.clear();

	}
	CommitQuestPetRsp& operator= (const CommitQuestPetRsp& src)
	{
		quest_id = src.quest_id;

		pets = src.pets;

		return *this;
	}
	bool operator==(const CommitQuestPetRsp& src) const
	{
		if (quest_id != src.quest_id)
		{
			return false;
		}

		if (pets != src.pets)
		{
			return false;
		}

		return true;
	}
	bool operator != (const CommitQuestPetRsp& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(CommitQuestPetRsp& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_pets_handler(m_data.pets, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_pets_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.quest_id, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            switch (m_state)
            {
            case 1:
            {
                m_assigned_bitset.set(m_state);
                return &m_pets_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)elementCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_pets_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        CommitQuestPetRsp& m_data;
        DataArrayHandler<GUIDCountData, unsigned char, GUIDCountData::Handler> m_pets_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"quest_id", quest_id);

		json_data.Writer().Key(u8"pets", sizeof(u8"pets") - 1);
		json_data.AddArray(pets);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        CommitQuestPetRsp::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct CommitQuestPetNtf:Protocol<CommitQuestPetNtf>
{
	unsigned int              quest_id; //任务ID
	DataArray<IDCountData, unsigned char> pets; //上交宠物
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(quest_id);

		net_data.AddArray(pets);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(quest_id);

		net_data.AddArray(pets);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(quest_id))
			return false;

		if(!net_data.DelArray(pets))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(quest_id))
			return false;

		if(!net_data.DelArray(pets))
			return false;

		return true;
	}
	void Reset(void)
	{
		quest_id = 0;

		pets.clear();

	}
	CommitQuestPetNtf& operator= (const CommitQuestPetNtf& src)
	{
		quest_id = src.quest_id;

		pets = src.pets;

		return *this;
	}
	bool operator==(const CommitQuestPetNtf& src) const
	{
		if (quest_id != src.quest_id)
		{
			return false;
		}

		if (pets != src.pets)
		{
			return false;
		}

		return true;
	}
	bool operator != (const CommitQuestPetNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(CommitQuestPetNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_pets_handler(m_data.pets, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_pets_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.quest_id, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            switch (m_state)
            {
            case 1:
            {
                m_assigned_bitset.set(m_state);
                return &m_pets_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)elementCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_pets_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        CommitQuestPetNtf& m_data;
        DataArrayHandler<IDCountData, unsigned char, IDCountData::Handler> m_pets_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"quest_id", quest_id);

		json_data.Writer().Key(u8"pets", sizeof(u8"pets") - 1);
		json_data.AddArray(pets);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        CommitQuestPetNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct AbandonQuest:Protocol<AbandonQuest>
{
	unsigned int              quest_id; //任务ID
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(quest_id);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(quest_id);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(quest_id))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(quest_id))
			return false;

		return true;
	}
	void Reset(void)
	{
		quest_id = 0;

	}
	AbandonQuest& operator= (const AbandonQuest& src)
	{
		quest_id = src.quest_id;

		return *this;
	}
	bool operator==(const AbandonQuest& src) const
	{
		if (quest_id != src.quest_id)
		{
			return false;
		}

		return true;
	}
	bool operator != (const AbandonQuest& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(AbandonQuest& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.quest_id, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        AbandonQuest& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"quest_id", quest_id);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        AbandonQuest::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct SkillTipsReq:Protocol<SkillTipsReq>
{
	unsigned long long        actor; //宠物guid,自己填0
	unsigned short            skill_id; //技能ID
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(actor);

		net_data.AddIntegral(skill_id);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(actor);

		net_data.AddIntegral(skill_id);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(actor))
			return false;

		if (!net_data.DelIntegral(skill_id))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(actor))
			return false;

		if (!net_data.DelIntegral(skill_id))
			return false;

		return true;
	}
	void Reset(void)
	{
		actor = 0;

		skill_id = 0;

	}
	SkillTipsReq& operator= (const SkillTipsReq& src)
	{
		actor = src.actor;

		skill_id = src.skill_id;

		return *this;
	}
	bool operator==(const SkillTipsReq& src) const
	{
		if (actor != src.actor)
		{
			return false;
		}

		if (skill_id != src.skill_id)
		{
			return false;
		}

		return true;
	}
	bool operator != (const SkillTipsReq& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(SkillTipsReq& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.actor, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.skill_id, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        SkillTipsReq& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"actor", actor);

		json_data.AddIntegral(u8"skill_id", skill_id);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        SkillTipsReq::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct SkillTipsAck:Protocol<SkillTipsAck>
{
	unsigned short            skill_id; //技能ID
	DataArray<SkillTipsData, unsigned char> tips; //tip属性
	int                       errcode; //错误码
	char                      errmsg[256]; //错误描述
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(skill_id);

		net_data.AddArray(tips);

		net_data.AddIntegral(errcode);

		net_data.AddString(errmsg, sizeof(errmsg));

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(skill_id);

		net_data.AddArray(tips);

		net_data.AddIntegral(errcode);

		net_data.AddString(errmsg, sizeof(errmsg));

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(skill_id))
			return false;

		if(!net_data.DelArray(tips))
			return false;

		if (!net_data.DelIntegral(errcode))
			return false;

		if (!net_data.DelString(errmsg, sizeof(errmsg)))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(skill_id))
			return false;

		if(!net_data.DelArray(tips))
			return false;

		if (!net_data.DelIntegral(errcode))
			return false;

		if (!net_data.DelString(errmsg, sizeof(errmsg)))
			return false;

		return true;
	}
	void Reset(void)
	{
		skill_id = 0;

		tips.clear();

		errcode = 0;

		errmsg[0] = 0;

	}
	SkillTipsAck& operator= (const SkillTipsAck& src)
	{
		skill_id = src.skill_id;

		tips = src.tips;

		errcode = src.errcode;

		{
			size_t str_len = strnlen(src.errmsg, sizeof(errmsg) - 1);
			memcpy(errmsg, src.errmsg, str_len + 1);
			errmsg[sizeof(errmsg) - 1] = 0;
		}

		return *this;
	}
	bool operator==(const SkillTipsAck& src) const
	{
		if (skill_id != src.skill_id)
		{
			return false;
		}

		if (tips != src.tips)
		{
			return false;
		}

		if (errcode != src.errcode)
		{
			return false;
		}

		if (strncmp(errmsg, src.errmsg, sizeof(errmsg)-1))
		{
			return false;
		}

		return true;
	}
	bool operator != (const SkillTipsAck& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(SkillTipsAck& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_tips_handler(m_data.tips, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_tips_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.skill_id, str, length);
            }
            break;
            case 2:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.errcode, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 3:
            {
                m_assigned_bitset.set(m_state);
                JsonDelString(m_data.errmsg, str, length);
            }
            break;
            default:
            {
                m_state = 0;
                return true;
            }
            }

            m_state++;
            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            switch (m_state)
            {
            case 1:
            {
                m_assigned_bitset.set(m_state);
                return &m_tips_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)elementCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_tips_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        SkillTipsAck& m_data;
        DataArrayHandler<SkillTipsData, unsigned char, SkillTipsData::Handler> m_tips_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<4> m_assigned_bitset;

        static const std::bitset<4> template_assigned_bitset;
        static const char* m_key_list[4];
        static const char* m_alias_list[4];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"skill_id", skill_id);

		json_data.Writer().Key(u8"tips", sizeof(u8"tips") - 1);
		json_data.AddArray(tips);

		json_data.AddIntegral(u8"errcode", errcode);

		json_data.AddString(u8"errmsg", errmsg, sizeof(errmsg));

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        SkillTipsAck::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct TeamLeaderOprNtf:Protocol<TeamLeaderOprNtf>
{
	unsigned char             opr; //队长操作
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(opr);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(opr);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(opr))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(opr))
			return false;

		return true;
	}
	void Reset(void)
	{
		opr = 0;

	}
	TeamLeaderOprNtf& operator= (const TeamLeaderOprNtf& src)
	{
		opr = src.opr;

		return *this;
	}
	bool operator==(const TeamLeaderOprNtf& src) const
	{
		if (opr != src.opr)
		{
			return false;
		}

		return true;
	}
	bool operator != (const TeamLeaderOprNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(TeamLeaderOprNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.opr, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        TeamLeaderOprNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"opr", opr);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        TeamLeaderOprNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct KeepAliveCtrlNtf:Protocol<KeepAliveCtrlNtf>
{
	unsigned char             opt; //0=关闭心跳 1=开启心跳
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(opt);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(opt);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(opt))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(opt))
			return false;

		return true;
	}
	void Reset(void)
	{
		opt = 0;

	}
	KeepAliveCtrlNtf& operator= (const KeepAliveCtrlNtf& src)
	{
		opt = src.opt;

		return *this;
	}
	bool operator==(const KeepAliveCtrlNtf& src) const
	{
		if (opt != src.opt)
		{
			return false;
		}

		return true;
	}
	bool operator != (const KeepAliveCtrlNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(KeepAliveCtrlNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.opt, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        KeepAliveCtrlNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"opt", opt);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        KeepAliveCtrlNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct NetDelayReq:Protocol<NetDelayReq>
{
	unsigned int              gs_tick; //GS发送此请求tick
	unsigned int              gt_tick; //GT发送此请求tick
	unsigned int              sg_tick; //SG发送此请求tick
	unsigned char             ping; //是否ping 1=开始 0=结束
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(gs_tick);

		net_data.AddIntegral(gt_tick);

		net_data.AddIntegral(sg_tick);

		net_data.AddIntegral(ping);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(gs_tick);

		net_data.AddIntegral(gt_tick);

		net_data.AddIntegral(sg_tick);

		net_data.AddIntegral(ping);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(gs_tick))
			return false;

		if (!net_data.DelIntegral(gt_tick))
			return false;

		if (!net_data.DelIntegral(sg_tick))
			return false;

		if (!net_data.DelIntegral(ping))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(gs_tick))
			return false;

		if (!net_data.DelIntegral(gt_tick))
			return false;

		if (!net_data.DelIntegral(sg_tick))
			return false;

		if (!net_data.DelIntegral(ping))
			return false;

		return true;
	}
	void Reset(void)
	{
		gs_tick = 0;

		gt_tick = 0;

		sg_tick = 0;

		ping = 0;

	}
	NetDelayReq& operator= (const NetDelayReq& src)
	{
		gs_tick = src.gs_tick;

		gt_tick = src.gt_tick;

		sg_tick = src.sg_tick;

		ping = src.ping;

		return *this;
	}
	bool operator==(const NetDelayReq& src) const
	{
		if (gs_tick != src.gs_tick)
		{
			return false;
		}

		if (gt_tick != src.gt_tick)
		{
			return false;
		}

		if (sg_tick != src.sg_tick)
		{
			return false;
		}

		if (ping != src.ping)
		{
			return false;
		}

		return true;
	}
	bool operator != (const NetDelayReq& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(NetDelayReq& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.gs_tick, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.gt_tick, str, length);
            }
            break;
            case 2:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.sg_tick, str, length);
            }
            break;
            case 3:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.ping, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        NetDelayReq& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<4> m_assigned_bitset;

        static const std::bitset<4> template_assigned_bitset;
        static const char* m_key_list[4];
        static const char* m_alias_list[4];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"gs_tick", gs_tick);

		json_data.AddIntegral(u8"gt_tick", gt_tick);

		json_data.AddIntegral(u8"sg_tick", sg_tick);

		json_data.AddIntegral(u8"ping", ping);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        NetDelayReq::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct NetDelayAck:Protocol<NetDelayAck>
{
	int                       gs_elpase; //GS从发出NetDelayReq到收到NetDelayAck的耗时
	int                       gt_elpase; //GT从发出NetDelayReq到收到NetDelayAck的耗时
	int                       sg_elpase; //SG从发出NetDelayReq到收到NetDelayAck的耗时
	int                       gt_cpu; //GT收到NetDelayAck时的cpu利用率
	int                       baidu_delay; //百度的延时
	int                       taobao_delay; //淘宝的延时
	char                      sg_id[256]; //云网关id
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(gs_elpase);

		net_data.AddIntegral(gt_elpase);

		net_data.AddIntegral(sg_elpase);

		net_data.AddIntegral(gt_cpu);

		net_data.AddIntegral(baidu_delay);

		net_data.AddIntegral(taobao_delay);

		net_data.AddString(sg_id, sizeof(sg_id));

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(gs_elpase);

		net_data.AddIntegral(gt_elpase);

		net_data.AddIntegral(sg_elpase);

		net_data.AddIntegral(gt_cpu);

		net_data.AddIntegral(baidu_delay);

		net_data.AddIntegral(taobao_delay);

		net_data.AddString(sg_id, sizeof(sg_id));

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(gs_elpase))
			return false;

		if (!net_data.DelIntegral(gt_elpase))
			return false;

		if (!net_data.DelIntegral(sg_elpase))
			return false;

		if (!net_data.DelIntegral(gt_cpu))
			return false;

		if (!net_data.DelIntegral(baidu_delay))
			return false;

		if (!net_data.DelIntegral(taobao_delay))
			return false;

		if (!net_data.DelString(sg_id, sizeof(sg_id)))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(gs_elpase))
			return false;

		if (!net_data.DelIntegral(gt_elpase))
			return false;

		if (!net_data.DelIntegral(sg_elpase))
			return false;

		if (!net_data.DelIntegral(gt_cpu))
			return false;

		if (!net_data.DelIntegral(baidu_delay))
			return false;

		if (!net_data.DelIntegral(taobao_delay))
			return false;

		if (!net_data.DelString(sg_id, sizeof(sg_id)))
			return false;

		return true;
	}
	void Reset(void)
	{
		gs_elpase = 0;

		gt_elpase = 0;

		sg_elpase = 0;

		gt_cpu = 0;

		baidu_delay = 0;

		taobao_delay = 0;

		sg_id[0] = 0;

	}
	NetDelayAck& operator= (const NetDelayAck& src)
	{
		gs_elpase = src.gs_elpase;

		gt_elpase = src.gt_elpase;

		sg_elpase = src.sg_elpase;

		gt_cpu = src.gt_cpu;

		baidu_delay = src.baidu_delay;

		taobao_delay = src.taobao_delay;

		{
			size_t str_len = strnlen(src.sg_id, sizeof(sg_id) - 1);
			memcpy(sg_id, src.sg_id, str_len + 1);
			sg_id[sizeof(sg_id) - 1] = 0;
		}

		return *this;
	}
	bool operator==(const NetDelayAck& src) const
	{
		if (gs_elpase != src.gs_elpase)
		{
			return false;
		}

		if (gt_elpase != src.gt_elpase)
		{
			return false;
		}

		if (sg_elpase != src.sg_elpase)
		{
			return false;
		}

		if (gt_cpu != src.gt_cpu)
		{
			return false;
		}

		if (baidu_delay != src.baidu_delay)
		{
			return false;
		}

		if (taobao_delay != src.taobao_delay)
		{
			return false;
		}

		if (strncmp(sg_id, src.sg_id, sizeof(sg_id)-1))
		{
			return false;
		}

		return true;
	}
	bool operator != (const NetDelayAck& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(NetDelayAck& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.gs_elpase, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.gt_elpase, str, length);
            }
            break;
            case 2:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.sg_elpase, str, length);
            }
            break;
            case 3:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.gt_cpu, str, length);
            }
            break;
            case 4:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.baidu_delay, str, length);
            }
            break;
            case 5:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.taobao_delay, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 6:
            {
                m_assigned_bitset.set(m_state);
                JsonDelString(m_data.sg_id, str, length);
            }
            break;
            default:
            {
                m_state = 0;
                return true;
            }
            }

            m_state++;
            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        NetDelayAck& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<7> m_assigned_bitset;

        static const std::bitset<7> template_assigned_bitset;
        static const char* m_key_list[7];
        static const char* m_alias_list[7];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"gs_elpase", gs_elpase);

		json_data.AddIntegral(u8"gt_elpase", gt_elpase);

		json_data.AddIntegral(u8"sg_elpase", sg_elpase);

		json_data.AddIntegral(u8"gt_cpu", gt_cpu);

		json_data.AddIntegral(u8"baidu_delay", baidu_delay);

		json_data.AddIntegral(u8"taobao_delay", taobao_delay);

		json_data.AddString(u8"sg_id", sg_id, sizeof(sg_id));

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        NetDelayAck::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct SystemSetupNtf:Protocol<SystemSetupNtf>
{
	DataArray<AttrData, unsigned short> attrs; //属性数据
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddArray(attrs);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddArray(attrs);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if(!net_data.DelArray(attrs))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if(!net_data.DelArray(attrs))
			return false;

		return true;
	}
	void Reset(void)
	{
		attrs.clear();

	}
	SystemSetupNtf& operator= (const SystemSetupNtf& src)
	{
		attrs = src.attrs;

		return *this;
	}
	bool operator==(const SystemSetupNtf& src) const
	{
		if (attrs != src.attrs)
		{
			return false;
		}

		return true;
	}
	bool operator != (const SystemSetupNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(SystemSetupNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_attrs_handler(m_data.attrs, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_attrs_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                return &m_attrs_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)elementCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_attrs_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        SystemSetupNtf& m_data;
        DataArrayHandler<AttrData, unsigned short, AttrData::Handler> m_attrs_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.Writer().Key(u8"attrs", sizeof(u8"attrs") - 1);
		json_data.AddArray(attrs);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        SystemSetupNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct BuffListNtf:Protocol<BuffListNtf>
{
	unsigned long long        guid; //玩家或宠物guid
	DataArray<BuffData, unsigned short> buffs; //BUFF列表
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(guid);

		net_data.AddArray(buffs);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(guid);

		net_data.AddArray(buffs);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if(!net_data.DelArray(buffs))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if(!net_data.DelArray(buffs))
			return false;

		return true;
	}
	void Reset(void)
	{
		guid = 0;

		buffs.clear();

	}
	BuffListNtf& operator= (const BuffListNtf& src)
	{
		guid = src.guid;

		buffs = src.buffs;

		return *this;
	}
	bool operator==(const BuffListNtf& src) const
	{
		if (guid != src.guid)
		{
			return false;
		}

		if (buffs != src.buffs)
		{
			return false;
		}

		return true;
	}
	bool operator != (const BuffListNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(BuffListNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_buffs_handler(m_data.buffs, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_buffs_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.guid, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            switch (m_state)
            {
            case 1:
            {
                m_assigned_bitset.set(m_state);
                return &m_buffs_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)elementCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_buffs_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        BuffListNtf& m_data;
        DataArrayHandler<BuffData, unsigned short, BuffData::Handler> m_buffs_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"guid", guid);

		json_data.Writer().Key(u8"buffs", sizeof(u8"buffs") - 1);
		json_data.AddArray(buffs);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        BuffListNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct BuffAddNtf:Protocol<BuffAddNtf>
{
	unsigned long long        guid; //玩家或宠物guid
	BuffData                  buff; //BUFF列表
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(guid);

		buff.EnCode(net_data);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(guid);

		buff.EnCode(net_data);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!buff.DeCode(net_data))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!buff.DeCode(net_data))
			return false;

		return true;
	}
	void Reset(void)
	{
		guid = 0;

		buff.Reset();

	}
	BuffAddNtf& operator= (const BuffAddNtf& src)
	{
		guid = src.guid;

		buff = src.buff;

		return *this;
	}
	bool operator==(const BuffAddNtf& src) const
	{
		if (guid != src.guid)
		{
			return false;
		}

		if (buff != src.buff)
		{
			return false;
		}

		return true;
	}
	bool operator != (const BuffAddNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(BuffAddNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_buff_handler(m_data.buff, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_buff_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.guid, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            switch (m_state)
            {
            case 1:
            {
                m_assigned_bitset.set(m_state);
                return &m_buff_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)memberCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_buff_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        BuffAddNtf& m_data;
        BuffData::Handler m_buff_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"guid", guid);

		json_data.Writer().Key(u8"buff", sizeof(u8"buff") - 1);
		buff.ToJson(json_data);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        BuffAddNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct BuffDurationNtf:Protocol<BuffDurationNtf>
{
	unsigned long long        guid; //玩家或宠物guid
	unsigned short            id; //buff的id
	unsigned int              duration; //持续数值
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(guid);

		net_data.AddIntegral(id);

		net_data.AddIntegral(duration);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(guid);

		net_data.AddIntegral(id);

		net_data.AddIntegral(duration);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!net_data.DelIntegral(id))
			return false;

		if (!net_data.DelIntegral(duration))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!net_data.DelIntegral(id))
			return false;

		if (!net_data.DelIntegral(duration))
			return false;

		return true;
	}
	void Reset(void)
	{
		guid = 0;

		id = 0;

		duration = 0;

	}
	BuffDurationNtf& operator= (const BuffDurationNtf& src)
	{
		guid = src.guid;

		id = src.id;

		duration = src.duration;

		return *this;
	}
	bool operator==(const BuffDurationNtf& src) const
	{
		if (guid != src.guid)
		{
			return false;
		}

		if (id != src.id)
		{
			return false;
		}

		if (duration != src.duration)
		{
			return false;
		}

		return true;
	}
	bool operator != (const BuffDurationNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(BuffDurationNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.guid, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.id, str, length);
            }
            break;
            case 2:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.duration, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        BuffDurationNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<3> m_assigned_bitset;

        static const std::bitset<3> template_assigned_bitset;
        static const char* m_key_list[3];
        static const char* m_alias_list[3];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"guid", guid);

		json_data.AddIntegral(u8"id", id);

		json_data.AddIntegral(u8"duration", duration);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        BuffDurationNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct BuffDynAttrNtf:Protocol<BuffDynAttrNtf>
{
	unsigned long long        guid; //玩家或宠物guid
	unsigned short            id; //buff的id
	DataArray<DynAttrData, unsigned short> dyn_attrs; //动态属性数据
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(guid);

		net_data.AddIntegral(id);

		net_data.AddArray(dyn_attrs);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(guid);

		net_data.AddIntegral(id);

		net_data.AddArray(dyn_attrs);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!net_data.DelIntegral(id))
			return false;

		if(!net_data.DelArray(dyn_attrs))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!net_data.DelIntegral(id))
			return false;

		if(!net_data.DelArray(dyn_attrs))
			return false;

		return true;
	}
	void Reset(void)
	{
		guid = 0;

		id = 0;

		dyn_attrs.clear();

	}
	BuffDynAttrNtf& operator= (const BuffDynAttrNtf& src)
	{
		guid = src.guid;

		id = src.id;

		dyn_attrs = src.dyn_attrs;

		return *this;
	}
	bool operator==(const BuffDynAttrNtf& src) const
	{
		if (guid != src.guid)
		{
			return false;
		}

		if (id != src.id)
		{
			return false;
		}

		if (dyn_attrs != src.dyn_attrs)
		{
			return false;
		}

		return true;
	}
	bool operator != (const BuffDynAttrNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(BuffDynAttrNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_dyn_attrs_handler(m_data.dyn_attrs, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_dyn_attrs_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.guid, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.id, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            switch (m_state)
            {
            case 2:
            {
                m_assigned_bitset.set(m_state);
                return &m_dyn_attrs_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)elementCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_dyn_attrs_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        BuffDynAttrNtf& m_data;
        DataArrayHandler<DynAttrData, unsigned short, DynAttrData::Handler> m_dyn_attrs_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<3> m_assigned_bitset;

        static const std::bitset<3> template_assigned_bitset;
        static const char* m_key_list[3];
        static const char* m_alias_list[3];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"guid", guid);

		json_data.AddIntegral(u8"id", id);

		json_data.Writer().Key(u8"dyn_attrs", sizeof(u8"dyn_attrs") - 1);
		json_data.AddArray(dyn_attrs);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        BuffDynAttrNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct StopBuff:Protocol<StopBuff>
{
	unsigned long long        guid; //玩家或宠物guid,玩家的填0
	unsigned short            id; //buff的id
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(guid);

		net_data.AddIntegral(id);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(guid);

		net_data.AddIntegral(id);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!net_data.DelIntegral(id))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!net_data.DelIntegral(id))
			return false;

		return true;
	}
	void Reset(void)
	{
		guid = 0;

		id = 0;

	}
	StopBuff& operator= (const StopBuff& src)
	{
		guid = src.guid;

		id = src.id;

		return *this;
	}
	bool operator==(const StopBuff& src) const
	{
		if (guid != src.guid)
		{
			return false;
		}

		if (id != src.id)
		{
			return false;
		}

		return true;
	}
	bool operator != (const StopBuff& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(StopBuff& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.guid, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.id, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        StopBuff& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"guid", guid);

		json_data.AddIntegral(u8"id", id);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        StopBuff::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct BuffDelNtf:Protocol<BuffDelNtf>
{
	unsigned long long        guid; //玩家或宠物guid
	unsigned short            id; //buff的id
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(guid);

		net_data.AddIntegral(id);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(guid);

		net_data.AddIntegral(id);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!net_data.DelIntegral(id))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!net_data.DelIntegral(id))
			return false;

		return true;
	}
	void Reset(void)
	{
		guid = 0;

		id = 0;

	}
	BuffDelNtf& operator= (const BuffDelNtf& src)
	{
		guid = src.guid;

		id = src.id;

		return *this;
	}
	bool operator==(const BuffDelNtf& src) const
	{
		if (guid != src.guid)
		{
			return false;
		}

		if (id != src.id)
		{
			return false;
		}

		return true;
	}
	bool operator != (const BuffDelNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(BuffDelNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.guid, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.id, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        BuffDelNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"guid", guid);

		json_data.AddIntegral(u8"id", id);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        BuffDelNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct ActivityListReq:Protocol<ActivityListReq>
{
	bool EnCode(NetEnCode& net_data)
	{
		(void)(net_data);
		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		(void)(net_data);
		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		(void)(net_data);
		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		(void)(net_data);
		return true;
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(ActivityListReq& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            return true;
        }
    private:
        ActivityListReq& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        ActivityListReq::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct ActivityListAck:Protocol<ActivityListAck>
{
	DataArray<ActivityData, unsigned short> datas; //活动数据
	int                       errcode; //错误码
	char                      errmsg[256]; //错误描述
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddArray(datas);

		net_data.AddIntegral(errcode);

		net_data.AddString(errmsg, sizeof(errmsg));

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddArray(datas);

		net_data.AddIntegral(errcode);

		net_data.AddString(errmsg, sizeof(errmsg));

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if(!net_data.DelArray(datas))
			return false;

		if (!net_data.DelIntegral(errcode))
			return false;

		if (!net_data.DelString(errmsg, sizeof(errmsg)))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if(!net_data.DelArray(datas))
			return false;

		if (!net_data.DelIntegral(errcode))
			return false;

		if (!net_data.DelString(errmsg, sizeof(errmsg)))
			return false;

		return true;
	}
	void Reset(void)
	{
		datas.clear();

		errcode = 0;

		errmsg[0] = 0;

	}
	ActivityListAck& operator= (const ActivityListAck& src)
	{
		datas = src.datas;

		errcode = src.errcode;

		{
			size_t str_len = strnlen(src.errmsg, sizeof(errmsg) - 1);
			memcpy(errmsg, src.errmsg, str_len + 1);
			errmsg[sizeof(errmsg) - 1] = 0;
		}

		return *this;
	}
	bool operator==(const ActivityListAck& src) const
	{
		if (datas != src.datas)
		{
			return false;
		}

		if (errcode != src.errcode)
		{
			return false;
		}

		if (strncmp(errmsg, src.errmsg, sizeof(errmsg)-1))
		{
			return false;
		}

		return true;
	}
	bool operator != (const ActivityListAck& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(ActivityListAck& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_datas_handler(m_data.datas, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_datas_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.errcode, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 2:
            {
                m_assigned_bitset.set(m_state);
                JsonDelString(m_data.errmsg, str, length);
            }
            break;
            default:
            {
                m_state = 0;
                return true;
            }
            }

            m_state++;
            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                return &m_datas_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)elementCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_datas_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        ActivityListAck& m_data;
        DataArrayHandler<ActivityData, unsigned short, ActivityData::Handler> m_datas_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<3> m_assigned_bitset;

        static const std::bitset<3> template_assigned_bitset;
        static const char* m_key_list[3];
        static const char* m_alias_list[3];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.Writer().Key(u8"datas", sizeof(u8"datas") - 1);
		json_data.AddArray(datas);

		json_data.AddIntegral(u8"errcode", errcode);

		json_data.AddString(u8"errmsg", errmsg, sizeof(errmsg));

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        ActivityListAck::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct ActivityJoinNtf:Protocol<ActivityJoinNtf>
{
	unsigned short            id; //活动的id
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(id);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(id);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(id))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(id))
			return false;

		return true;
	}
	void Reset(void)
	{
		id = 0;

	}
	ActivityJoinNtf& operator= (const ActivityJoinNtf& src)
	{
		id = src.id;

		return *this;
	}
	bool operator==(const ActivityJoinNtf& src) const
	{
		if (id != src.id)
		{
			return false;
		}

		return true;
	}
	bool operator != (const ActivityJoinNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(ActivityJoinNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.id, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        ActivityJoinNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"id", id);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        ActivityJoinNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct GuildListNtf:Protocol<GuildListNtf>
{
	int                       pos; //帮派索引
	unsigned short            count; //帮派总数
	DataArray<GuildBriefData, unsigned short> guilds; //帮派简略信息
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(pos);

		net_data.AddIntegral(count);

		net_data.AddArray(guilds);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(pos);

		net_data.AddIntegral(count);

		net_data.AddArray(guilds);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(pos))
			return false;

		if (!net_data.DelIntegral(count))
			return false;

		if(!net_data.DelArray(guilds))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(pos))
			return false;

		if (!net_data.DelIntegral(count))
			return false;

		if(!net_data.DelArray(guilds))
			return false;

		return true;
	}
	void Reset(void)
	{
		pos = 0;

		count = 0;

		guilds.clear();

	}
	GuildListNtf& operator= (const GuildListNtf& src)
	{
		pos = src.pos;

		count = src.count;

		guilds = src.guilds;

		return *this;
	}
	bool operator==(const GuildListNtf& src) const
	{
		if (pos != src.pos)
		{
			return false;
		}

		if (count != src.count)
		{
			return false;
		}

		if (guilds != src.guilds)
		{
			return false;
		}

		return true;
	}
	bool operator != (const GuildListNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(GuildListNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_guilds_handler(m_data.guilds, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_guilds_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.pos, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.count, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            switch (m_state)
            {
            case 2:
            {
                m_assigned_bitset.set(m_state);
                return &m_guilds_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)elementCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_guilds_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        GuildListNtf& m_data;
        DataArrayHandler<GuildBriefData, unsigned short, GuildBriefData::Handler> m_guilds_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<3> m_assigned_bitset;

        static const std::bitset<3> template_assigned_bitset;
        static const char* m_key_list[3];
        static const char* m_alias_list[3];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"pos", pos);

		json_data.AddIntegral(u8"count", count);

		json_data.Writer().Key(u8"guilds", sizeof(u8"guilds") - 1);
		json_data.AddArray(guilds);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        GuildListNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct GuildNtf:Protocol<GuildNtf>
{
	GuildData                 guild; //帮派数据
	GuildMemberData           self; //帮派成员信息
	bool EnCode(NetEnCode& net_data)
	{
		guild.EnCode(net_data);

		self.EnCode(net_data);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		guild.EnCode(net_data);

		self.EnCode(net_data);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!guild.DeCode(net_data))
			return false;

		if (!self.DeCode(net_data))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!guild.DeCode(net_data))
			return false;

		if (!self.DeCode(net_data))
			return false;

		return true;
	}
	void Reset(void)
	{
		guild.Reset();

		self.Reset();

	}
	GuildNtf& operator= (const GuildNtf& src)
	{
		guild = src.guild;

		self = src.self;

		return *this;
	}
	bool operator==(const GuildNtf& src) const
	{
		if (guild != src.guild)
		{
			return false;
		}

		if (self != src.self)
		{
			return false;
		}

		return true;
	}
	bool operator != (const GuildNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(GuildNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_guild_handler(m_data.guild, this),
            m_self_handler(m_data.self, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_guild_handler.ResetState();
            m_self_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                return &m_guild_handler;
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                return &m_self_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)memberCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_guild_handler.IsAllMemberSet())
            {
                return false;
            }

            if (!m_self_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        GuildNtf& m_data;
        GuildData::Handler m_guild_handler;
        GuildMemberData::Handler m_self_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.Writer().Key(u8"guild", sizeof(u8"guild") - 1);
		guild.ToJson(json_data);

		json_data.Writer().Key(u8"self", sizeof(u8"self") - 1);
		self.ToJson(json_data);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        GuildNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct GuildBaseNtf:Protocol<GuildBaseNtf>
{
	unsigned long long        guid; //帮派guid
	char                      name[32]; //帮派名称
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(guid);

		net_data.AddString(name, sizeof(name));

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(guid);

		net_data.AddString(name, sizeof(name));

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!net_data.DelString(name, sizeof(name)))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!net_data.DelString(name, sizeof(name)))
			return false;

		return true;
	}
	void Reset(void)
	{
		guid = 0;

		name[0] = 0;

	}
	GuildBaseNtf& operator= (const GuildBaseNtf& src)
	{
		guid = src.guid;

		{
			size_t str_len = strnlen(src.name, sizeof(name) - 1);
			memcpy(name, src.name, str_len + 1);
			name[sizeof(name) - 1] = 0;
		}

		return *this;
	}
	bool operator==(const GuildBaseNtf& src) const
	{
		if (guid != src.guid)
		{
			return false;
		}

		if (strncmp(name, src.name, sizeof(name)-1))
		{
			return false;
		}

		return true;
	}
	bool operator != (const GuildBaseNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(GuildBaseNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.guid, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelString(m_data.name, str, length);
            }
            break;
            default:
            {
                m_state = 0;
                return true;
            }
            }

            m_state++;
            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        GuildBaseNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"guid", guid);

		json_data.AddString(u8"name", name, sizeof(name));

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        GuildBaseNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct GuildNoticeNtf:Protocol<GuildNoticeNtf>
{
	unsigned long long        guid; //帮派guid
	char                      notice[1024]; //通知内容
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(guid);

		net_data.AddString(notice, sizeof(notice));

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(guid);

		net_data.AddString(notice, sizeof(notice));

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!net_data.DelString(notice, sizeof(notice)))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!net_data.DelString(notice, sizeof(notice)))
			return false;

		return true;
	}
	void Reset(void)
	{
		guid = 0;

		notice[0] = 0;

	}
	GuildNoticeNtf& operator= (const GuildNoticeNtf& src)
	{
		guid = src.guid;

		{
			size_t str_len = strnlen(src.notice, sizeof(notice) - 1);
			memcpy(notice, src.notice, str_len + 1);
			notice[sizeof(notice) - 1] = 0;
		}

		return *this;
	}
	bool operator==(const GuildNoticeNtf& src) const
	{
		if (guid != src.guid)
		{
			return false;
		}

		if (strncmp(notice, src.notice, sizeof(notice)-1))
		{
			return false;
		}

		return true;
	}
	bool operator != (const GuildNoticeNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(GuildNoticeNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.guid, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelString(m_data.notice, str, length);
            }
            break;
            default:
            {
                m_state = 0;
                return true;
            }
            }

            m_state++;
            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        GuildNoticeNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"guid", guid);

		json_data.AddString(u8"notice", notice, sizeof(notice));

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        GuildNoticeNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct GuildBriefNtf:Protocol<GuildBriefNtf>
{
	GuildBriefData            guild; //帮派简略信息
	bool EnCode(NetEnCode& net_data)
	{
		guild.EnCode(net_data);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		guild.EnCode(net_data);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!guild.DeCode(net_data))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!guild.DeCode(net_data))
			return false;

		return true;
	}
	void Reset(void)
	{
		guild.Reset();

	}
	GuildBriefNtf& operator= (const GuildBriefNtf& src)
	{
		guild = src.guild;

		return *this;
	}
	bool operator==(const GuildBriefNtf& src) const
	{
		if (guild != src.guild)
		{
			return false;
		}

		return true;
	}
	bool operator != (const GuildBriefNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(GuildBriefNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_guild_handler(m_data.guild, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_guild_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                return &m_guild_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)memberCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_guild_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        GuildBriefNtf& m_data;
        GuildBriefData::Handler m_guild_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.Writer().Key(u8"guild", sizeof(u8"guild") - 1);
		guild.ToJson(json_data);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        GuildBriefNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct GuildMemberListNtf:Protocol<GuildMemberListNtf>
{
	unsigned long long        guid; //帮派GUID
	int                       pos; //成员索引
	unsigned short            count; //帮派成员总数
	DataArray<GuildMemberBriefData, unsigned short> members; //帮派成员数据
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(guid);

		net_data.AddIntegral(pos);

		net_data.AddIntegral(count);

		net_data.AddArray(members);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(guid);

		net_data.AddIntegral(pos);

		net_data.AddIntegral(count);

		net_data.AddArray(members);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!net_data.DelIntegral(pos))
			return false;

		if (!net_data.DelIntegral(count))
			return false;

		if(!net_data.DelArray(members))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!net_data.DelIntegral(pos))
			return false;

		if (!net_data.DelIntegral(count))
			return false;

		if(!net_data.DelArray(members))
			return false;

		return true;
	}
	void Reset(void)
	{
		guid = 0;

		pos = 0;

		count = 0;

		members.clear();

	}
	GuildMemberListNtf& operator= (const GuildMemberListNtf& src)
	{
		guid = src.guid;

		pos = src.pos;

		count = src.count;

		members = src.members;

		return *this;
	}
	bool operator==(const GuildMemberListNtf& src) const
	{
		if (guid != src.guid)
		{
			return false;
		}

		if (pos != src.pos)
		{
			return false;
		}

		if (count != src.count)
		{
			return false;
		}

		if (members != src.members)
		{
			return false;
		}

		return true;
	}
	bool operator != (const GuildMemberListNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(GuildMemberListNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_members_handler(m_data.members, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_members_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.guid, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.pos, str, length);
            }
            break;
            case 2:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.count, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            switch (m_state)
            {
            case 3:
            {
                m_assigned_bitset.set(m_state);
                return &m_members_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)elementCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_members_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        GuildMemberListNtf& m_data;
        DataArrayHandler<GuildMemberBriefData, unsigned short, GuildMemberBriefData::Handler> m_members_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<4> m_assigned_bitset;

        static const std::bitset<4> template_assigned_bitset;
        static const char* m_key_list[4];
        static const char* m_alias_list[4];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"guid", guid);

		json_data.AddIntegral(u8"pos", pos);

		json_data.AddIntegral(u8"count", count);

		json_data.Writer().Key(u8"members", sizeof(u8"members") - 1);
		json_data.AddArray(members);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        GuildMemberListNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct GuildMemberNtf:Protocol<GuildMemberNtf>
{
	unsigned long long        guid; //帮派GUID
	DataArray<GuildMemberData, unsigned short> members; //帮派成员数据
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(guid);

		net_data.AddArray(members);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(guid);

		net_data.AddArray(members);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if(!net_data.DelArray(members))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if(!net_data.DelArray(members))
			return false;

		return true;
	}
	void Reset(void)
	{
		guid = 0;

		members.clear();

	}
	GuildMemberNtf& operator= (const GuildMemberNtf& src)
	{
		guid = src.guid;

		members = src.members;

		return *this;
	}
	bool operator==(const GuildMemberNtf& src) const
	{
		if (guid != src.guid)
		{
			return false;
		}

		if (members != src.members)
		{
			return false;
		}

		return true;
	}
	bool operator != (const GuildMemberNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(GuildMemberNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_members_handler(m_data.members, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_members_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.guid, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            switch (m_state)
            {
            case 1:
            {
                m_assigned_bitset.set(m_state);
                return &m_members_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)elementCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_members_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        GuildMemberNtf& m_data;
        DataArrayHandler<GuildMemberData, unsigned short, GuildMemberData::Handler> m_members_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"guid", guid);

		json_data.Writer().Key(u8"members", sizeof(u8"members") - 1);
		json_data.AddArray(members);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        GuildMemberNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct GuildApplicantListNtf:Protocol<GuildApplicantListNtf>
{
	unsigned long long        guid; //帮派GUID
	DataArray<GuildApplicantData, unsigned short> applicants; //帮派申请列表
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(guid);

		net_data.AddArray(applicants);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(guid);

		net_data.AddArray(applicants);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if(!net_data.DelArray(applicants))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if(!net_data.DelArray(applicants))
			return false;

		return true;
	}
	void Reset(void)
	{
		guid = 0;

		applicants.clear();

	}
	GuildApplicantListNtf& operator= (const GuildApplicantListNtf& src)
	{
		guid = src.guid;

		applicants = src.applicants;

		return *this;
	}
	bool operator==(const GuildApplicantListNtf& src) const
	{
		if (guid != src.guid)
		{
			return false;
		}

		if (applicants != src.applicants)
		{
			return false;
		}

		return true;
	}
	bool operator != (const GuildApplicantListNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(GuildApplicantListNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_applicants_handler(m_data.applicants, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_applicants_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.guid, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            switch (m_state)
            {
            case 1:
            {
                m_assigned_bitset.set(m_state);
                return &m_applicants_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)elementCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_applicants_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        GuildApplicantListNtf& m_data;
        DataArrayHandler<GuildApplicantData, unsigned short, GuildApplicantData::Handler> m_applicants_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"guid", guid);

		json_data.Writer().Key(u8"applicants", sizeof(u8"applicants") - 1);
		json_data.AddArray(applicants);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        GuildApplicantListNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct GuildOperationNtf:Protocol<GuildOperationNtf>
{
	unsigned short            type; //操作通知
	char                      param1[256]; //参数1
	char                      param2[256]; //参数2
	int                       errcode; //0=成功, 其他表示错误码
	char                      errmsg[256]; //错误码不为0时表示 错误消息
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(type);

		net_data.AddString(param1, sizeof(param1));

		net_data.AddString(param2, sizeof(param2));

		net_data.AddIntegral(errcode);

		net_data.AddString(errmsg, sizeof(errmsg));

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(type);

		net_data.AddString(param1, sizeof(param1));

		net_data.AddString(param2, sizeof(param2));

		net_data.AddIntegral(errcode);

		net_data.AddString(errmsg, sizeof(errmsg));

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(type))
			return false;

		if (!net_data.DelString(param1, sizeof(param1)))
			return false;

		if (!net_data.DelString(param2, sizeof(param2)))
			return false;

		if (!net_data.DelIntegral(errcode))
			return false;

		if (!net_data.DelString(errmsg, sizeof(errmsg)))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(type))
			return false;

		if (!net_data.DelString(param1, sizeof(param1)))
			return false;

		if (!net_data.DelString(param2, sizeof(param2)))
			return false;

		if (!net_data.DelIntegral(errcode))
			return false;

		if (!net_data.DelString(errmsg, sizeof(errmsg)))
			return false;

		return true;
	}
	void Reset(void)
	{
		type = 0;

		param1[0] = 0;

		param2[0] = 0;

		errcode = 0;

		errmsg[0] = 0;

	}
	GuildOperationNtf& operator= (const GuildOperationNtf& src)
	{
		type = src.type;

		{
			size_t str_len = strnlen(src.param1, sizeof(param1) - 1);
			memcpy(param1, src.param1, str_len + 1);
			param1[sizeof(param1) - 1] = 0;
		}

		{
			size_t str_len = strnlen(src.param2, sizeof(param2) - 1);
			memcpy(param2, src.param2, str_len + 1);
			param2[sizeof(param2) - 1] = 0;
		}

		errcode = src.errcode;

		{
			size_t str_len = strnlen(src.errmsg, sizeof(errmsg) - 1);
			memcpy(errmsg, src.errmsg, str_len + 1);
			errmsg[sizeof(errmsg) - 1] = 0;
		}

		return *this;
	}
	bool operator==(const GuildOperationNtf& src) const
	{
		if (type != src.type)
		{
			return false;
		}

		if (strncmp(param1, src.param1, sizeof(param1)-1))
		{
			return false;
		}

		if (strncmp(param2, src.param2, sizeof(param2)-1))
		{
			return false;
		}

		if (errcode != src.errcode)
		{
			return false;
		}

		if (strncmp(errmsg, src.errmsg, sizeof(errmsg)-1))
		{
			return false;
		}

		return true;
	}
	bool operator != (const GuildOperationNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(GuildOperationNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.type, str, length);
            }
            break;
            case 3:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.errcode, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelString(m_data.param1, str, length);
            }
            break;
            case 2:
            {
                m_assigned_bitset.set(m_state);
                JsonDelString(m_data.param2, str, length);
            }
            break;
            case 4:
            {
                m_assigned_bitset.set(m_state);
                JsonDelString(m_data.errmsg, str, length);
            }
            break;
            default:
            {
                m_state = 0;
                return true;
            }
            }

            m_state++;
            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        GuildOperationNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<5> m_assigned_bitset;

        static const std::bitset<5> template_assigned_bitset;
        static const char* m_key_list[5];
        static const char* m_alias_list[5];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"type", type);

		json_data.AddString(u8"param1", param1, sizeof(param1));

		json_data.AddString(u8"param2", param2, sizeof(param2));

		json_data.AddIntegral(u8"errcode", errcode);

		json_data.AddString(u8"errmsg", errmsg, sizeof(errmsg));

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        GuildOperationNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct GetTimestampReq:Protocol<GetTimestampReq>
{
	bool EnCode(NetEnCode& net_data)
	{
		(void)(net_data);
		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		(void)(net_data);
		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		(void)(net_data);
		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		(void)(net_data);
		return true;
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(GetTimestampReq& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            return true;
        }
    private:
        GetTimestampReq& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        GetTimestampReq::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct GetTimestampAck:Protocol<GetTimestampAck>
{
	unsigned int              now; //当前时间
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(now);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(now);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(now))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(now))
			return false;

		return true;
	}
	void Reset(void)
	{
		now = 0;

	}
	GetTimestampAck& operator= (const GetTimestampAck& src)
	{
		now = src.now;

		return *this;
	}
	bool operator==(const GetTimestampAck& src) const
	{
		if (now != src.now)
		{
			return false;
		}

		return true;
	}
	bool operator != (const GetTimestampAck& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(GetTimestampAck& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.now, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        GetTimestampAck& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"now", now);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        GetTimestampAck::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct ContactListNtf:Protocol<ContactListNtf>
{
	unsigned char             contact_type; //联系人类型：对应枚举contact_type的陌生人、好友、申请者
	DataArray<ContactData, unsigned short> contacts; //联系人列表
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(contact_type);

		net_data.AddArray(contacts);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(contact_type);

		net_data.AddArray(contacts);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(contact_type))
			return false;

		if(!net_data.DelArray(contacts))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(contact_type))
			return false;

		if(!net_data.DelArray(contacts))
			return false;

		return true;
	}
	void Reset(void)
	{
		contact_type = 0;

		contacts.clear();

	}
	ContactListNtf& operator= (const ContactListNtf& src)
	{
		contact_type = src.contact_type;

		contacts = src.contacts;

		return *this;
	}
	bool operator==(const ContactListNtf& src) const
	{
		if (contact_type != src.contact_type)
		{
			return false;
		}

		if (contacts != src.contacts)
		{
			return false;
		}

		return true;
	}
	bool operator != (const ContactListNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(ContactListNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_contacts_handler(m_data.contacts, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_contacts_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.contact_type, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            switch (m_state)
            {
            case 1:
            {
                m_assigned_bitset.set(m_state);
                return &m_contacts_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)elementCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_contacts_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        ContactListNtf& m_data;
        DataArrayHandler<ContactData, unsigned short, ContactData::Handler> m_contacts_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"contact_type", contact_type);

		json_data.Writer().Key(u8"contacts", sizeof(u8"contacts") - 1);
		json_data.AddArray(contacts);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        ContactListNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct AddContactNtf:Protocol<AddContactNtf>
{
	ContactData               contact; //联系人
	bool EnCode(NetEnCode& net_data)
	{
		contact.EnCode(net_data);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		contact.EnCode(net_data);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!contact.DeCode(net_data))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!contact.DeCode(net_data))
			return false;

		return true;
	}
	void Reset(void)
	{
		contact.Reset();

	}
	AddContactNtf& operator= (const AddContactNtf& src)
	{
		contact = src.contact;

		return *this;
	}
	bool operator==(const AddContactNtf& src) const
	{
		if (contact != src.contact)
		{
			return false;
		}

		return true;
	}
	bool operator != (const AddContactNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(AddContactNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_contact_handler(m_data.contact, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_contact_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                return &m_contact_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)memberCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_contact_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        AddContactNtf& m_data;
        ContactData::Handler m_contact_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.Writer().Key(u8"contact", sizeof(u8"contact") - 1);
		contact.ToJson(json_data);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        AddContactNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct UpdateContactNtf:Protocol<UpdateContactNtf>
{
	ContactData               contact; //联系人
	bool EnCode(NetEnCode& net_data)
	{
		contact.EnCode(net_data);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		contact.EnCode(net_data);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!contact.DeCode(net_data))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!contact.DeCode(net_data))
			return false;

		return true;
	}
	void Reset(void)
	{
		contact.Reset();

	}
	UpdateContactNtf& operator= (const UpdateContactNtf& src)
	{
		contact = src.contact;

		return *this;
	}
	bool operator==(const UpdateContactNtf& src) const
	{
		if (contact != src.contact)
		{
			return false;
		}

		return true;
	}
	bool operator != (const UpdateContactNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(UpdateContactNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_contact_handler(m_data.contact, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_contact_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                return &m_contact_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)memberCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_contact_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        UpdateContactNtf& m_data;
        ContactData::Handler m_contact_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.Writer().Key(u8"contact", sizeof(u8"contact") - 1);
		contact.ToJson(json_data);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        UpdateContactNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct DelContactNtf:Protocol<DelContactNtf>
{
	unsigned long long        target_guid; //玩家GUID
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(target_guid);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(target_guid);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(target_guid))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(target_guid))
			return false;

		return true;
	}
	void Reset(void)
	{
		target_guid = 0;

	}
	DelContactNtf& operator= (const DelContactNtf& src)
	{
		target_guid = src.target_guid;

		return *this;
	}
	bool operator==(const DelContactNtf& src) const
	{
		if (target_guid != src.target_guid)
		{
			return false;
		}

		return true;
	}
	bool operator != (const DelContactNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(DelContactNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.target_guid, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        DelContactNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"target_guid", target_guid);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        DelContactNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct AddContactMessageNtf:Protocol<AddContactMessageNtf>
{
	MessageData               messages; //消息内容
	bool EnCode(NetEnCode& net_data)
	{
		messages.EnCode(net_data);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		messages.EnCode(net_data);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!messages.DeCode(net_data))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!messages.DeCode(net_data))
			return false;

		return true;
	}
	void Reset(void)
	{
		messages.Reset();

	}
	AddContactMessageNtf& operator= (const AddContactMessageNtf& src)
	{
		messages = src.messages;

		return *this;
	}
	bool operator==(const AddContactMessageNtf& src) const
	{
		if (messages != src.messages)
		{
			return false;
		}

		return true;
	}
	bool operator != (const AddContactMessageNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(AddContactMessageNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_messages_handler(m_data.messages, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_messages_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                return &m_messages_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)memberCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_messages_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        AddContactMessageNtf& m_data;
        MessageData::Handler m_messages_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.Writer().Key(u8"messages", sizeof(u8"messages") - 1);
		messages.ToJson(json_data);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        AddContactMessageNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct ItemQueryNtf:Protocol<ItemQueryNtf>
{
	ItemData                  item; //物品数据
	bool EnCode(NetEnCode& net_data)
	{
		item.EnCode(net_data);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		item.EnCode(net_data);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!item.DeCode(net_data))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!item.DeCode(net_data))
			return false;

		return true;
	}
	void Reset(void)
	{
		item.Reset();

	}
	ItemQueryNtf& operator= (const ItemQueryNtf& src)
	{
		item = src.item;

		return *this;
	}
	bool operator==(const ItemQueryNtf& src) const
	{
		if (item != src.item)
		{
			return false;
		}

		return true;
	}
	bool operator != (const ItemQueryNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(ItemQueryNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_item_handler(m_data.item, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_item_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                return &m_item_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)memberCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_item_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        ItemQueryNtf& m_data;
        ItemData::Handler m_item_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.Writer().Key(u8"item", sizeof(u8"item") - 1);
		item.ToJson(json_data);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        ItemQueryNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct PetQueryNtf:Protocol<PetQueryNtf>
{
	PetData                   pet; //宠物数据
	bool EnCode(NetEnCode& net_data)
	{
		pet.EnCode(net_data);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		pet.EnCode(net_data);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!pet.DeCode(net_data))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!pet.DeCode(net_data))
			return false;

		return true;
	}
	void Reset(void)
	{
		pet.Reset();

	}
	PetQueryNtf& operator= (const PetQueryNtf& src)
	{
		pet = src.pet;

		return *this;
	}
	bool operator==(const PetQueryNtf& src) const
	{
		if (pet != src.pet)
		{
			return false;
		}

		return true;
	}
	bool operator != (const PetQueryNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(PetQueryNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_pet_handler(m_data.pet, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_pet_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                return &m_pet_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)memberCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_pet_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        PetQueryNtf& m_data;
        PetData::Handler m_pet_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.Writer().Key(u8"pet", sizeof(u8"pet") - 1);
		pet.ToJson(json_data);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        PetQueryNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct ContactInfoNtf:Protocol<ContactInfoNtf>
{
	ContactInfoData           data; //联系人信息
	bool EnCode(NetEnCode& net_data)
	{
		data.EnCode(net_data);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		data.EnCode(net_data);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!data.DeCode(net_data))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!data.DeCode(net_data))
			return false;

		return true;
	}
	void Reset(void)
	{
		data.Reset();

	}
	ContactInfoNtf& operator= (const ContactInfoNtf& src)
	{
		data = src.data;

		return *this;
	}
	bool operator==(const ContactInfoNtf& src) const
	{
		if (data != src.data)
		{
			return false;
		}

		return true;
	}
	bool operator != (const ContactInfoNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(ContactInfoNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_data_handler(m_data.data, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_data_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                return &m_data_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)memberCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_data_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        ContactInfoNtf& m_data;
        ContactInfoData::Handler m_data_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.Writer().Key(u8"data", sizeof(u8"data") - 1);
		data.ToJson(json_data);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        ContactInfoNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct MailListNtf:Protocol<MailListNtf>
{
	DataArray<MailHeadData, unsigned char> mails; //邮件标题列表
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddArray(mails);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddArray(mails);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if(!net_data.DelArray(mails))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if(!net_data.DelArray(mails))
			return false;

		return true;
	}
	void Reset(void)
	{
		mails.clear();

	}
	MailListNtf& operator= (const MailListNtf& src)
	{
		mails = src.mails;

		return *this;
	}
	bool operator==(const MailListNtf& src) const
	{
		if (mails != src.mails)
		{
			return false;
		}

		return true;
	}
	bool operator != (const MailListNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(MailListNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_mails_handler(m_data.mails, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_mails_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                return &m_mails_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)elementCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_mails_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        MailListNtf& m_data;
        DataArrayHandler<MailHeadData, unsigned char, MailHeadData::Handler> m_mails_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.Writer().Key(u8"mails", sizeof(u8"mails") - 1);
		json_data.AddArray(mails);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        MailListNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct AddMailNtf:Protocol<AddMailNtf>
{
	MailHeadData              mail; //邮件标题
	bool EnCode(NetEnCode& net_data)
	{
		mail.EnCode(net_data);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		mail.EnCode(net_data);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!mail.DeCode(net_data))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!mail.DeCode(net_data))
			return false;

		return true;
	}
	void Reset(void)
	{
		mail.Reset();

	}
	AddMailNtf& operator= (const AddMailNtf& src)
	{
		mail = src.mail;

		return *this;
	}
	bool operator==(const AddMailNtf& src) const
	{
		if (mail != src.mail)
		{
			return false;
		}

		return true;
	}
	bool operator != (const AddMailNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(AddMailNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_mail_handler(m_data.mail, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_mail_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                return &m_mail_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)memberCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_mail_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        AddMailNtf& m_data;
        MailHeadData::Handler m_mail_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.Writer().Key(u8"mail", sizeof(u8"mail") - 1);
		mail.ToJson(json_data);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        AddMailNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct DelMailNtf:Protocol<DelMailNtf>
{
	unsigned long long        mail_guid; //邮件GUID
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(mail_guid);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(mail_guid);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(mail_guid))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(mail_guid))
			return false;

		return true;
	}
	void Reset(void)
	{
		mail_guid = 0;

	}
	DelMailNtf& operator= (const DelMailNtf& src)
	{
		mail_guid = src.mail_guid;

		return *this;
	}
	bool operator==(const DelMailNtf& src) const
	{
		if (mail_guid != src.mail_guid)
		{
			return false;
		}

		return true;
	}
	bool operator != (const DelMailNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(DelMailNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.mail_guid, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        DelMailNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"mail_guid", mail_guid);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        DelMailNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct MailBodyNtf:Protocol<MailBodyNtf>
{
	unsigned long long        mail_guid; //邮件GUID
	MailBodyData              mail; //邮件内容
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(mail_guid);

		mail.EnCode(net_data);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(mail_guid);

		mail.EnCode(net_data);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(mail_guid))
			return false;

		if (!mail.DeCode(net_data))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(mail_guid))
			return false;

		if (!mail.DeCode(net_data))
			return false;

		return true;
	}
	void Reset(void)
	{
		mail_guid = 0;

		mail.Reset();

	}
	MailBodyNtf& operator= (const MailBodyNtf& src)
	{
		mail_guid = src.mail_guid;

		mail = src.mail;

		return *this;
	}
	bool operator==(const MailBodyNtf& src) const
	{
		if (mail_guid != src.mail_guid)
		{
			return false;
		}

		if (mail != src.mail)
		{
			return false;
		}

		return true;
	}
	bool operator != (const MailBodyNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(MailBodyNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_mail_handler(m_data.mail, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_mail_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.mail_guid, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            switch (m_state)
            {
            case 1:
            {
                m_assigned_bitset.set(m_state);
                return &m_mail_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)memberCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_mail_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        MailBodyNtf& m_data;
        MailBodyData::Handler m_mail_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"mail_guid", mail_guid);

		json_data.Writer().Key(u8"mail", sizeof(u8"mail") - 1);
		mail.ToJson(json_data);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        MailBodyNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct UpdateMailBodyNtf:Protocol<UpdateMailBodyNtf>
{
	unsigned long long        mail_guid; //邮件GUID
	MailBodyData              mail; //邮件内容
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(mail_guid);

		mail.EnCode(net_data);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(mail_guid);

		mail.EnCode(net_data);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(mail_guid))
			return false;

		if (!mail.DeCode(net_data))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(mail_guid))
			return false;

		if (!mail.DeCode(net_data))
			return false;

		return true;
	}
	void Reset(void)
	{
		mail_guid = 0;

		mail.Reset();

	}
	UpdateMailBodyNtf& operator= (const UpdateMailBodyNtf& src)
	{
		mail_guid = src.mail_guid;

		mail = src.mail;

		return *this;
	}
	bool operator==(const UpdateMailBodyNtf& src) const
	{
		if (mail_guid != src.mail_guid)
		{
			return false;
		}

		if (mail != src.mail)
		{
			return false;
		}

		return true;
	}
	bool operator != (const UpdateMailBodyNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(UpdateMailBodyNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_mail_handler(m_data.mail, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_mail_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.mail_guid, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            switch (m_state)
            {
            case 1:
            {
                m_assigned_bitset.set(m_state);
                return &m_mail_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)memberCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_mail_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        UpdateMailBodyNtf& m_data;
        MailBodyData::Handler m_mail_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"mail_guid", mail_guid);

		json_data.Writer().Key(u8"mail", sizeof(u8"mail") - 1);
		mail.ToJson(json_data);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        UpdateMailBodyNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct UpdateMailHeadNtf:Protocol<UpdateMailHeadNtf>
{
	unsigned long long        mail_guid; //邮件GUID
	MailHeadData              mail; //邮件标题
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(mail_guid);

		mail.EnCode(net_data);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(mail_guid);

		mail.EnCode(net_data);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(mail_guid))
			return false;

		if (!mail.DeCode(net_data))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(mail_guid))
			return false;

		if (!mail.DeCode(net_data))
			return false;

		return true;
	}
	void Reset(void)
	{
		mail_guid = 0;

		mail.Reset();

	}
	UpdateMailHeadNtf& operator= (const UpdateMailHeadNtf& src)
	{
		mail_guid = src.mail_guid;

		mail = src.mail;

		return *this;
	}
	bool operator==(const UpdateMailHeadNtf& src) const
	{
		if (mail_guid != src.mail_guid)
		{
			return false;
		}

		if (mail != src.mail)
		{
			return false;
		}

		return true;
	}
	bool operator != (const UpdateMailHeadNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(UpdateMailHeadNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_mail_handler(m_data.mail, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_mail_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.mail_guid, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            switch (m_state)
            {
            case 1:
            {
                m_assigned_bitset.set(m_state);
                return &m_mail_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)memberCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_mail_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        UpdateMailHeadNtf& m_data;
        MailHeadData::Handler m_mail_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"mail_guid", mail_guid);

		json_data.Writer().Key(u8"mail", sizeof(u8"mail") - 1);
		mail.ToJson(json_data);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        UpdateMailHeadNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct RanklistReq:Protocol<RanklistReq>
{
	int                       type; //榜单类型 
	unsigned short            begin; //获取排行开始
	unsigned short            end; //获取排行结束
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(type);

		net_data.AddIntegral(begin);

		net_data.AddIntegral(end);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(type);

		net_data.AddIntegral(begin);

		net_data.AddIntegral(end);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(type))
			return false;

		if (!net_data.DelIntegral(begin))
			return false;

		if (!net_data.DelIntegral(end))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(type))
			return false;

		if (!net_data.DelIntegral(begin))
			return false;

		if (!net_data.DelIntegral(end))
			return false;

		return true;
	}
	void Reset(void)
	{
		type = 0;

		begin = 0;

		end = 0;

	}
	RanklistReq& operator= (const RanklistReq& src)
	{
		type = src.type;

		begin = src.begin;

		end = src.end;

		return *this;
	}
	bool operator==(const RanklistReq& src) const
	{
		if (type != src.type)
		{
			return false;
		}

		if (begin != src.begin)
		{
			return false;
		}

		if (end != src.end)
		{
			return false;
		}

		return true;
	}
	bool operator != (const RanklistReq& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(RanklistReq& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.type, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.begin, str, length);
            }
            break;
            case 2:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.end, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        RanklistReq& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<3> m_assigned_bitset;

        static const std::bitset<3> template_assigned_bitset;
        static const char* m_key_list[3];
        static const char* m_alias_list[3];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"type", type);

		json_data.AddIntegral(u8"begin", begin);

		json_data.AddIntegral(u8"end", end);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        RanklistReq::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct RanklistAck:Protocol<RanklistAck>
{
	int                       type; //榜单类型 1=等级总榜 2=等级人榜 3=等级魔榜 4=等级仙榜 5=等级鬼榜 6=等级龙榜 7=装备总榜 8=装备人榜 9=装备魔榜 10=装备仙榜 11=装备鬼榜 12=装备龙榜 13=帮派榜 14=宠物榜 15=水陆大会榜 16=竞技场榜 16以后是其他自定义榜
	unsigned short            total; //排行榜总数
	unsigned short            begin; //获取排行开始
	unsigned short            end; //获取排行结束
	DataArray<RanklistData, unsigned short> data; //排行榜内容
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(type);

		net_data.AddIntegral(total);

		net_data.AddIntegral(begin);

		net_data.AddIntegral(end);

		net_data.AddArray(data);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(type);

		net_data.AddIntegral(total);

		net_data.AddIntegral(begin);

		net_data.AddIntegral(end);

		net_data.AddArray(data);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(type))
			return false;

		if (!net_data.DelIntegral(total))
			return false;

		if (!net_data.DelIntegral(begin))
			return false;

		if (!net_data.DelIntegral(end))
			return false;

		if(!net_data.DelArray(data))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(type))
			return false;

		if (!net_data.DelIntegral(total))
			return false;

		if (!net_data.DelIntegral(begin))
			return false;

		if (!net_data.DelIntegral(end))
			return false;

		if(!net_data.DelArray(data))
			return false;

		return true;
	}
	void Reset(void)
	{
		type = 0;

		total = 0;

		begin = 0;

		end = 0;

		data.clear();

	}
	RanklistAck& operator= (const RanklistAck& src)
	{
		type = src.type;

		total = src.total;

		begin = src.begin;

		end = src.end;

		data = src.data;

		return *this;
	}
	bool operator==(const RanklistAck& src) const
	{
		if (type != src.type)
		{
			return false;
		}

		if (total != src.total)
		{
			return false;
		}

		if (begin != src.begin)
		{
			return false;
		}

		if (end != src.end)
		{
			return false;
		}

		if (data != src.data)
		{
			return false;
		}

		return true;
	}
	bool operator != (const RanklistAck& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(RanklistAck& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_data_handler(m_data.data, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_data_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.type, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.total, str, length);
            }
            break;
            case 2:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.begin, str, length);
            }
            break;
            case 3:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.end, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            switch (m_state)
            {
            case 4:
            {
                m_assigned_bitset.set(m_state);
                return &m_data_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)elementCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_data_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        RanklistAck& m_data;
        DataArrayHandler<RanklistData, unsigned short, RanklistData::Handler> m_data_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<5> m_assigned_bitset;

        static const std::bitset<5> template_assigned_bitset;
        static const char* m_key_list[5];
        static const char* m_alias_list[5];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"type", type);

		json_data.AddIntegral(u8"total", total);

		json_data.AddIntegral(u8"begin", begin);

		json_data.AddIntegral(u8"end", end);

		json_data.Writer().Key(u8"data", sizeof(u8"data") - 1);
		json_data.AddArray(data);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        RanklistAck::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct GetRankReq:Protocol<GetRankReq>
{
	int                       type; //榜单类型 
	unsigned long long        guid; //玩家宠物或者其他榜单上对象的GUID
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(type);

		net_data.AddIntegral(guid);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(type);

		net_data.AddIntegral(guid);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(type))
			return false;

		if (!net_data.DelIntegral(guid))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(type))
			return false;

		if (!net_data.DelIntegral(guid))
			return false;

		return true;
	}
	void Reset(void)
	{
		type = 0;

		guid = 0;

	}
	GetRankReq& operator= (const GetRankReq& src)
	{
		type = src.type;

		guid = src.guid;

		return *this;
	}
	bool operator==(const GetRankReq& src) const
	{
		if (type != src.type)
		{
			return false;
		}

		if (guid != src.guid)
		{
			return false;
		}

		return true;
	}
	bool operator != (const GetRankReq& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(GetRankReq& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.type, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.guid, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        GetRankReq& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"type", type);

		json_data.AddIntegral(u8"guid", guid);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        GetRankReq::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct GetRankAck:Protocol<GetRankAck>
{
	int                       type; //榜单类型 
	unsigned short            rank; //玩家宠物或者其他榜单上排名数, 0=未上榜
	RanklistData              data; //榜单数据
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(type);

		net_data.AddIntegral(rank);

		data.EnCode(net_data);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(type);

		net_data.AddIntegral(rank);

		data.EnCode(net_data);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(type))
			return false;

		if (!net_data.DelIntegral(rank))
			return false;

		if (!data.DeCode(net_data))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(type))
			return false;

		if (!net_data.DelIntegral(rank))
			return false;

		if (!data.DeCode(net_data))
			return false;

		return true;
	}
	void Reset(void)
	{
		type = 0;

		rank = 0;

		data.Reset();

	}
	GetRankAck& operator= (const GetRankAck& src)
	{
		type = src.type;

		rank = src.rank;

		data = src.data;

		return *this;
	}
	bool operator==(const GetRankAck& src) const
	{
		if (type != src.type)
		{
			return false;
		}

		if (rank != src.rank)
		{
			return false;
		}

		if (data != src.data)
		{
			return false;
		}

		return true;
	}
	bool operator != (const GetRankAck& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(GetRankAck& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_data_handler(m_data.data, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_data_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.type, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.rank, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            switch (m_state)
            {
            case 2:
            {
                m_assigned_bitset.set(m_state);
                return &m_data_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)memberCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_data_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        GetRankAck& m_data;
        RanklistData::Handler m_data_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<3> m_assigned_bitset;

        static const std::bitset<3> template_assigned_bitset;
        static const char* m_key_list[3];
        static const char* m_alias_list[3];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"type", type);

		json_data.AddIntegral(u8"rank", rank);

		json_data.Writer().Key(u8"data", sizeof(u8"data") - 1);
		data.ToJson(json_data);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        GetRankAck::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct TitleContainerNtf:Protocol<TitleContainerNtf>
{
	DataArray<TitleData, unsigned short> titles; //称号列表
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddArray(titles);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddArray(titles);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if(!net_data.DelArray(titles))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if(!net_data.DelArray(titles))
			return false;

		return true;
	}
	void Reset(void)
	{
		titles.clear();

	}
	TitleContainerNtf& operator= (const TitleContainerNtf& src)
	{
		titles = src.titles;

		return *this;
	}
	bool operator==(const TitleContainerNtf& src) const
	{
		if (titles != src.titles)
		{
			return false;
		}

		return true;
	}
	bool operator != (const TitleContainerNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(TitleContainerNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_titles_handler(m_data.titles, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_titles_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                return &m_titles_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)elementCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_titles_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        TitleContainerNtf& m_data;
        DataArrayHandler<TitleData, unsigned short, TitleData::Handler> m_titles_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.Writer().Key(u8"titles", sizeof(u8"titles") - 1);
		json_data.AddArray(titles);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        TitleContainerNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct TitleAddNtf:Protocol<TitleAddNtf>
{
	TitleData                 title; //称号数据
	bool EnCode(NetEnCode& net_data)
	{
		title.EnCode(net_data);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		title.EnCode(net_data);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!title.DeCode(net_data))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!title.DeCode(net_data))
			return false;

		return true;
	}
	void Reset(void)
	{
		title.Reset();

	}
	TitleAddNtf& operator= (const TitleAddNtf& src)
	{
		title = src.title;

		return *this;
	}
	bool operator==(const TitleAddNtf& src) const
	{
		if (title != src.title)
		{
			return false;
		}

		return true;
	}
	bool operator != (const TitleAddNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(TitleAddNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_title_handler(m_data.title, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_title_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                return &m_title_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)memberCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_title_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        TitleAddNtf& m_data;
        TitleData::Handler m_title_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.Writer().Key(u8"title", sizeof(u8"title") - 1);
		title.ToJson(json_data);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        TitleAddNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct TitleDelNtf:Protocol<TitleDelNtf>
{
	unsigned short            title_id; //称号ID
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(title_id);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(title_id);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(title_id))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(title_id))
			return false;

		return true;
	}
	void Reset(void)
	{
		title_id = 0;

	}
	TitleDelNtf& operator= (const TitleDelNtf& src)
	{
		title_id = src.title_id;

		return *this;
	}
	bool operator==(const TitleDelNtf& src) const
	{
		if (title_id != src.title_id)
		{
			return false;
		}

		return true;
	}
	bool operator != (const TitleDelNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(TitleDelNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.title_id, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        TitleDelNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"title_id", title_id);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        TitleDelNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct AgentKeyReq:Protocol<AgentKeyReq>
{
	bool EnCode(NetEnCode& net_data)
	{
		(void)(net_data);
		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		(void)(net_data);
		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		(void)(net_data);
		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		(void)(net_data);
		return true;
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(AgentKeyReq& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            return true;
        }
    private:
        AgentKeyReq& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        AgentKeyReq::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct AgentKeyAck:Protocol<AgentKeyAck>
{
	DataArray<unsigned char, unsigned char> key; //代理Key值
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddArray(key);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddArray(key);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if(!net_data.DelArray(key))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if(!net_data.DelArray(key))
			return false;

		return true;
	}
	void Reset(void)
	{
		key.clear();

	}
	AgentKeyAck& operator= (const AgentKeyAck& src)
	{
		key = src.key;

		return *this;
	}
	bool operator==(const AgentKeyAck& src) const
	{
		if (key != src.key)
		{
			return false;
		}

		return true;
	}
	bool operator != (const AgentKeyAck& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(AgentKeyAck& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                DataArrayHandler<unsigned char, unsigned char> handler(m_data.key, this);
                handler.String(str, length, copy);
            }
            break;
            default:
            {
                m_state = 0;
                return true;
            }
            }

            m_state++;
            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        AgentKeyAck& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.Writer().Key(u8"key", sizeof(u8"key") - 1);
		json_data.AddArray(key);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        AgentKeyAck::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct HeadMsgNtf:Protocol<HeadMsgNtf>
{
	unsigned long long        guid; //对象GUID
	DataArray<unsigned char, unsigned short> msg; //消息内容
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(guid);

		net_data.AddArray(msg);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(guid);

		net_data.AddArray(msg);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if(!net_data.DelArray(msg))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if(!net_data.DelArray(msg))
			return false;

		return true;
	}
	void Reset(void)
	{
		guid = 0;

		msg.clear();

	}
	HeadMsgNtf& operator= (const HeadMsgNtf& src)
	{
		guid = src.guid;

		msg = src.msg;

		return *this;
	}
	bool operator==(const HeadMsgNtf& src) const
	{
		if (guid != src.guid)
		{
			return false;
		}

		if (msg != src.msg)
		{
			return false;
		}

		return true;
	}
	bool operator != (const HeadMsgNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(HeadMsgNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.guid, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 1:
            {
                m_assigned_bitset.set(m_state);
                DataArrayHandler<unsigned char, unsigned short> handler(m_data.msg, this);
                handler.String(str, length, copy);
            }
            break;
            default:
            {
                m_state = 0;
                return true;
            }
            }

            m_state++;
            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        HeadMsgNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"guid", guid);

		json_data.Writer().Key(u8"msg", sizeof(u8"msg") - 1);
		json_data.AddArray(msg);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        HeadMsgNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct AutoContainerNtf:Protocol<AutoContainerNtf>
{
	unsigned long long        guid; //自己或自己的宠物
	unsigned char             is_auto; //是否开启了自动(宠物跟随主人自动)
	unsigned short            auto_skill; //自动战斗技能
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(guid);

		net_data.AddIntegral(is_auto);

		net_data.AddIntegral(auto_skill);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(guid);

		net_data.AddIntegral(is_auto);

		net_data.AddIntegral(auto_skill);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!net_data.DelIntegral(is_auto))
			return false;

		if (!net_data.DelIntegral(auto_skill))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!net_data.DelIntegral(is_auto))
			return false;

		if (!net_data.DelIntegral(auto_skill))
			return false;

		return true;
	}
	void Reset(void)
	{
		guid = 0;

		is_auto = 0;

		auto_skill = 0;

	}
	AutoContainerNtf& operator= (const AutoContainerNtf& src)
	{
		guid = src.guid;

		is_auto = src.is_auto;

		auto_skill = src.auto_skill;

		return *this;
	}
	bool operator==(const AutoContainerNtf& src) const
	{
		if (guid != src.guid)
		{
			return false;
		}

		if (is_auto != src.is_auto)
		{
			return false;
		}

		if (auto_skill != src.auto_skill)
		{
			return false;
		}

		return true;
	}
	bool operator != (const AutoContainerNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(AutoContainerNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.guid, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.is_auto, str, length);
            }
            break;
            case 2:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.auto_skill, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        AutoContainerNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<3> m_assigned_bitset;

        static const std::bitset<3> template_assigned_bitset;
        static const char* m_key_list[3];
        static const char* m_alias_list[3];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"guid", guid);

		json_data.AddIntegral(u8"is_auto", is_auto);

		json_data.AddIntegral(u8"auto_skill", auto_skill);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        AutoContainerNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct PlayerQueryNtf:Protocol<PlayerQueryNtf>
{
	PlayerBrief               brief; //玩家简略数据
	bool EnCode(NetEnCode& net_data)
	{
		brief.EnCode(net_data);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		brief.EnCode(net_data);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!brief.DeCode(net_data))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!brief.DeCode(net_data))
			return false;

		return true;
	}
	void Reset(void)
	{
		brief.Reset();

	}
	PlayerQueryNtf& operator= (const PlayerQueryNtf& src)
	{
		brief = src.brief;

		return *this;
	}
	bool operator==(const PlayerQueryNtf& src) const
	{
		if (brief != src.brief)
		{
			return false;
		}

		return true;
	}
	bool operator != (const PlayerQueryNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(PlayerQueryNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_brief_handler(m_data.brief, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_brief_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                return &m_brief_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)memberCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_brief_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        PlayerQueryNtf& m_data;
        PlayerBrief::Handler m_brief_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.Writer().Key(u8"brief", sizeof(u8"brief") - 1);
		brief.ToJson(json_data);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        PlayerQueryNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct UseAllItem:Protocol<UseAllItem>
{
	unsigned long long        item_guid; //物品guid
	unsigned short            item_amount; //物品数量
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(item_guid);

		net_data.AddIntegral(item_amount);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(item_guid);

		net_data.AddIntegral(item_amount);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(item_guid))
			return false;

		if (!net_data.DelIntegral(item_amount))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(item_guid))
			return false;

		if (!net_data.DelIntegral(item_amount))
			return false;

		return true;
	}
	void Reset(void)
	{
		item_guid = 0;

		item_amount = 0;

	}
	UseAllItem& operator= (const UseAllItem& src)
	{
		item_guid = src.item_guid;

		item_amount = src.item_amount;

		return *this;
	}
	bool operator==(const UseAllItem& src) const
	{
		if (item_guid != src.item_guid)
		{
			return false;
		}

		if (item_amount != src.item_amount)
		{
			return false;
		}

		return true;
	}
	bool operator != (const UseAllItem& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(UseAllItem& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.item_guid, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.item_amount, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        UseAllItem& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"item_guid", item_guid);

		json_data.AddIntegral(u8"item_amount", item_amount);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        UseAllItem::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct GuardContainerNtf:Protocol<GuardContainerNtf>
{
	DataArray<GuardData, unsigned short> guards; //侍从
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddArray(guards);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddArray(guards);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if(!net_data.DelArray(guards))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if(!net_data.DelArray(guards))
			return false;

		return true;
	}
	void Reset(void)
	{
		guards.clear();

	}
	GuardContainerNtf& operator= (const GuardContainerNtf& src)
	{
		guards = src.guards;

		return *this;
	}
	bool operator==(const GuardContainerNtf& src) const
	{
		if (guards != src.guards)
		{
			return false;
		}

		return true;
	}
	bool operator != (const GuardContainerNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(GuardContainerNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_guards_handler(m_data.guards, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_guards_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                return &m_guards_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)elementCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_guards_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        GuardContainerNtf& m_data;
        DataArrayHandler<GuardData, unsigned short, GuardData::Handler> m_guards_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.Writer().Key(u8"guards", sizeof(u8"guards") - 1);
		json_data.AddArray(guards);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        GuardContainerNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct GuardAddNtf:Protocol<GuardAddNtf>
{
	GuardData                 guard; //侍从列表
	bool EnCode(NetEnCode& net_data)
	{
		guard.EnCode(net_data);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		guard.EnCode(net_data);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!guard.DeCode(net_data))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!guard.DeCode(net_data))
			return false;

		return true;
	}
	void Reset(void)
	{
		guard.Reset();

	}
	GuardAddNtf& operator= (const GuardAddNtf& src)
	{
		guard = src.guard;

		return *this;
	}
	bool operator==(const GuardAddNtf& src) const
	{
		if (guard != src.guard)
		{
			return false;
		}

		return true;
	}
	bool operator != (const GuardAddNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(GuardAddNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_guard_handler(m_data.guard, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_guard_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                return &m_guard_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)memberCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_guard_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        GuardAddNtf& m_data;
        GuardData::Handler m_guard_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.Writer().Key(u8"guard", sizeof(u8"guard") - 1);
		guard.ToJson(json_data);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        GuardAddNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct SetGuardLineup:Protocol<SetGuardLineup>
{
	unsigned long long        guid; //侍从guid
	unsigned char             lineup; //上阵：0 下阵，1 上阵
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(guid);

		net_data.AddIntegral(lineup);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(guid);

		net_data.AddIntegral(lineup);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!net_data.DelIntegral(lineup))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!net_data.DelIntegral(lineup))
			return false;

		return true;
	}
	void Reset(void)
	{
		guid = 0;

		lineup = 0;

	}
	SetGuardLineup& operator= (const SetGuardLineup& src)
	{
		guid = src.guid;

		lineup = src.lineup;

		return *this;
	}
	bool operator==(const SetGuardLineup& src) const
	{
		if (guid != src.guid)
		{
			return false;
		}

		if (lineup != src.lineup)
		{
			return false;
		}

		return true;
	}
	bool operator != (const SetGuardLineup& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(SetGuardLineup& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.guid, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.lineup, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        SetGuardLineup& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"guid", guid);

		json_data.AddIntegral(u8"lineup", lineup);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        SetGuardLineup::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct PetNewAddNtf:Protocol<PetNewAddNtf>
{
	unsigned long long        pet_guid; //宠物GUID
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(pet_guid);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(pet_guid);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(pet_guid))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(pet_guid))
			return false;

		return true;
	}
	void Reset(void)
	{
		pet_guid = 0;

	}
	PetNewAddNtf& operator= (const PetNewAddNtf& src)
	{
		pet_guid = src.pet_guid;

		return *this;
	}
	bool operator==(const PetNewAddNtf& src) const
	{
		if (pet_guid != src.pet_guid)
		{
			return false;
		}

		return true;
	}
	bool operator != (const PetNewAddNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(PetNewAddNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.pet_guid, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        PetNewAddNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"pet_guid", pet_guid);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        PetNewAddNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct TeamPlatformNtf:Protocol<TeamPlatformNtf>
{
	DataArray<TeamBriefData, unsigned short> teams; //队伍列表
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddArray(teams);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddArray(teams);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if(!net_data.DelArray(teams))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if(!net_data.DelArray(teams))
			return false;

		return true;
	}
	void Reset(void)
	{
		teams.clear();

	}
	TeamPlatformNtf& operator= (const TeamPlatformNtf& src)
	{
		teams = src.teams;

		return *this;
	}
	bool operator==(const TeamPlatformNtf& src) const
	{
		if (teams != src.teams)
		{
			return false;
		}

		return true;
	}
	bool operator != (const TeamPlatformNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(TeamPlatformNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_teams_handler(m_data.teams, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_teams_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                return &m_teams_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)elementCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_teams_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        TeamPlatformNtf& m_data;
        DataArrayHandler<TeamBriefData, unsigned short, TeamBriefData::Handler> m_teams_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.Writer().Key(u8"teams", sizeof(u8"teams") - 1);
		json_data.AddArray(teams);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        TeamPlatformNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct TeamApplicantsNtf:Protocol<TeamApplicantsNtf>
{
	unsigned long long        team_guid; //队伍GUID
	DataArray<TeamApplicantData, unsigned short> applicants; //申请人列表
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(team_guid);

		net_data.AddArray(applicants);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(team_guid);

		net_data.AddArray(applicants);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(team_guid))
			return false;

		if(!net_data.DelArray(applicants))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(team_guid))
			return false;

		if(!net_data.DelArray(applicants))
			return false;

		return true;
	}
	void Reset(void)
	{
		team_guid = 0;

		applicants.clear();

	}
	TeamApplicantsNtf& operator= (const TeamApplicantsNtf& src)
	{
		team_guid = src.team_guid;

		applicants = src.applicants;

		return *this;
	}
	bool operator==(const TeamApplicantsNtf& src) const
	{
		if (team_guid != src.team_guid)
		{
			return false;
		}

		if (applicants != src.applicants)
		{
			return false;
		}

		return true;
	}
	bool operator != (const TeamApplicantsNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(TeamApplicantsNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_applicants_handler(m_data.applicants, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_applicants_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.team_guid, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            switch (m_state)
            {
            case 1:
            {
                m_assigned_bitset.set(m_state);
                return &m_applicants_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)elementCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_applicants_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        TeamApplicantsNtf& m_data;
        DataArrayHandler<TeamApplicantData, unsigned short, TeamApplicantData::Handler> m_applicants_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"team_guid", team_guid);

		json_data.Writer().Key(u8"applicants", sizeof(u8"applicants") - 1);
		json_data.AddArray(applicants);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        TeamApplicantsNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct TeamOperationNtf:Protocol<TeamOperationNtf>
{
	unsigned short            type; //操作通知
	int                       errcode; //0=成功, 其他表示错误码
	char                      errmsg[256]; //错误码不为0时表示 错误消息
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(type);

		net_data.AddIntegral(errcode);

		net_data.AddString(errmsg, sizeof(errmsg));

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(type);

		net_data.AddIntegral(errcode);

		net_data.AddString(errmsg, sizeof(errmsg));

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(type))
			return false;

		if (!net_data.DelIntegral(errcode))
			return false;

		if (!net_data.DelString(errmsg, sizeof(errmsg)))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(type))
			return false;

		if (!net_data.DelIntegral(errcode))
			return false;

		if (!net_data.DelString(errmsg, sizeof(errmsg)))
			return false;

		return true;
	}
	void Reset(void)
	{
		type = 0;

		errcode = 0;

		errmsg[0] = 0;

	}
	TeamOperationNtf& operator= (const TeamOperationNtf& src)
	{
		type = src.type;

		errcode = src.errcode;

		{
			size_t str_len = strnlen(src.errmsg, sizeof(errmsg) - 1);
			memcpy(errmsg, src.errmsg, str_len + 1);
			errmsg[sizeof(errmsg) - 1] = 0;
		}

		return *this;
	}
	bool operator==(const TeamOperationNtf& src) const
	{
		if (type != src.type)
		{
			return false;
		}

		if (errcode != src.errcode)
		{
			return false;
		}

		if (strncmp(errmsg, src.errmsg, sizeof(errmsg)-1))
		{
			return false;
		}

		return true;
	}
	bool operator != (const TeamOperationNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(TeamOperationNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.type, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.errcode, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 2:
            {
                m_assigned_bitset.set(m_state);
                JsonDelString(m_data.errmsg, str, length);
            }
            break;
            default:
            {
                m_state = 0;
                return true;
            }
            }

            m_state++;
            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        TeamOperationNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<3> m_assigned_bitset;

        static const std::bitset<3> template_assigned_bitset;
        static const char* m_key_list[3];
        static const char* m_alias_list[3];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"type", type);

		json_data.AddIntegral(u8"errcode", errcode);

		json_data.AddString(u8"errmsg", errmsg, sizeof(errmsg));

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        TeamOperationNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct TeamTargetNtf:Protocol<TeamTargetNtf>
{
	unsigned long long        team_guid; //队伍GUID
	unsigned short            target; //目标ID
	unsigned short            permission; //1=开启队友招人权限 0=关闭
	unsigned short            min_require_level; //最低要求等级
	unsigned short            max_require_level; //最高要求等级
	unsigned long long        leader_guid; //队长GUID
	unsigned short            min_require_reinc; //最低要求转生次数
	unsigned short            max_require_reinc; //最高要求转生次数
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(team_guid);

		net_data.AddIntegral(target);

		net_data.AddIntegral(permission);

		net_data.AddIntegral(min_require_level);

		net_data.AddIntegral(max_require_level);

		net_data.AddIntegral(leader_guid);

		net_data.AddIntegral(min_require_reinc);

		net_data.AddIntegral(max_require_reinc);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(team_guid);

		net_data.AddIntegral(target);

		net_data.AddIntegral(permission);

		net_data.AddIntegral(min_require_level);

		net_data.AddIntegral(max_require_level);

		net_data.AddIntegral(leader_guid);

		net_data.AddIntegral(min_require_reinc);

		net_data.AddIntegral(max_require_reinc);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(team_guid))
			return false;

		if (!net_data.DelIntegral(target))
			return false;

		if (!net_data.DelIntegral(permission))
			return false;

		if (!net_data.DelIntegral(min_require_level))
			return false;

		if (!net_data.DelIntegral(max_require_level))
			return false;

		if (!net_data.DelIntegral(leader_guid))
			return false;

		if (!net_data.DelIntegral(min_require_reinc))
			return false;

		if (!net_data.DelIntegral(max_require_reinc))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(team_guid))
			return false;

		if (!net_data.DelIntegral(target))
			return false;

		if (!net_data.DelIntegral(permission))
			return false;

		if (!net_data.DelIntegral(min_require_level))
			return false;

		if (!net_data.DelIntegral(max_require_level))
			return false;

		if (!net_data.DelIntegral(leader_guid))
			return false;

		if (!net_data.DelIntegral(min_require_reinc))
			return false;

		if (!net_data.DelIntegral(max_require_reinc))
			return false;

		return true;
	}
	void Reset(void)
	{
		team_guid = 0;

		target = 0;

		permission = 0;

		min_require_level = 0;

		max_require_level = 0;

		leader_guid = 0;

		min_require_reinc = 0;

		max_require_reinc = 0;

	}
	TeamTargetNtf& operator= (const TeamTargetNtf& src)
	{
		team_guid = src.team_guid;

		target = src.target;

		permission = src.permission;

		min_require_level = src.min_require_level;

		max_require_level = src.max_require_level;

		leader_guid = src.leader_guid;

		min_require_reinc = src.min_require_reinc;

		max_require_reinc = src.max_require_reinc;

		return *this;
	}
	bool operator==(const TeamTargetNtf& src) const
	{
		if (team_guid != src.team_guid)
		{
			return false;
		}

		if (target != src.target)
		{
			return false;
		}

		if (permission != src.permission)
		{
			return false;
		}

		if (min_require_level != src.min_require_level)
		{
			return false;
		}

		if (max_require_level != src.max_require_level)
		{
			return false;
		}

		if (leader_guid != src.leader_guid)
		{
			return false;
		}

		if (min_require_reinc != src.min_require_reinc)
		{
			return false;
		}

		if (max_require_reinc != src.max_require_reinc)
		{
			return false;
		}

		return true;
	}
	bool operator != (const TeamTargetNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(TeamTargetNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.team_guid, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.target, str, length);
            }
            break;
            case 2:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.permission, str, length);
            }
            break;
            case 3:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.min_require_level, str, length);
            }
            break;
            case 4:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.max_require_level, str, length);
            }
            break;
            case 5:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.leader_guid, str, length);
            }
            break;
            case 6:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.min_require_reinc, str, length);
            }
            break;
            case 7:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.max_require_reinc, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        TeamTargetNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<8> m_assigned_bitset;

        static const std::bitset<8> template_assigned_bitset;
        static const char* m_key_list[8];
        static const char* m_alias_list[8];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"team_guid", team_guid);

		json_data.AddIntegral(u8"target", target);

		json_data.AddIntegral(u8"permission", permission);

		json_data.AddIntegral(u8"min_require_level", min_require_level);

		json_data.AddIntegral(u8"max_require_level", max_require_level);

		json_data.AddIntegral(u8"leader_guid", leader_guid);

		json_data.AddIntegral(u8"min_require_reinc", min_require_reinc);

		json_data.AddIntegral(u8"max_require_reinc", max_require_reinc);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        TeamTargetNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct ChangedNameNtf:Protocol<ChangedNameNtf>
{
	unsigned long long        guid; //对象 guid
	char                      name[256]; //玩家名字
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(guid);

		net_data.AddString(name, sizeof(name));

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(guid);

		net_data.AddString(name, sizeof(name));

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!net_data.DelString(name, sizeof(name)))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!net_data.DelString(name, sizeof(name)))
			return false;

		return true;
	}
	void Reset(void)
	{
		guid = 0;

		name[0] = 0;

	}
	ChangedNameNtf& operator= (const ChangedNameNtf& src)
	{
		guid = src.guid;

		{
			size_t str_len = strnlen(src.name, sizeof(name) - 1);
			memcpy(name, src.name, str_len + 1);
			name[sizeof(name) - 1] = 0;
		}

		return *this;
	}
	bool operator==(const ChangedNameNtf& src) const
	{
		if (guid != src.guid)
		{
			return false;
		}

		if (strncmp(name, src.name, sizeof(name)-1))
		{
			return false;
		}

		return true;
	}
	bool operator != (const ChangedNameNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(ChangedNameNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.guid, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelString(m_data.name, str, length);
            }
            break;
            default:
            {
                m_state = 0;
                return true;
            }
            }

            m_state++;
            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        ChangedNameNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"guid", guid);

		json_data.AddString(u8"name", name, sizeof(name));

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        ChangedNameNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct CustomDataNtf:Protocol<CustomDataNtf>
{
	unsigned long long        guid; //玩家guid
	CustomData                custom; //自定义数据
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(guid);

		custom.EnCode(net_data);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(guid);

		custom.EnCode(net_data);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!custom.DeCode(net_data))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!custom.DeCode(net_data))
			return false;

		return true;
	}
	void Reset(void)
	{
		guid = 0;

		custom.Reset();

	}
	CustomDataNtf& operator= (const CustomDataNtf& src)
	{
		guid = src.guid;

		custom = src.custom;

		return *this;
	}
	bool operator==(const CustomDataNtf& src) const
	{
		if (guid != src.guid)
		{
			return false;
		}

		if (custom != src.custom)
		{
			return false;
		}

		return true;
	}
	bool operator != (const CustomDataNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(CustomDataNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_custom_handler(m_data.custom, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_custom_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.guid, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            switch (m_state)
            {
            case 1:
            {
                m_assigned_bitset.set(m_state);
                return &m_custom_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)memberCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_custom_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        CustomDataNtf& m_data;
        CustomData::Handler m_custom_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"guid", guid);

		json_data.Writer().Key(u8"custom", sizeof(u8"custom") - 1);
		custom.ToJson(json_data);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        CustomDataNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct SpeedCheckNtf:Protocol<SpeedCheckNtf>
{
	unsigned char             type; //1=加速 2=超时 3=异常
	unsigned char             pct; //加速百分比
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(type);

		net_data.AddIntegral(pct);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(type);

		net_data.AddIntegral(pct);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(type))
			return false;

		if (!net_data.DelIntegral(pct))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(type))
			return false;

		if (!net_data.DelIntegral(pct))
			return false;

		return true;
	}
	void Reset(void)
	{
		type = 0;

		pct = 0;

	}
	SpeedCheckNtf& operator= (const SpeedCheckNtf& src)
	{
		type = src.type;

		pct = src.pct;

		return *this;
	}
	bool operator==(const SpeedCheckNtf& src) const
	{
		if (type != src.type)
		{
			return false;
		}

		if (pct != src.pct)
		{
			return false;
		}

		return true;
	}
	bool operator != (const SpeedCheckNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(SpeedCheckNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.type, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.pct, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        SpeedCheckNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"type", type);

		json_data.AddIntegral(u8"pct", pct);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        SpeedCheckNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct ConsoleMsgNtf:Protocol<ConsoleMsgNtf>
{
	DataArray<unsigned char, unsigned short> msg; //控制台消息
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddArray(msg);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddArray(msg);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if(!net_data.DelArray(msg))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if(!net_data.DelArray(msg))
			return false;

		return true;
	}
	void Reset(void)
	{
		msg.clear();

	}
	ConsoleMsgNtf& operator= (const ConsoleMsgNtf& src)
	{
		msg = src.msg;

		return *this;
	}
	bool operator==(const ConsoleMsgNtf& src) const
	{
		if (msg != src.msg)
		{
			return false;
		}

		return true;
	}
	bool operator != (const ConsoleMsgNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(ConsoleMsgNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                DataArrayHandler<unsigned char, unsigned short> handler(m_data.msg, this);
                handler.String(str, length, copy);
            }
            break;
            default:
            {
                m_state = 0;
                return true;
            }
            }

            m_state++;
            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        ConsoleMsgNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.Writer().Key(u8"msg", sizeof(u8"msg") - 1);
		json_data.AddArray(msg);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        ConsoleMsgNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct PetSwapNtf:Protocol<PetSwapNtf>
{
	unsigned short            container_type; //pet容器类型
	unsigned long long        pet_guid1; //宠物1guid
	unsigned long long        pet_guid2; //宠物2guid
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(container_type);

		net_data.AddIntegral(pet_guid1);

		net_data.AddIntegral(pet_guid2);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(container_type);

		net_data.AddIntegral(pet_guid1);

		net_data.AddIntegral(pet_guid2);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(container_type))
			return false;

		if (!net_data.DelIntegral(pet_guid1))
			return false;

		if (!net_data.DelIntegral(pet_guid2))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(container_type))
			return false;

		if (!net_data.DelIntegral(pet_guid1))
			return false;

		if (!net_data.DelIntegral(pet_guid2))
			return false;

		return true;
	}
	void Reset(void)
	{
		container_type = 0;

		pet_guid1 = 0;

		pet_guid2 = 0;

	}
	PetSwapNtf& operator= (const PetSwapNtf& src)
	{
		container_type = src.container_type;

		pet_guid1 = src.pet_guid1;

		pet_guid2 = src.pet_guid2;

		return *this;
	}
	bool operator==(const PetSwapNtf& src) const
	{
		if (container_type != src.container_type)
		{
			return false;
		}

		if (pet_guid1 != src.pet_guid1)
		{
			return false;
		}

		if (pet_guid2 != src.pet_guid2)
		{
			return false;
		}

		return true;
	}
	bool operator != (const PetSwapNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(PetSwapNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.container_type, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.pet_guid1, str, length);
            }
            break;
            case 2:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.pet_guid2, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        PetSwapNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<3> m_assigned_bitset;

        static const std::bitset<3> template_assigned_bitset;
        static const char* m_key_list[3];
        static const char* m_alias_list[3];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"container_type", container_type);

		json_data.AddIntegral(u8"pet_guid1", pet_guid1);

		json_data.AddIntegral(u8"pet_guid2", pet_guid2);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        PetSwapNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct GuardDestroyNtf:Protocol<GuardDestroyNtf>
{
	unsigned long long        guid; //侍从GUID
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(guid);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(guid);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(guid))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(guid))
			return false;

		return true;
	}
	void Reset(void)
	{
		guid = 0;

	}
	GuardDestroyNtf& operator= (const GuardDestroyNtf& src)
	{
		guid = src.guid;

		return *this;
	}
	bool operator==(const GuardDestroyNtf& src) const
	{
		if (guid != src.guid)
		{
			return false;
		}

		return true;
	}
	bool operator != (const GuardDestroyNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(GuardDestroyNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.guid, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        GuardDestroyNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"guid", guid);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        GuardDestroyNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct ActivateGuard:Protocol<ActivateGuard>
{
	unsigned int              guard_id; //侍从ID
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(guard_id);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(guard_id);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(guard_id))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(guard_id))
			return false;

		return true;
	}
	void Reset(void)
	{
		guard_id = 0;

	}
	ActivateGuard& operator= (const ActivateGuard& src)
	{
		guard_id = src.guard_id;

		return *this;
	}
	bool operator==(const ActivateGuard& src) const
	{
		if (guard_id != src.guard_id)
		{
			return false;
		}

		return true;
	}
	bool operator != (const ActivateGuard& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(ActivateGuard& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.guard_id, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        ActivateGuard& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"guard_id", guard_id);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        ActivateGuard::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct ReleaseGuard:Protocol<ReleaseGuard>
{
	unsigned long long        guard_guid; //侍从GUID
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(guard_guid);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(guard_guid);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(guard_guid))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(guard_guid))
			return false;

		return true;
	}
	void Reset(void)
	{
		guard_guid = 0;

	}
	ReleaseGuard& operator= (const ReleaseGuard& src)
	{
		guard_guid = src.guard_guid;

		return *this;
	}
	bool operator==(const ReleaseGuard& src) const
	{
		if (guard_guid != src.guard_guid)
		{
			return false;
		}

		return true;
	}
	bool operator != (const ReleaseGuard& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(ReleaseGuard& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.guard_guid, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        ReleaseGuard& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"guard_guid", guard_guid);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        ReleaseGuard::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct TeamMemberSwapNtf:Protocol<TeamMemberSwapNtf>
{
	unsigned long long        member_guid1; //队伍成员GUID1
	unsigned long long        member_guid2; //队伍成员GUID2
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(member_guid1);

		net_data.AddIntegral(member_guid2);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(member_guid1);

		net_data.AddIntegral(member_guid2);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(member_guid1))
			return false;

		if (!net_data.DelIntegral(member_guid2))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(member_guid1))
			return false;

		if (!net_data.DelIntegral(member_guid2))
			return false;

		return true;
	}
	void Reset(void)
	{
		member_guid1 = 0;

		member_guid2 = 0;

	}
	TeamMemberSwapNtf& operator= (const TeamMemberSwapNtf& src)
	{
		member_guid1 = src.member_guid1;

		member_guid2 = src.member_guid2;

		return *this;
	}
	bool operator==(const TeamMemberSwapNtf& src) const
	{
		if (member_guid1 != src.member_guid1)
		{
			return false;
		}

		if (member_guid2 != src.member_guid2)
		{
			return false;
		}

		return true;
	}
	bool operator != (const TeamMemberSwapNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(TeamMemberSwapNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.member_guid1, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.member_guid2, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        TeamMemberSwapNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"member_guid1", member_guid1);

		json_data.AddIntegral(u8"member_guid2", member_guid2);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        TeamMemberSwapNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct GuardSwapNtf:Protocol<GuardSwapNtf>
{
	unsigned long long        guard_guid1; //侍从1guid
	unsigned long long        guard_guid2; //侍从2guid
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(guard_guid1);

		net_data.AddIntegral(guard_guid2);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(guard_guid1);

		net_data.AddIntegral(guard_guid2);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(guard_guid1))
			return false;

		if (!net_data.DelIntegral(guard_guid2))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(guard_guid1))
			return false;

		if (!net_data.DelIntegral(guard_guid2))
			return false;

		return true;
	}
	void Reset(void)
	{
		guard_guid1 = 0;

		guard_guid2 = 0;

	}
	GuardSwapNtf& operator= (const GuardSwapNtf& src)
	{
		guard_guid1 = src.guard_guid1;

		guard_guid2 = src.guard_guid2;

		return *this;
	}
	bool operator==(const GuardSwapNtf& src) const
	{
		if (guard_guid1 != src.guard_guid1)
		{
			return false;
		}

		if (guard_guid2 != src.guard_guid2)
		{
			return false;
		}

		return true;
	}
	bool operator != (const GuardSwapNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(GuardSwapNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.guard_guid1, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.guard_guid2, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        GuardSwapNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"guard_guid1", guard_guid1);

		json_data.AddIntegral(u8"guard_guid2", guard_guid2);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        GuardSwapNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct PetReplaceNtf:Protocol<PetReplaceNtf>
{
	unsigned short            container_type; //pet容器类型
	unsigned long long        dst_pet_guid; //目标宠物GUID
	PetData                   src_pet; //替换宠物
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(container_type);

		net_data.AddIntegral(dst_pet_guid);

		src_pet.EnCode(net_data);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(container_type);

		net_data.AddIntegral(dst_pet_guid);

		src_pet.EnCode(net_data);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(container_type))
			return false;

		if (!net_data.DelIntegral(dst_pet_guid))
			return false;

		if (!src_pet.DeCode(net_data))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(container_type))
			return false;

		if (!net_data.DelIntegral(dst_pet_guid))
			return false;

		if (!src_pet.DeCode(net_data))
			return false;

		return true;
	}
	void Reset(void)
	{
		container_type = 0;

		dst_pet_guid = 0;

		src_pet.Reset();

	}
	PetReplaceNtf& operator= (const PetReplaceNtf& src)
	{
		container_type = src.container_type;

		dst_pet_guid = src.dst_pet_guid;

		src_pet = src.src_pet;

		return *this;
	}
	bool operator==(const PetReplaceNtf& src) const
	{
		if (container_type != src.container_type)
		{
			return false;
		}

		if (dst_pet_guid != src.dst_pet_guid)
		{
			return false;
		}

		if (src_pet != src.src_pet)
		{
			return false;
		}

		return true;
	}
	bool operator != (const PetReplaceNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(PetReplaceNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_src_pet_handler(m_data.src_pet, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_src_pet_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.container_type, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.dst_pet_guid, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            switch (m_state)
            {
            case 2:
            {
                m_assigned_bitset.set(m_state);
                return &m_src_pet_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)memberCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_src_pet_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        PetReplaceNtf& m_data;
        PetData::Handler m_src_pet_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<3> m_assigned_bitset;

        static const std::bitset<3> template_assigned_bitset;
        static const char* m_key_list[3];
        static const char* m_alias_list[3];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"container_type", container_type);

		json_data.AddIntegral(u8"dst_pet_guid", dst_pet_guid);

		json_data.Writer().Key(u8"src_pet", sizeof(u8"src_pet") - 1);
		src_pet.ToJson(json_data);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        PetReplaceNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct GuardAppearNtf:Protocol<GuardAppearNtf>
{
	unsigned long long        guid; //侍从guid
	char                      name[256]; //侍从名字
	unsigned short            x; //x坐标
	unsigned short            y; //y坐标
	DataArray<AttrData, unsigned short> attrs; //属性数据
	DataArray<BuffData, unsigned char> buffs; //buff数据
	CustomData                custom; //自定义数据
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(guid);

		net_data.AddString(name, sizeof(name));

		net_data.AddIntegral(x);

		net_data.AddIntegral(y);

		net_data.AddArray(attrs);

		net_data.AddArray(buffs);

		custom.EnCode(net_data);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(guid);

		net_data.AddString(name, sizeof(name));

		net_data.AddIntegral(x);

		net_data.AddIntegral(y);

		net_data.AddArray(attrs);

		net_data.AddArray(buffs);

		custom.EnCode(net_data);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!net_data.DelString(name, sizeof(name)))
			return false;

		if (!net_data.DelIntegral(x))
			return false;

		if (!net_data.DelIntegral(y))
			return false;

		if(!net_data.DelArray(attrs))
			return false;

		if(!net_data.DelArray(buffs))
			return false;

		if (!custom.DeCode(net_data))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(guid))
			return false;

		if (!net_data.DelString(name, sizeof(name)))
			return false;

		if (!net_data.DelIntegral(x))
			return false;

		if (!net_data.DelIntegral(y))
			return false;

		if(!net_data.DelArray(attrs))
			return false;

		if(!net_data.DelArray(buffs))
			return false;

		if (!custom.DeCode(net_data))
			return false;

		return true;
	}
	void Reset(void)
	{
		guid = 0;

		name[0] = 0;

		x = 0;

		y = 0;

		attrs.clear();

		buffs.clear();

		custom.Reset();

	}
	GuardAppearNtf& operator= (const GuardAppearNtf& src)
	{
		guid = src.guid;

		{
			size_t str_len = strnlen(src.name, sizeof(name) - 1);
			memcpy(name, src.name, str_len + 1);
			name[sizeof(name) - 1] = 0;
		}

		x = src.x;

		y = src.y;

		attrs = src.attrs;

		buffs = src.buffs;

		custom = src.custom;

		return *this;
	}
	bool operator==(const GuardAppearNtf& src) const
	{
		if (guid != src.guid)
		{
			return false;
		}

		if (strncmp(name, src.name, sizeof(name)-1))
		{
			return false;
		}

		if (x != src.x)
		{
			return false;
		}

		if (y != src.y)
		{
			return false;
		}

		if (attrs != src.attrs)
		{
			return false;
		}

		if (buffs != src.buffs)
		{
			return false;
		}

		if (custom != src.custom)
		{
			return false;
		}

		return true;
	}
	bool operator != (const GuardAppearNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(GuardAppearNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_custom_handler(m_data.custom, this),
            m_attrs_handler(m_data.attrs, this),
            m_buffs_handler(m_data.buffs, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_custom_handler.ResetState();
            m_attrs_handler.ResetState();
            m_buffs_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.guid, str, length);
            }
            break;
            case 2:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.x, str, length);
            }
            break;
            case 3:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.y, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelString(m_data.name, str, length);
            }
            break;
            default:
            {
                m_state = 0;
                return true;
            }
            }

            m_state++;
            return true;
        }

        JsonHandler* StartObject() override
        {
            switch (m_state)
            {
            case 6:
            {
                m_assigned_bitset.set(m_state);
                return &m_custom_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)memberCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        JsonHandler* StartArray() override
        {
            switch (m_state)
            {
            case 4:
            {
                m_assigned_bitset.set(m_state);
                return &m_attrs_handler;
            }
            break;
            case 5:
            {
                m_assigned_bitset.set(m_state);
                return &m_buffs_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)elementCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_attrs_handler.IsAllMemberSet())
            {
                return false;
            }

            if (!m_buffs_handler.IsAllMemberSet())
            {
                return false;
            }

            if (!m_custom_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        GuardAppearNtf& m_data;
        CustomData::Handler m_custom_handler;
        DataArrayHandler<AttrData, unsigned short, AttrData::Handler> m_attrs_handler;
        DataArrayHandler<BuffData, unsigned char, BuffData::Handler> m_buffs_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<7> m_assigned_bitset;

        static const std::bitset<7> template_assigned_bitset;
        static const char* m_key_list[7];
        static const char* m_alias_list[7];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"guid", guid);

		json_data.AddString(u8"name", name, sizeof(name));

		json_data.AddIntegral(u8"x", x);

		json_data.AddIntegral(u8"y", y);

		json_data.Writer().Key(u8"attrs", sizeof(u8"attrs") - 1);
		json_data.AddArray(attrs);

		json_data.Writer().Key(u8"buffs", sizeof(u8"buffs") - 1);
		json_data.AddArray(buffs);

		json_data.Writer().Key(u8"custom", sizeof(u8"custom") - 1);
		custom.ToJson(json_data);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        GuardAppearNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct InstructionContainerNtf:Protocol<InstructionContainerNtf>
{
	InstructionData           datas; //指令数据
	bool EnCode(NetEnCode& net_data)
	{
		datas.EnCode(net_data);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		datas.EnCode(net_data);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!datas.DeCode(net_data))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!datas.DeCode(net_data))
			return false;

		return true;
	}
	void Reset(void)
	{
		datas.Reset();

	}
	InstructionContainerNtf& operator= (const InstructionContainerNtf& src)
	{
		datas = src.datas;

		return *this;
	}
	bool operator==(const InstructionContainerNtf& src) const
	{
		if (datas != src.datas)
		{
			return false;
		}

		return true;
	}
	bool operator != (const InstructionContainerNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(InstructionContainerNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_datas_handler(m_data.datas, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_datas_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                return &m_datas_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)memberCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_datas_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        InstructionContainerNtf& m_data;
        InstructionData::Handler m_datas_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.Writer().Key(u8"datas", sizeof(u8"datas") - 1);
		datas.ToJson(json_data);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        InstructionContainerNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct InstructionAddReq:Protocol<InstructionAddReq>
{
	unsigned char             type; //指令类型
	char                      content[32]; //指令内容
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(type);

		net_data.AddString(content, sizeof(content));

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(type);

		net_data.AddString(content, sizeof(content));

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(type))
			return false;

		if (!net_data.DelString(content, sizeof(content)))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(type))
			return false;

		if (!net_data.DelString(content, sizeof(content)))
			return false;

		return true;
	}
	void Reset(void)
	{
		type = 0;

		content[0] = 0;

	}
	InstructionAddReq& operator= (const InstructionAddReq& src)
	{
		type = src.type;

		{
			size_t str_len = strnlen(src.content, sizeof(content) - 1);
			memcpy(content, src.content, str_len + 1);
			content[sizeof(content) - 1] = 0;
		}

		return *this;
	}
	bool operator==(const InstructionAddReq& src) const
	{
		if (type != src.type)
		{
			return false;
		}

		if (strncmp(content, src.content, sizeof(content)-1))
		{
			return false;
		}

		return true;
	}
	bool operator != (const InstructionAddReq& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(InstructionAddReq& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.type, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelString(m_data.content, str, length);
            }
            break;
            default:
            {
                m_state = 0;
                return true;
            }
            }

            m_state++;
            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        InstructionAddReq& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"type", type);

		json_data.AddString(u8"content", content, sizeof(content));

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        InstructionAddReq::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct InstructionAddAck:Protocol<InstructionAddAck>
{
	unsigned char             type; //指令类型
	char                      content[32]; //指令内容
	int                       errcode; //0=成功, 其他表示错误码
	char                      errmsg[256]; //错误码不为0时表示 错误消息
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(type);

		net_data.AddString(content, sizeof(content));

		net_data.AddIntegral(errcode);

		net_data.AddString(errmsg, sizeof(errmsg));

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(type);

		net_data.AddString(content, sizeof(content));

		net_data.AddIntegral(errcode);

		net_data.AddString(errmsg, sizeof(errmsg));

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(type))
			return false;

		if (!net_data.DelString(content, sizeof(content)))
			return false;

		if (!net_data.DelIntegral(errcode))
			return false;

		if (!net_data.DelString(errmsg, sizeof(errmsg)))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(type))
			return false;

		if (!net_data.DelString(content, sizeof(content)))
			return false;

		if (!net_data.DelIntegral(errcode))
			return false;

		if (!net_data.DelString(errmsg, sizeof(errmsg)))
			return false;

		return true;
	}
	void Reset(void)
	{
		type = 0;

		content[0] = 0;

		errcode = 0;

		errmsg[0] = 0;

	}
	InstructionAddAck& operator= (const InstructionAddAck& src)
	{
		type = src.type;

		{
			size_t str_len = strnlen(src.content, sizeof(content) - 1);
			memcpy(content, src.content, str_len + 1);
			content[sizeof(content) - 1] = 0;
		}

		errcode = src.errcode;

		{
			size_t str_len = strnlen(src.errmsg, sizeof(errmsg) - 1);
			memcpy(errmsg, src.errmsg, str_len + 1);
			errmsg[sizeof(errmsg) - 1] = 0;
		}

		return *this;
	}
	bool operator==(const InstructionAddAck& src) const
	{
		if (type != src.type)
		{
			return false;
		}

		if (strncmp(content, src.content, sizeof(content)-1))
		{
			return false;
		}

		if (errcode != src.errcode)
		{
			return false;
		}

		if (strncmp(errmsg, src.errmsg, sizeof(errmsg)-1))
		{
			return false;
		}

		return true;
	}
	bool operator != (const InstructionAddAck& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(InstructionAddAck& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.type, str, length);
            }
            break;
            case 2:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.errcode, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelString(m_data.content, str, length);
            }
            break;
            case 3:
            {
                m_assigned_bitset.set(m_state);
                JsonDelString(m_data.errmsg, str, length);
            }
            break;
            default:
            {
                m_state = 0;
                return true;
            }
            }

            m_state++;
            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        InstructionAddAck& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<4> m_assigned_bitset;

        static const std::bitset<4> template_assigned_bitset;
        static const char* m_key_list[4];
        static const char* m_alias_list[4];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"type", type);

		json_data.AddString(u8"content", content, sizeof(content));

		json_data.AddIntegral(u8"errcode", errcode);

		json_data.AddString(u8"errmsg", errmsg, sizeof(errmsg));

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        InstructionAddAck::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct InstructionDeleteReq:Protocol<InstructionDeleteReq>
{
	unsigned char             type; //指令类型
	unsigned char             index; //指令索引
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(type);

		net_data.AddIntegral(index);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(type);

		net_data.AddIntegral(index);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(type))
			return false;

		if (!net_data.DelIntegral(index))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(type))
			return false;

		if (!net_data.DelIntegral(index))
			return false;

		return true;
	}
	void Reset(void)
	{
		type = 0;

		index = 0;

	}
	InstructionDeleteReq& operator= (const InstructionDeleteReq& src)
	{
		type = src.type;

		index = src.index;

		return *this;
	}
	bool operator==(const InstructionDeleteReq& src) const
	{
		if (type != src.type)
		{
			return false;
		}

		if (index != src.index)
		{
			return false;
		}

		return true;
	}
	bool operator != (const InstructionDeleteReq& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(InstructionDeleteReq& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.type, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.index, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        InstructionDeleteReq& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"type", type);

		json_data.AddIntegral(u8"index", index);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        InstructionDeleteReq::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct InstructionDeleteAck:Protocol<InstructionDeleteAck>
{
	unsigned char             type; //指令类型
	unsigned char             index; //指令索引
	int                       errcode; //0=成功, 其他表示错误码
	char                      errmsg[256]; //错误码不为0时表示 错误消息
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(type);

		net_data.AddIntegral(index);

		net_data.AddIntegral(errcode);

		net_data.AddString(errmsg, sizeof(errmsg));

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(type);

		net_data.AddIntegral(index);

		net_data.AddIntegral(errcode);

		net_data.AddString(errmsg, sizeof(errmsg));

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(type))
			return false;

		if (!net_data.DelIntegral(index))
			return false;

		if (!net_data.DelIntegral(errcode))
			return false;

		if (!net_data.DelString(errmsg, sizeof(errmsg)))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(type))
			return false;

		if (!net_data.DelIntegral(index))
			return false;

		if (!net_data.DelIntegral(errcode))
			return false;

		if (!net_data.DelString(errmsg, sizeof(errmsg)))
			return false;

		return true;
	}
	void Reset(void)
	{
		type = 0;

		index = 0;

		errcode = 0;

		errmsg[0] = 0;

	}
	InstructionDeleteAck& operator= (const InstructionDeleteAck& src)
	{
		type = src.type;

		index = src.index;

		errcode = src.errcode;

		{
			size_t str_len = strnlen(src.errmsg, sizeof(errmsg) - 1);
			memcpy(errmsg, src.errmsg, str_len + 1);
			errmsg[sizeof(errmsg) - 1] = 0;
		}

		return *this;
	}
	bool operator==(const InstructionDeleteAck& src) const
	{
		if (type != src.type)
		{
			return false;
		}

		if (index != src.index)
		{
			return false;
		}

		if (errcode != src.errcode)
		{
			return false;
		}

		if (strncmp(errmsg, src.errmsg, sizeof(errmsg)-1))
		{
			return false;
		}

		return true;
	}
	bool operator != (const InstructionDeleteAck& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(InstructionDeleteAck& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.type, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.index, str, length);
            }
            break;
            case 2:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.errcode, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 3:
            {
                m_assigned_bitset.set(m_state);
                JsonDelString(m_data.errmsg, str, length);
            }
            break;
            default:
            {
                m_state = 0;
                return true;
            }
            }

            m_state++;
            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        InstructionDeleteAck& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<4> m_assigned_bitset;

        static const std::bitset<4> template_assigned_bitset;
        static const char* m_key_list[4];
        static const char* m_alias_list[4];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"type", type);

		json_data.AddIntegral(u8"index", index);

		json_data.AddIntegral(u8"errcode", errcode);

		json_data.AddString(u8"errmsg", errmsg, sizeof(errmsg));

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        InstructionDeleteAck::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct InstructionModfityReq:Protocol<InstructionModfityReq>
{
	unsigned char             type; //指令类型
	unsigned char             index; //指令索引
	char                      content[32]; //指令内容
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(type);

		net_data.AddIntegral(index);

		net_data.AddString(content, sizeof(content));

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(type);

		net_data.AddIntegral(index);

		net_data.AddString(content, sizeof(content));

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(type))
			return false;

		if (!net_data.DelIntegral(index))
			return false;

		if (!net_data.DelString(content, sizeof(content)))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(type))
			return false;

		if (!net_data.DelIntegral(index))
			return false;

		if (!net_data.DelString(content, sizeof(content)))
			return false;

		return true;
	}
	void Reset(void)
	{
		type = 0;

		index = 0;

		content[0] = 0;

	}
	InstructionModfityReq& operator= (const InstructionModfityReq& src)
	{
		type = src.type;

		index = src.index;

		{
			size_t str_len = strnlen(src.content, sizeof(content) - 1);
			memcpy(content, src.content, str_len + 1);
			content[sizeof(content) - 1] = 0;
		}

		return *this;
	}
	bool operator==(const InstructionModfityReq& src) const
	{
		if (type != src.type)
		{
			return false;
		}

		if (index != src.index)
		{
			return false;
		}

		if (strncmp(content, src.content, sizeof(content)-1))
		{
			return false;
		}

		return true;
	}
	bool operator != (const InstructionModfityReq& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(InstructionModfityReq& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.type, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.index, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 2:
            {
                m_assigned_bitset.set(m_state);
                JsonDelString(m_data.content, str, length);
            }
            break;
            default:
            {
                m_state = 0;
                return true;
            }
            }

            m_state++;
            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        InstructionModfityReq& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<3> m_assigned_bitset;

        static const std::bitset<3> template_assigned_bitset;
        static const char* m_key_list[3];
        static const char* m_alias_list[3];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"type", type);

		json_data.AddIntegral(u8"index", index);

		json_data.AddString(u8"content", content, sizeof(content));

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        InstructionModfityReq::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct InstructionModifyAck:Protocol<InstructionModifyAck>
{
	unsigned char             type; //指令类型
	unsigned char             index; //指令索引
	char                      content[32]; //指令内容
	int                       errcode; //0=成功, 其他表示错误码
	char                      errmsg[256]; //错误码不为0时表示 错误消息
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(type);

		net_data.AddIntegral(index);

		net_data.AddString(content, sizeof(content));

		net_data.AddIntegral(errcode);

		net_data.AddString(errmsg, sizeof(errmsg));

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(type);

		net_data.AddIntegral(index);

		net_data.AddString(content, sizeof(content));

		net_data.AddIntegral(errcode);

		net_data.AddString(errmsg, sizeof(errmsg));

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(type))
			return false;

		if (!net_data.DelIntegral(index))
			return false;

		if (!net_data.DelString(content, sizeof(content)))
			return false;

		if (!net_data.DelIntegral(errcode))
			return false;

		if (!net_data.DelString(errmsg, sizeof(errmsg)))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(type))
			return false;

		if (!net_data.DelIntegral(index))
			return false;

		if (!net_data.DelString(content, sizeof(content)))
			return false;

		if (!net_data.DelIntegral(errcode))
			return false;

		if (!net_data.DelString(errmsg, sizeof(errmsg)))
			return false;

		return true;
	}
	void Reset(void)
	{
		type = 0;

		index = 0;

		content[0] = 0;

		errcode = 0;

		errmsg[0] = 0;

	}
	InstructionModifyAck& operator= (const InstructionModifyAck& src)
	{
		type = src.type;

		index = src.index;

		{
			size_t str_len = strnlen(src.content, sizeof(content) - 1);
			memcpy(content, src.content, str_len + 1);
			content[sizeof(content) - 1] = 0;
		}

		errcode = src.errcode;

		{
			size_t str_len = strnlen(src.errmsg, sizeof(errmsg) - 1);
			memcpy(errmsg, src.errmsg, str_len + 1);
			errmsg[sizeof(errmsg) - 1] = 0;
		}

		return *this;
	}
	bool operator==(const InstructionModifyAck& src) const
	{
		if (type != src.type)
		{
			return false;
		}

		if (index != src.index)
		{
			return false;
		}

		if (strncmp(content, src.content, sizeof(content)-1))
		{
			return false;
		}

		if (errcode != src.errcode)
		{
			return false;
		}

		if (strncmp(errmsg, src.errmsg, sizeof(errmsg)-1))
		{
			return false;
		}

		return true;
	}
	bool operator != (const InstructionModifyAck& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(InstructionModifyAck& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.type, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.index, str, length);
            }
            break;
            case 3:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.errcode, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 2:
            {
                m_assigned_bitset.set(m_state);
                JsonDelString(m_data.content, str, length);
            }
            break;
            case 4:
            {
                m_assigned_bitset.set(m_state);
                JsonDelString(m_data.errmsg, str, length);
            }
            break;
            default:
            {
                m_state = 0;
                return true;
            }
            }

            m_state++;
            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        InstructionModifyAck& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<5> m_assigned_bitset;

        static const std::bitset<5> template_assigned_bitset;
        static const char* m_key_list[5];
        static const char* m_alias_list[5];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"type", type);

		json_data.AddIntegral(u8"index", index);

		json_data.AddString(u8"content", content, sizeof(content));

		json_data.AddIntegral(u8"errcode", errcode);

		json_data.AddString(u8"errmsg", errmsg, sizeof(errmsg));

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        InstructionModifyAck::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct InstructionDefaultReq:Protocol<InstructionDefaultReq>
{
	unsigned char             type; //指令类型
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(type);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(type);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(type))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(type))
			return false;

		return true;
	}
	void Reset(void)
	{
		type = 0;

	}
	InstructionDefaultReq& operator= (const InstructionDefaultReq& src)
	{
		type = src.type;

		return *this;
	}
	bool operator==(const InstructionDefaultReq& src) const
	{
		if (type != src.type)
		{
			return false;
		}

		return true;
	}
	bool operator != (const InstructionDefaultReq& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(InstructionDefaultReq& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.type, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        InstructionDefaultReq& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"type", type);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        InstructionDefaultReq::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct InstructionDefaultAck:Protocol<InstructionDefaultAck>
{
	unsigned char             type; //指令类型
	DataArray<InstructionBasic, unsigned char> datas; //恢复后的指令
	int                       errcode; //0=成功, 其他表示错误码
	char                      errmsg[256]; //错误码不为0时表示 错误消息
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(type);

		net_data.AddArray(datas);

		net_data.AddIntegral(errcode);

		net_data.AddString(errmsg, sizeof(errmsg));

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(type);

		net_data.AddArray(datas);

		net_data.AddIntegral(errcode);

		net_data.AddString(errmsg, sizeof(errmsg));

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(type))
			return false;

		if(!net_data.DelArray(datas))
			return false;

		if (!net_data.DelIntegral(errcode))
			return false;

		if (!net_data.DelString(errmsg, sizeof(errmsg)))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(type))
			return false;

		if(!net_data.DelArray(datas))
			return false;

		if (!net_data.DelIntegral(errcode))
			return false;

		if (!net_data.DelString(errmsg, sizeof(errmsg)))
			return false;

		return true;
	}
	void Reset(void)
	{
		type = 0;

		datas.clear();

		errcode = 0;

		errmsg[0] = 0;

	}
	InstructionDefaultAck& operator= (const InstructionDefaultAck& src)
	{
		type = src.type;

		datas = src.datas;

		errcode = src.errcode;

		{
			size_t str_len = strnlen(src.errmsg, sizeof(errmsg) - 1);
			memcpy(errmsg, src.errmsg, str_len + 1);
			errmsg[sizeof(errmsg) - 1] = 0;
		}

		return *this;
	}
	bool operator==(const InstructionDefaultAck& src) const
	{
		if (type != src.type)
		{
			return false;
		}

		if (datas != src.datas)
		{
			return false;
		}

		if (errcode != src.errcode)
		{
			return false;
		}

		if (strncmp(errmsg, src.errmsg, sizeof(errmsg)-1))
		{
			return false;
		}

		return true;
	}
	bool operator != (const InstructionDefaultAck& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(InstructionDefaultAck& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_datas_handler(m_data.datas, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_datas_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.type, str, length);
            }
            break;
            case 2:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.errcode, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 3:
            {
                m_assigned_bitset.set(m_state);
                JsonDelString(m_data.errmsg, str, length);
            }
            break;
            default:
            {
                m_state = 0;
                return true;
            }
            }

            m_state++;
            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            switch (m_state)
            {
            case 1:
            {
                m_assigned_bitset.set(m_state);
                return &m_datas_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)elementCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_datas_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        InstructionDefaultAck& m_data;
        DataArrayHandler<InstructionBasic, unsigned char, InstructionBasic::Handler> m_datas_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<4> m_assigned_bitset;

        static const std::bitset<4> template_assigned_bitset;
        static const char* m_key_list[4];
        static const char* m_alias_list[4];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"type", type);

		json_data.Writer().Key(u8"datas", sizeof(u8"datas") - 1);
		json_data.AddArray(datas);

		json_data.AddIntegral(u8"errcode", errcode);

		json_data.AddString(u8"errmsg", errmsg, sizeof(errmsg));

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        InstructionDefaultAck::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct InstructionAttachReq:Protocol<InstructionAttachReq>
{
	unsigned char             type; //指令类型
	unsigned char             index; //指令索引
	unsigned long long        target; //目标GUID
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(type);

		net_data.AddIntegral(index);

		net_data.AddIntegral(target);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(type);

		net_data.AddIntegral(index);

		net_data.AddIntegral(target);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(type))
			return false;

		if (!net_data.DelIntegral(index))
			return false;

		if (!net_data.DelIntegral(target))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(type))
			return false;

		if (!net_data.DelIntegral(index))
			return false;

		if (!net_data.DelIntegral(target))
			return false;

		return true;
	}
	void Reset(void)
	{
		type = 0;

		index = 0;

		target = 0;

	}
	InstructionAttachReq& operator= (const InstructionAttachReq& src)
	{
		type = src.type;

		index = src.index;

		target = src.target;

		return *this;
	}
	bool operator==(const InstructionAttachReq& src) const
	{
		if (type != src.type)
		{
			return false;
		}

		if (index != src.index)
		{
			return false;
		}

		if (target != src.target)
		{
			return false;
		}

		return true;
	}
	bool operator != (const InstructionAttachReq& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(InstructionAttachReq& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.type, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.index, str, length);
            }
            break;
            case 2:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.target, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        InstructionAttachReq& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<3> m_assigned_bitset;

        static const std::bitset<3> template_assigned_bitset;
        static const char* m_key_list[3];
        static const char* m_alias_list[3];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"type", type);

		json_data.AddIntegral(u8"index", index);

		json_data.AddIntegral(u8"target", target);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        InstructionAttachReq::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct InstructionAttachAck:Protocol<InstructionAttachAck>
{
	unsigned char             type; //指令类型
	unsigned char             index; //指令索引
	unsigned long long        target; //目标GUID
	int                       errcode; //0=成功, 其他表示错误码
	char                      errmsg[256]; //错误码不为0时表示 错误消息
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(type);

		net_data.AddIntegral(index);

		net_data.AddIntegral(target);

		net_data.AddIntegral(errcode);

		net_data.AddString(errmsg, sizeof(errmsg));

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(type);

		net_data.AddIntegral(index);

		net_data.AddIntegral(target);

		net_data.AddIntegral(errcode);

		net_data.AddString(errmsg, sizeof(errmsg));

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(type))
			return false;

		if (!net_data.DelIntegral(index))
			return false;

		if (!net_data.DelIntegral(target))
			return false;

		if (!net_data.DelIntegral(errcode))
			return false;

		if (!net_data.DelString(errmsg, sizeof(errmsg)))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(type))
			return false;

		if (!net_data.DelIntegral(index))
			return false;

		if (!net_data.DelIntegral(target))
			return false;

		if (!net_data.DelIntegral(errcode))
			return false;

		if (!net_data.DelString(errmsg, sizeof(errmsg)))
			return false;

		return true;
	}
	void Reset(void)
	{
		type = 0;

		index = 0;

		target = 0;

		errcode = 0;

		errmsg[0] = 0;

	}
	InstructionAttachAck& operator= (const InstructionAttachAck& src)
	{
		type = src.type;

		index = src.index;

		target = src.target;

		errcode = src.errcode;

		{
			size_t str_len = strnlen(src.errmsg, sizeof(errmsg) - 1);
			memcpy(errmsg, src.errmsg, str_len + 1);
			errmsg[sizeof(errmsg) - 1] = 0;
		}

		return *this;
	}
	bool operator==(const InstructionAttachAck& src) const
	{
		if (type != src.type)
		{
			return false;
		}

		if (index != src.index)
		{
			return false;
		}

		if (target != src.target)
		{
			return false;
		}

		if (errcode != src.errcode)
		{
			return false;
		}

		if (strncmp(errmsg, src.errmsg, sizeof(errmsg)-1))
		{
			return false;
		}

		return true;
	}
	bool operator != (const InstructionAttachAck& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(InstructionAttachAck& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.type, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.index, str, length);
            }
            break;
            case 2:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.target, str, length);
            }
            break;
            case 3:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.errcode, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 4:
            {
                m_assigned_bitset.set(m_state);
                JsonDelString(m_data.errmsg, str, length);
            }
            break;
            default:
            {
                m_state = 0;
                return true;
            }
            }

            m_state++;
            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        InstructionAttachAck& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<5> m_assigned_bitset;

        static const std::bitset<5> template_assigned_bitset;
        static const char* m_key_list[5];
        static const char* m_alias_list[5];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"type", type);

		json_data.AddIntegral(u8"index", index);

		json_data.AddIntegral(u8"target", target);

		json_data.AddIntegral(u8"errcode", errcode);

		json_data.AddString(u8"errmsg", errmsg, sizeof(errmsg));

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        InstructionAttachAck::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct InstructionAttachNtf:Protocol<InstructionAttachNtf>
{
	unsigned int              fighter_id; //战斗者id
	char                      content[32]; //指令内容
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(fighter_id);

		net_data.AddString(content, sizeof(content));

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(fighter_id);

		net_data.AddString(content, sizeof(content));

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(fighter_id))
			return false;

		if (!net_data.DelString(content, sizeof(content)))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(fighter_id))
			return false;

		if (!net_data.DelString(content, sizeof(content)))
			return false;

		return true;
	}
	void Reset(void)
	{
		fighter_id = 0;

		content[0] = 0;

	}
	InstructionAttachNtf& operator= (const InstructionAttachNtf& src)
	{
		fighter_id = src.fighter_id;

		{
			size_t str_len = strnlen(src.content, sizeof(content) - 1);
			memcpy(content, src.content, str_len + 1);
			content[sizeof(content) - 1] = 0;
		}

		return *this;
	}
	bool operator==(const InstructionAttachNtf& src) const
	{
		if (fighter_id != src.fighter_id)
		{
			return false;
		}

		if (strncmp(content, src.content, sizeof(content)-1))
		{
			return false;
		}

		return true;
	}
	bool operator != (const InstructionAttachNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(InstructionAttachNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.fighter_id, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelString(m_data.content, str, length);
            }
            break;
            default:
            {
                m_state = 0;
                return true;
            }
            }

            m_state++;
            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        InstructionAttachNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"fighter_id", fighter_id);

		json_data.AddString(u8"content", content, sizeof(content));

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        InstructionAttachNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct InstructionDetachReq:Protocol<InstructionDetachReq>
{
	unsigned long long        target; //目标GUID
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(target);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(target);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(target))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(target))
			return false;

		return true;
	}
	void Reset(void)
	{
		target = 0;

	}
	InstructionDetachReq& operator= (const InstructionDetachReq& src)
	{
		target = src.target;

		return *this;
	}
	bool operator==(const InstructionDetachReq& src) const
	{
		if (target != src.target)
		{
			return false;
		}

		return true;
	}
	bool operator != (const InstructionDetachReq& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(InstructionDetachReq& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.target, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        InstructionDetachReq& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"target", target);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        InstructionDetachReq::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct InstructionDetachAck:Protocol<InstructionDetachAck>
{
	unsigned long long        target; //目标GUID
	int                       errcode; //0=成功, 其他表示错误码
	char                      errmsg[256]; //错误码不为0时表示 错误消息
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(target);

		net_data.AddIntegral(errcode);

		net_data.AddString(errmsg, sizeof(errmsg));

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(target);

		net_data.AddIntegral(errcode);

		net_data.AddString(errmsg, sizeof(errmsg));

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(target))
			return false;

		if (!net_data.DelIntegral(errcode))
			return false;

		if (!net_data.DelString(errmsg, sizeof(errmsg)))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(target))
			return false;

		if (!net_data.DelIntegral(errcode))
			return false;

		if (!net_data.DelString(errmsg, sizeof(errmsg)))
			return false;

		return true;
	}
	void Reset(void)
	{
		target = 0;

		errcode = 0;

		errmsg[0] = 0;

	}
	InstructionDetachAck& operator= (const InstructionDetachAck& src)
	{
		target = src.target;

		errcode = src.errcode;

		{
			size_t str_len = strnlen(src.errmsg, sizeof(errmsg) - 1);
			memcpy(errmsg, src.errmsg, str_len + 1);
			errmsg[sizeof(errmsg) - 1] = 0;
		}

		return *this;
	}
	bool operator==(const InstructionDetachAck& src) const
	{
		if (target != src.target)
		{
			return false;
		}

		if (errcode != src.errcode)
		{
			return false;
		}

		if (strncmp(errmsg, src.errmsg, sizeof(errmsg)-1))
		{
			return false;
		}

		return true;
	}
	bool operator != (const InstructionDetachAck& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(InstructionDetachAck& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.target, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.errcode, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 2:
            {
                m_assigned_bitset.set(m_state);
                JsonDelString(m_data.errmsg, str, length);
            }
            break;
            default:
            {
                m_state = 0;
                return true;
            }
            }

            m_state++;
            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        InstructionDetachAck& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<3> m_assigned_bitset;

        static const std::bitset<3> template_assigned_bitset;
        static const char* m_key_list[3];
        static const char* m_alias_list[3];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"target", target);

		json_data.AddIntegral(u8"errcode", errcode);

		json_data.AddString(u8"errmsg", errmsg, sizeof(errmsg));

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        InstructionDetachAck::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct InstructionDetachNtf:Protocol<InstructionDetachNtf>
{
	unsigned int              fighter_id; //战斗者id
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(fighter_id);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(fighter_id);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(fighter_id))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(fighter_id))
			return false;

		return true;
	}
	void Reset(void)
	{
		fighter_id = 0;

	}
	InstructionDetachNtf& operator= (const InstructionDetachNtf& src)
	{
		fighter_id = src.fighter_id;

		return *this;
	}
	bool operator==(const InstructionDetachNtf& src) const
	{
		if (fighter_id != src.fighter_id)
		{
			return false;
		}

		return true;
	}
	bool operator != (const InstructionDetachNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(InstructionDetachNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.fighter_id, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        InstructionDetachNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"fighter_id", fighter_id);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        InstructionDetachNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct PlayerDetailNtf:Protocol<PlayerDetailNtf>
{
	PlayerDetail              data; //玩家详细信息
	bool EnCode(NetEnCode& net_data)
	{
		data.EnCode(net_data);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		data.EnCode(net_data);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!data.DeCode(net_data))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!data.DeCode(net_data))
			return false;

		return true;
	}
	void Reset(void)
	{
		data.Reset();

	}
	PlayerDetailNtf& operator= (const PlayerDetailNtf& src)
	{
		data = src.data;

		return *this;
	}
	bool operator==(const PlayerDetailNtf& src) const
	{
		if (data != src.data)
		{
			return false;
		}

		return true;
	}
	bool operator != (const PlayerDetailNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(PlayerDetailNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_data_handler(m_data.data, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_data_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                return &m_data_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)memberCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_data_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        PlayerDetailNtf& m_data;
        PlayerDetail::Handler m_data_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.Writer().Key(u8"data", sizeof(u8"data") - 1);
		data.ToJson(json_data);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        PlayerDetailNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct MapDynBlockPtNtf:Protocol<MapDynBlockPtNtf>
{
	unsigned short            map_id; //地图id
	DataArray<Pt, unsigned short> block_pt_list; //玩家详细信息
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(map_id);

		net_data.AddArray(block_pt_list);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(map_id);

		net_data.AddArray(block_pt_list);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(map_id))
			return false;

		if(!net_data.DelArray(block_pt_list))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(map_id))
			return false;

		if(!net_data.DelArray(block_pt_list))
			return false;

		return true;
	}
	void Reset(void)
	{
		map_id = 0;

		block_pt_list.clear();

	}
	MapDynBlockPtNtf& operator= (const MapDynBlockPtNtf& src)
	{
		map_id = src.map_id;

		block_pt_list = src.block_pt_list;

		return *this;
	}
	bool operator==(const MapDynBlockPtNtf& src) const
	{
		if (map_id != src.map_id)
		{
			return false;
		}

		if (block_pt_list != src.block_pt_list)
		{
			return false;
		}

		return true;
	}
	bool operator != (const MapDynBlockPtNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(MapDynBlockPtNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_block_pt_list_handler(m_data.block_pt_list, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_block_pt_list_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.map_id, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            switch (m_state)
            {
            case 1:
            {
                m_assigned_bitset.set(m_state);
                return &m_block_pt_list_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)elementCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_block_pt_list_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        MapDynBlockPtNtf& m_data;
        DataArrayHandler<Pt, unsigned short, Pt::Handler> m_block_pt_list_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"map_id", map_id);

		json_data.Writer().Key(u8"block_pt_list", sizeof(u8"block_pt_list") - 1);
		json_data.AddArray(block_pt_list);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        MapDynBlockPtNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct GuardQueryNtf:Protocol<GuardQueryNtf>
{
	GuardData                 guard; //侍从数据
	bool EnCode(NetEnCode& net_data)
	{
		guard.EnCode(net_data);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		guard.EnCode(net_data);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!guard.DeCode(net_data))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!guard.DeCode(net_data))
			return false;

		return true;
	}
	void Reset(void)
	{
		guard.Reset();

	}
	GuardQueryNtf& operator= (const GuardQueryNtf& src)
	{
		guard = src.guard;

		return *this;
	}
	bool operator==(const GuardQueryNtf& src) const
	{
		if (guard != src.guard)
		{
			return false;
		}

		return true;
	}
	bool operator != (const GuardQueryNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(GuardQueryNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_guard_handler(m_data.guard, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_guard_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                return &m_guard_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)memberCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_guard_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        GuardQueryNtf& m_data;
        GuardData::Handler m_guard_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.Writer().Key(u8"guard", sizeof(u8"guard") - 1);
		guard.ToJson(json_data);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        GuardQueryNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct BuyBackNtfEx:Protocol<BuyBackNtfEx>
{
	unsigned long long        buy_guid; //出售物品guid
	unsigned short            buy_amount; //出售物品数量
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(buy_guid);

		net_data.AddIntegral(buy_amount);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(buy_guid);

		net_data.AddIntegral(buy_amount);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(buy_guid))
			return false;

		if (!net_data.DelIntegral(buy_amount))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(buy_guid))
			return false;

		if (!net_data.DelIntegral(buy_amount))
			return false;

		return true;
	}
	void Reset(void)
	{
		buy_guid = 0;

		buy_amount = 0;

	}
	BuyBackNtfEx& operator= (const BuyBackNtfEx& src)
	{
		buy_guid = src.buy_guid;

		buy_amount = src.buy_amount;

		return *this;
	}
	bool operator==(const BuyBackNtfEx& src) const
	{
		if (buy_guid != src.buy_guid)
		{
			return false;
		}

		if (buy_amount != src.buy_amount)
		{
			return false;
		}

		return true;
	}
	bool operator != (const BuyBackNtfEx& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(BuyBackNtfEx& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.buy_guid, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.buy_amount, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        BuyBackNtfEx& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<2> m_assigned_bitset;

        static const std::bitset<2> template_assigned_bitset;
        static const char* m_key_list[2];
        static const char* m_alias_list[2];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"buy_guid", buy_guid);

		json_data.AddIntegral(u8"buy_amount", buy_amount);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        BuyBackNtfEx::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct GuildCustomNtf:Protocol<GuildCustomNtf>
{
	unsigned long long        player_guid; //角色guid
	unsigned char             is_guild; //是否是帮派：0-帮派成员，1-帮派
	CustomData                customs; //自定义变量
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(player_guid);

		net_data.AddIntegral(is_guild);

		customs.EnCode(net_data);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(player_guid);

		net_data.AddIntegral(is_guild);

		customs.EnCode(net_data);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(player_guid))
			return false;

		if (!net_data.DelIntegral(is_guild))
			return false;

		if (!customs.DeCode(net_data))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(player_guid))
			return false;

		if (!net_data.DelIntegral(is_guild))
			return false;

		if (!customs.DeCode(net_data))
			return false;

		return true;
	}
	void Reset(void)
	{
		player_guid = 0;

		is_guild = 0;

		customs.Reset();

	}
	GuildCustomNtf& operator= (const GuildCustomNtf& src)
	{
		player_guid = src.player_guid;

		is_guild = src.is_guild;

		customs = src.customs;

		return *this;
	}
	bool operator==(const GuildCustomNtf& src) const
	{
		if (player_guid != src.player_guid)
		{
			return false;
		}

		if (is_guild != src.is_guild)
		{
			return false;
		}

		if (customs != src.customs)
		{
			return false;
		}

		return true;
	}
	bool operator != (const GuildCustomNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(GuildCustomNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_customs_handler(m_data.customs, this),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
            m_customs_handler.ResetState();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.player_guid, str, length);
            }
            break;
            case 1:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.is_guild, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            switch (m_state)
            {
            case 2:
            {
                m_assigned_bitset.set(m_state);
                return &m_customs_handler;
            }
            break;
            default:
            {
                m_default_handler.Reset(this);
                return &m_default_handler;
            }
            }

        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)memberCount;

            if (childen != &m_default_handler)
            {
                m_state++;
            }
            else
            {
                m_state = 0;
            }

            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            if (!m_customs_handler.IsAllMemberSet())
            {
                return false;
            }

            return true;
        }
    private:
        GuildCustomNtf& m_data;
        CustomData::Handler m_customs_handler;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<3> m_assigned_bitset;

        static const std::bitset<3> template_assigned_bitset;
        static const char* m_key_list[3];
        static const char* m_alias_list[3];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"player_guid", player_guid);

		json_data.AddIntegral(u8"is_guild", is_guild);

		json_data.Writer().Key(u8"customs", sizeof(u8"customs") - 1);
		customs.ToJson(json_data);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        GuildCustomNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct PreTurnRoundNtf:Protocol<PreTurnRoundNtf>
{
	unsigned short            round; //回合数
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(round);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(round);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(round))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(round))
			return false;

		return true;
	}
	void Reset(void)
	{
		round = 0;

	}
	PreTurnRoundNtf& operator= (const PreTurnRoundNtf& src)
	{
		round = src.round;

		return *this;
	}
	bool operator==(const PreTurnRoundNtf& src) const
	{
		if (round != src.round)
		{
			return false;
		}

		return true;
	}
	bool operator != (const PreTurnRoundNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(PreTurnRoundNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.round, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        PreTurnRoundNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"round", round);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        PreTurnRoundNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

struct FighterSpecialPetNtf:Protocol<FighterSpecialPetNtf>
{
	unsigned long long        special_pet; //指定主宠
	bool EnCode(NetEnCode& net_data)
	{
		net_data.AddIntegral(special_pet);

		return true;
	}
	bool EnCodeEx(NetEnCode& net_data) override
	{
		net_data.AddIntegral(special_pet);

		return true;
	}
	bool DeCode(NetDeCode& net_data)
	{
		if (!net_data.DelIntegral(special_pet))
			return false;

		return true;
	}
	bool DeCodeEx(NetDeCode& net_data) override
	{
		if (!net_data.DelIntegral(special_pet))
			return false;

		return true;
	}
	void Reset(void)
	{
		special_pet = 0;

	}
	FighterSpecialPetNtf& operator= (const FighterSpecialPetNtf& src)
	{
		special_pet = src.special_pet;

		return *this;
	}
	bool operator==(const FighterSpecialPetNtf& src) const
	{
		if (special_pet != src.special_pet)
		{
			return false;
		}

		return true;
	}
	bool operator != (const FighterSpecialPetNtf& src) const
	{
		return !(*this == src);
	}

    //===============Json===============

    class Handler :
        public JsonHandler
    {
    public:
        Handler(FighterSpecialPetNtf& data, JsonHandler* parent = nullptr)
            :
            JsonHandler(parent),
            m_data(data),
            m_default_handler(this),
            m_state(0) { (void)m_data; }

        ~Handler(){}

        void ResetState(void)
        {
            m_state = 0;
            m_assigned_bitset.reset();
        }

        bool Key(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            if (m_state >= static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0])))
            {
                m_state = 0;
            }

            if (strncmp(str, m_alias_list[m_state], length) && 
                strncmp(str, m_key_list[m_state], length))
            {
                for (size_t i = 0; i < (sizeof(m_key_list)/sizeof(m_key_list[0])); i++)
                {
                    if (!strncmp(str, m_alias_list[i], length) ||
                        !strncmp(str, m_key_list[i], length))
                    {
                        m_state = static_cast<int>(i);
                        return true;
                    }
                }

                m_state = static_cast<unsigned int>(sizeof(m_key_list) / sizeof(m_key_list[0]));
                return true;
            }

            return true;
        }

        bool RawNumber(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)copy;

            switch (m_state)
            {
            case 0:
            {
                m_assigned_bitset.set(m_state);
                JsonDelIntegral(m_data.special_pet, str, length);
            }
            break;
            default:
            {
                return true;
            }
            }

            m_state++;
            return true;
        }

        bool String(const char* str, rapidjson::SizeType length, bool copy) override
        {
            (void)str;
            (void)length;
            (void)copy;

            return true;
        }

        JsonHandler* StartObject() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndObject(JsonHandler* childen, rapidjson::SizeType memberCount) override
        {
            (void)childen;
            (void)memberCount;
            return true;
        }
        JsonHandler* StartArray() override
        {
            m_default_handler.Reset(this);
            return &m_default_handler;
        }

        bool EndArray(JsonHandler* childen, rapidjson::SizeType elementCount) override
        {
            (void)childen;
            (void)elementCount;
            return true;
        }
        bool IsAllMemberSet(void)
        {
            if ((m_assigned_bitset ^ template_assigned_bitset).any())
            {
                return false;
            }

            return true;
        }
    private:
        FighterSpecialPetNtf& m_data;
        HoleJsonHandler m_default_handler;
        unsigned int m_state;
        std::bitset<1> m_assigned_bitset;

        static const std::bitset<1> template_assigned_bitset;
        static const char* m_key_list[1];
        static const char* m_alias_list[1];
    };

	bool ToJson(JsonEnCode& json_data) const
	{
		json_data.Writer().StartObject();

		json_data.AddIntegral(u8"special_pet", special_pet);

		json_data.Writer().EndObject();

		return json_data.Writer().IsComplete();
	}

    bool MarshalJson(std::string& json) const
    {
        JsonEnCode json_encode(4096);

        bool json_ret = this->ToJson(json_encode);

        json = json_encode.ToString();

        return json_ret;
    }

    bool UnmarshalJson(const std::string& json)
    {
        if (json.empty())
        {
            return true;
        }
        
        FighterSpecialPetNtf::Handler h(*this, nullptr);
        JsonDeCode jd(&h);

        JsonAllocator json_allocator;
        rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>, JsonAllocator> rd(&json_allocator, 1024);
        rapidjson::StringStream ss(json.c_str());

        if (rd.Parse<rapidjson::kParseNumbersAsStringsFlag>(ss, jd))
        {
            return h.IsAllMemberSet();
        }

        return false;
    }
};

//===============数据定义结束===============
template<typename D>
class CClientGS
{
public:
	CClientGS()
	{
		size_t max_protocol_size = 0;
		if (sizeof(KeepAliveReq) > max_protocol_size)
			max_protocol_size = sizeof(KeepAliveReq);

		if (sizeof(KeepAliveAck) > max_protocol_size)
			max_protocol_size = sizeof(KeepAliveAck);

		if (sizeof(AttrNtf) > max_protocol_size)
			max_protocol_size = sizeof(AttrNtf);

		if (sizeof(PlayerAppearNtf) > max_protocol_size)
			max_protocol_size = sizeof(PlayerAppearNtf);

		if (sizeof(NPCAppearNtf) > max_protocol_size)
			max_protocol_size = sizeof(NPCAppearNtf);

		if (sizeof(ItemAppearNtf) > max_protocol_size)
			max_protocol_size = sizeof(ItemAppearNtf);

		if (sizeof(ObjDisAppearNtf) > max_protocol_size)
			max_protocol_size = sizeof(ObjDisAppearNtf);

		if (sizeof(ObjMoveNtf) > max_protocol_size)
			max_protocol_size = sizeof(ObjMoveNtf);

		if (sizeof(EnterMapNtf) > max_protocol_size)
			max_protocol_size = sizeof(EnterMapNtf);

		if (sizeof(MoveReq) > max_protocol_size)
			max_protocol_size = sizeof(MoveReq);

		if (sizeof(MoveAck) > max_protocol_size)
			max_protocol_size = sizeof(MoveAck);

		if (sizeof(JumpMapReq) > max_protocol_size)
			max_protocol_size = sizeof(JumpMapReq);

		if (sizeof(JumpMapAck) > max_protocol_size)
			max_protocol_size = sizeof(JumpMapAck);

		if (sizeof(AddJumpMapRegionNtf) > max_protocol_size)
			max_protocol_size = sizeof(AddJumpMapRegionNtf);

		if (sizeof(DelJumpMapRegionNtf) > max_protocol_size)
			max_protocol_size = sizeof(DelJumpMapRegionNtf);

		if (sizeof(ItemAddNtf) > max_protocol_size)
			max_protocol_size = sizeof(ItemAddNtf);

		if (sizeof(ItemUpdateNtf) > max_protocol_size)
			max_protocol_size = sizeof(ItemUpdateNtf);

		if (sizeof(ItemDestroyNtf) > max_protocol_size)
			max_protocol_size = sizeof(ItemDestroyNtf);

		if (sizeof(TipsMsgNtf) > max_protocol_size)
			max_protocol_size = sizeof(TipsMsgNtf);

		if (sizeof(TopMsgNtf) > max_protocol_size)
			max_protocol_size = sizeof(TopMsgNtf);

		if (sizeof(SysMsgNtf) > max_protocol_size)
			max_protocol_size = sizeof(SysMsgNtf);

		if (sizeof(PopupMsgNtf) > max_protocol_size)
			max_protocol_size = sizeof(PopupMsgNtf);

		if (sizeof(ItemContainerNtf) > max_protocol_size)
			max_protocol_size = sizeof(ItemContainerNtf);

		if (sizeof(ItemContainerUpdateNtf) > max_protocol_size)
			max_protocol_size = sizeof(ItemContainerUpdateNtf);

		if (sizeof(SubmitForm) > max_protocol_size)
			max_protocol_size = sizeof(SubmitForm);

		if (sizeof(ShowFormNtf) > max_protocol_size)
			max_protocol_size = sizeof(ShowFormNtf);

		if (sizeof(ExecuteGMReq) > max_protocol_size)
			max_protocol_size = sizeof(ExecuteGMReq);

		if (sizeof(FightBeginNtf) > max_protocol_size)
			max_protocol_size = sizeof(FightBeginNtf);

		if (sizeof(TurnRoundNtf) > max_protocol_size)
			max_protocol_size = sizeof(TurnRoundNtf);

		if (sizeof(FightOperateListNtf) > max_protocol_size)
			max_protocol_size = sizeof(FightOperateListNtf);

		if (sizeof(FightOperateReq) > max_protocol_size)
			max_protocol_size = sizeof(FightOperateReq);

		if (sizeof(FightOperateAck) > max_protocol_size)
			max_protocol_size = sizeof(FightOperateAck);

		if (sizeof(FightOperateNtf) > max_protocol_size)
			max_protocol_size = sizeof(FightOperateNtf);

		if (sizeof(FightDisplayNtf) > max_protocol_size)
			max_protocol_size = sizeof(FightDisplayNtf);

		if (sizeof(FightDisplayCompleteNtf) > max_protocol_size)
			max_protocol_size = sizeof(FightDisplayCompleteNtf);

		if (sizeof(FightAutoReq) > max_protocol_size)
			max_protocol_size = sizeof(FightAutoReq);

		if (sizeof(FightAutoAck) > max_protocol_size)
			max_protocol_size = sizeof(FightAutoAck);

		if (sizeof(FightAutoNtf) > max_protocol_size)
			max_protocol_size = sizeof(FightAutoNtf);

		if (sizeof(FightAutoSkillReq) > max_protocol_size)
			max_protocol_size = sizeof(FightAutoSkillReq);

		if (sizeof(FightAutoSkillAck) > max_protocol_size)
			max_protocol_size = sizeof(FightAutoSkillAck);

		if (sizeof(FightEndNtf) > max_protocol_size)
			max_protocol_size = sizeof(FightEndNtf);

		if (sizeof(AddFighterNtf) > max_protocol_size)
			max_protocol_size = sizeof(AddFighterNtf);

		if (sizeof(DelFighterNtf) > max_protocol_size)
			max_protocol_size = sizeof(DelFighterNtf);

		if (sizeof(AddFightPetData) > max_protocol_size)
			max_protocol_size = sizeof(AddFightPetData);

		if (sizeof(UpdateFightPetData) > max_protocol_size)
			max_protocol_size = sizeof(UpdateFightPetData);

		if (sizeof(PlayerKillReq) > max_protocol_size)
			max_protocol_size = sizeof(PlayerKillReq);

		if (sizeof(PlayerKillAck) > max_protocol_size)
			max_protocol_size = sizeof(PlayerKillAck);

		if (sizeof(EnterFightViewReq) > max_protocol_size)
			max_protocol_size = sizeof(EnterFightViewReq);

		if (sizeof(EnterFightViewAck) > max_protocol_size)
			max_protocol_size = sizeof(EnterFightViewAck);

		if (sizeof(LeaveFightViewReq) > max_protocol_size)
			max_protocol_size = sizeof(LeaveFightViewReq);

		if (sizeof(LeaveFightViewAck) > max_protocol_size)
			max_protocol_size = sizeof(LeaveFightViewAck);

		if (sizeof(TeamLeaderOprReq) > max_protocol_size)
			max_protocol_size = sizeof(TeamLeaderOprReq);

		if (sizeof(TeamNtf) > max_protocol_size)
			max_protocol_size = sizeof(TeamNtf);

		if (sizeof(TeamLeaderNtf) > max_protocol_size)
			max_protocol_size = sizeof(TeamLeaderNtf);

		if (sizeof(TeamDestroyNtf) > max_protocol_size)
			max_protocol_size = sizeof(TeamDestroyNtf);

		if (sizeof(TeamMemberNtf) > max_protocol_size)
			max_protocol_size = sizeof(TeamMemberNtf);

		if (sizeof(TeamMemberLeaveNtf) > max_protocol_size)
			max_protocol_size = sizeof(TeamMemberLeaveNtf);

		if (sizeof(NpcSelectReq) > max_protocol_size)
			max_protocol_size = sizeof(NpcSelectReq);

		if (sizeof(NpcSelectAck) > max_protocol_size)
			max_protocol_size = sizeof(NpcSelectAck);

		if (sizeof(NpcTalkReq) > max_protocol_size)
			max_protocol_size = sizeof(NpcTalkReq);

		if (sizeof(NpcTalkAck) > max_protocol_size)
			max_protocol_size = sizeof(NpcTalkAck);

		if (sizeof(InviteMsgNtf) > max_protocol_size)
			max_protocol_size = sizeof(InviteMsgNtf);

		if (sizeof(ReplyInvite) > max_protocol_size)
			max_protocol_size = sizeof(ReplyInvite);

		if (sizeof(MoveItem) > max_protocol_size)
			max_protocol_size = sizeof(MoveItem);

		if (sizeof(UseItem) > max_protocol_size)
			max_protocol_size = sizeof(UseItem);

		if (sizeof(RearrangeItem) > max_protocol_size)
			max_protocol_size = sizeof(RearrangeItem);

		if (sizeof(SkillContainerNtf) > max_protocol_size)
			max_protocol_size = sizeof(SkillContainerNtf);

		if (sizeof(AddSkillNtf) > max_protocol_size)
			max_protocol_size = sizeof(AddSkillNtf);

		if (sizeof(UpdateSkillNtf) > max_protocol_size)
			max_protocol_size = sizeof(UpdateSkillNtf);

		if (sizeof(DelSkillNtf) > max_protocol_size)
			max_protocol_size = sizeof(DelSkillNtf);

		if (sizeof(PetAppearNtf) > max_protocol_size)
			max_protocol_size = sizeof(PetAppearNtf);

		if (sizeof(PetContainerNtf) > max_protocol_size)
			max_protocol_size = sizeof(PetContainerNtf);

		if (sizeof(PetContainerUpdateNtf) > max_protocol_size)
			max_protocol_size = sizeof(PetContainerUpdateNtf);

		if (sizeof(PetAddNtf) > max_protocol_size)
			max_protocol_size = sizeof(PetAddNtf);

		if (sizeof(PetDestroyNtf) > max_protocol_size)
			max_protocol_size = sizeof(PetDestroyNtf);

		if (sizeof(SetPetLineup) > max_protocol_size)
			max_protocol_size = sizeof(SetPetLineup);

		if (sizeof(ShowPet) > max_protocol_size)
			max_protocol_size = sizeof(ShowPet);

		if (sizeof(ReleasePet) > max_protocol_size)
			max_protocol_size = sizeof(ReleasePet);

		if (sizeof(MovePet) > max_protocol_size)
			max_protocol_size = sizeof(MovePet);

		if (sizeof(ShopOpenNtf) > max_protocol_size)
			max_protocol_size = sizeof(ShopOpenNtf);

		if (sizeof(ShopBuyNtf) > max_protocol_size)
			max_protocol_size = sizeof(ShopBuyNtf);

		if (sizeof(SellNtf) > max_protocol_size)
			max_protocol_size = sizeof(SellNtf);

		if (sizeof(BuyBackNtf) > max_protocol_size)
			max_protocol_size = sizeof(BuyBackNtf);

		if (sizeof(BuyBackListNtf) > max_protocol_size)
			max_protocol_size = sizeof(BuyBackListNtf);

		if (sizeof(TeamAttrNtf) > max_protocol_size)
			max_protocol_size = sizeof(TeamAttrNtf);

		if (sizeof(TipsMsgExNtf) > max_protocol_size)
			max_protocol_size = sizeof(TipsMsgExNtf);

		if (sizeof(ItemNewAddNtf) > max_protocol_size)
			max_protocol_size = sizeof(ItemNewAddNtf);

		if (sizeof(QuestContainerNtf) > max_protocol_size)
			max_protocol_size = sizeof(QuestContainerNtf);

		if (sizeof(QuestAddNtf) > max_protocol_size)
			max_protocol_size = sizeof(QuestAddNtf);

		if (sizeof(QuestStateNtf) > max_protocol_size)
			max_protocol_size = sizeof(QuestStateNtf);

		if (sizeof(QuestNpcStateNtf) > max_protocol_size)
			max_protocol_size = sizeof(QuestNpcStateNtf);

		if (sizeof(QuestTrackCountNtf) > max_protocol_size)
			max_protocol_size = sizeof(QuestTrackCountNtf);

		if (sizeof(QuestTalkSelectReq) > max_protocol_size)
			max_protocol_size = sizeof(QuestTalkSelectReq);

		if (sizeof(QuestTalkSelectAck) > max_protocol_size)
			max_protocol_size = sizeof(QuestTalkSelectAck);

		if (sizeof(ObjStrCustomNtf) > max_protocol_size)
			max_protocol_size = sizeof(ObjStrCustomNtf);

		if (sizeof(ObjIntCustomNtf) > max_protocol_size)
			max_protocol_size = sizeof(ObjIntCustomNtf);

		if (sizeof(ObjDynAttrNtf) > max_protocol_size)
			max_protocol_size = sizeof(ObjDynAttrNtf);

		if (sizeof(CommitQuestItemRsp) > max_protocol_size)
			max_protocol_size = sizeof(CommitQuestItemRsp);

		if (sizeof(CommitQuestItemNtf) > max_protocol_size)
			max_protocol_size = sizeof(CommitQuestItemNtf);

		if (sizeof(CommitQuestPetRsp) > max_protocol_size)
			max_protocol_size = sizeof(CommitQuestPetRsp);

		if (sizeof(CommitQuestPetNtf) > max_protocol_size)
			max_protocol_size = sizeof(CommitQuestPetNtf);

		if (sizeof(AbandonQuest) > max_protocol_size)
			max_protocol_size = sizeof(AbandonQuest);

		if (sizeof(SkillTipsReq) > max_protocol_size)
			max_protocol_size = sizeof(SkillTipsReq);

		if (sizeof(SkillTipsAck) > max_protocol_size)
			max_protocol_size = sizeof(SkillTipsAck);

		if (sizeof(TeamLeaderOprNtf) > max_protocol_size)
			max_protocol_size = sizeof(TeamLeaderOprNtf);

		if (sizeof(KeepAliveCtrlNtf) > max_protocol_size)
			max_protocol_size = sizeof(KeepAliveCtrlNtf);

		if (sizeof(NetDelayReq) > max_protocol_size)
			max_protocol_size = sizeof(NetDelayReq);

		if (sizeof(NetDelayAck) > max_protocol_size)
			max_protocol_size = sizeof(NetDelayAck);

		if (sizeof(SystemSetupNtf) > max_protocol_size)
			max_protocol_size = sizeof(SystemSetupNtf);

		if (sizeof(BuffListNtf) > max_protocol_size)
			max_protocol_size = sizeof(BuffListNtf);

		if (sizeof(BuffAddNtf) > max_protocol_size)
			max_protocol_size = sizeof(BuffAddNtf);

		if (sizeof(BuffDurationNtf) > max_protocol_size)
			max_protocol_size = sizeof(BuffDurationNtf);

		if (sizeof(BuffDynAttrNtf) > max_protocol_size)
			max_protocol_size = sizeof(BuffDynAttrNtf);

		if (sizeof(StopBuff) > max_protocol_size)
			max_protocol_size = sizeof(StopBuff);

		if (sizeof(BuffDelNtf) > max_protocol_size)
			max_protocol_size = sizeof(BuffDelNtf);

		if (sizeof(ActivityListReq) > max_protocol_size)
			max_protocol_size = sizeof(ActivityListReq);

		if (sizeof(ActivityListAck) > max_protocol_size)
			max_protocol_size = sizeof(ActivityListAck);

		if (sizeof(ActivityJoinNtf) > max_protocol_size)
			max_protocol_size = sizeof(ActivityJoinNtf);

		if (sizeof(GuildListNtf) > max_protocol_size)
			max_protocol_size = sizeof(GuildListNtf);

		if (sizeof(GuildNtf) > max_protocol_size)
			max_protocol_size = sizeof(GuildNtf);

		if (sizeof(GuildBaseNtf) > max_protocol_size)
			max_protocol_size = sizeof(GuildBaseNtf);

		if (sizeof(GuildNoticeNtf) > max_protocol_size)
			max_protocol_size = sizeof(GuildNoticeNtf);

		if (sizeof(GuildBriefNtf) > max_protocol_size)
			max_protocol_size = sizeof(GuildBriefNtf);

		if (sizeof(GuildMemberListNtf) > max_protocol_size)
			max_protocol_size = sizeof(GuildMemberListNtf);

		if (sizeof(GuildMemberNtf) > max_protocol_size)
			max_protocol_size = sizeof(GuildMemberNtf);

		if (sizeof(GuildApplicantListNtf) > max_protocol_size)
			max_protocol_size = sizeof(GuildApplicantListNtf);

		if (sizeof(GuildOperationNtf) > max_protocol_size)
			max_protocol_size = sizeof(GuildOperationNtf);

		if (sizeof(GetTimestampReq) > max_protocol_size)
			max_protocol_size = sizeof(GetTimestampReq);

		if (sizeof(GetTimestampAck) > max_protocol_size)
			max_protocol_size = sizeof(GetTimestampAck);

		if (sizeof(ContactListNtf) > max_protocol_size)
			max_protocol_size = sizeof(ContactListNtf);

		if (sizeof(AddContactNtf) > max_protocol_size)
			max_protocol_size = sizeof(AddContactNtf);

		if (sizeof(UpdateContactNtf) > max_protocol_size)
			max_protocol_size = sizeof(UpdateContactNtf);

		if (sizeof(DelContactNtf) > max_protocol_size)
			max_protocol_size = sizeof(DelContactNtf);

		if (sizeof(AddContactMessageNtf) > max_protocol_size)
			max_protocol_size = sizeof(AddContactMessageNtf);

		if (sizeof(ItemQueryNtf) > max_protocol_size)
			max_protocol_size = sizeof(ItemQueryNtf);

		if (sizeof(PetQueryNtf) > max_protocol_size)
			max_protocol_size = sizeof(PetQueryNtf);

		if (sizeof(ContactInfoNtf) > max_protocol_size)
			max_protocol_size = sizeof(ContactInfoNtf);

		if (sizeof(MailListNtf) > max_protocol_size)
			max_protocol_size = sizeof(MailListNtf);

		if (sizeof(AddMailNtf) > max_protocol_size)
			max_protocol_size = sizeof(AddMailNtf);

		if (sizeof(DelMailNtf) > max_protocol_size)
			max_protocol_size = sizeof(DelMailNtf);

		if (sizeof(MailBodyNtf) > max_protocol_size)
			max_protocol_size = sizeof(MailBodyNtf);

		if (sizeof(UpdateMailBodyNtf) > max_protocol_size)
			max_protocol_size = sizeof(UpdateMailBodyNtf);

		if (sizeof(UpdateMailHeadNtf) > max_protocol_size)
			max_protocol_size = sizeof(UpdateMailHeadNtf);

		if (sizeof(RanklistReq) > max_protocol_size)
			max_protocol_size = sizeof(RanklistReq);

		if (sizeof(RanklistAck) > max_protocol_size)
			max_protocol_size = sizeof(RanklistAck);

		if (sizeof(GetRankReq) > max_protocol_size)
			max_protocol_size = sizeof(GetRankReq);

		if (sizeof(GetRankAck) > max_protocol_size)
			max_protocol_size = sizeof(GetRankAck);

		if (sizeof(TitleContainerNtf) > max_protocol_size)
			max_protocol_size = sizeof(TitleContainerNtf);

		if (sizeof(TitleAddNtf) > max_protocol_size)
			max_protocol_size = sizeof(TitleAddNtf);

		if (sizeof(TitleDelNtf) > max_protocol_size)
			max_protocol_size = sizeof(TitleDelNtf);

		if (sizeof(AgentKeyReq) > max_protocol_size)
			max_protocol_size = sizeof(AgentKeyReq);

		if (sizeof(AgentKeyAck) > max_protocol_size)
			max_protocol_size = sizeof(AgentKeyAck);

		if (sizeof(HeadMsgNtf) > max_protocol_size)
			max_protocol_size = sizeof(HeadMsgNtf);

		if (sizeof(AutoContainerNtf) > max_protocol_size)
			max_protocol_size = sizeof(AutoContainerNtf);

		if (sizeof(PlayerQueryNtf) > max_protocol_size)
			max_protocol_size = sizeof(PlayerQueryNtf);

		if (sizeof(UseAllItem) > max_protocol_size)
			max_protocol_size = sizeof(UseAllItem);

		if (sizeof(GuardContainerNtf) > max_protocol_size)
			max_protocol_size = sizeof(GuardContainerNtf);

		if (sizeof(GuardAddNtf) > max_protocol_size)
			max_protocol_size = sizeof(GuardAddNtf);

		if (sizeof(SetGuardLineup) > max_protocol_size)
			max_protocol_size = sizeof(SetGuardLineup);

		if (sizeof(PetNewAddNtf) > max_protocol_size)
			max_protocol_size = sizeof(PetNewAddNtf);

		if (sizeof(TeamPlatformNtf) > max_protocol_size)
			max_protocol_size = sizeof(TeamPlatformNtf);

		if (sizeof(TeamApplicantsNtf) > max_protocol_size)
			max_protocol_size = sizeof(TeamApplicantsNtf);

		if (sizeof(TeamOperationNtf) > max_protocol_size)
			max_protocol_size = sizeof(TeamOperationNtf);

		if (sizeof(TeamTargetNtf) > max_protocol_size)
			max_protocol_size = sizeof(TeamTargetNtf);

		if (sizeof(ChangedNameNtf) > max_protocol_size)
			max_protocol_size = sizeof(ChangedNameNtf);

		if (sizeof(CustomDataNtf) > max_protocol_size)
			max_protocol_size = sizeof(CustomDataNtf);

		if (sizeof(SpeedCheckNtf) > max_protocol_size)
			max_protocol_size = sizeof(SpeedCheckNtf);

		if (sizeof(ConsoleMsgNtf) > max_protocol_size)
			max_protocol_size = sizeof(ConsoleMsgNtf);

		if (sizeof(PetSwapNtf) > max_protocol_size)
			max_protocol_size = sizeof(PetSwapNtf);

		if (sizeof(GuardDestroyNtf) > max_protocol_size)
			max_protocol_size = sizeof(GuardDestroyNtf);

		if (sizeof(ActivateGuard) > max_protocol_size)
			max_protocol_size = sizeof(ActivateGuard);

		if (sizeof(ReleaseGuard) > max_protocol_size)
			max_protocol_size = sizeof(ReleaseGuard);

		if (sizeof(TeamMemberSwapNtf) > max_protocol_size)
			max_protocol_size = sizeof(TeamMemberSwapNtf);

		if (sizeof(GuardSwapNtf) > max_protocol_size)
			max_protocol_size = sizeof(GuardSwapNtf);

		if (sizeof(PetReplaceNtf) > max_protocol_size)
			max_protocol_size = sizeof(PetReplaceNtf);

		if (sizeof(GuardAppearNtf) > max_protocol_size)
			max_protocol_size = sizeof(GuardAppearNtf);

		if (sizeof(InstructionContainerNtf) > max_protocol_size)
			max_protocol_size = sizeof(InstructionContainerNtf);

		if (sizeof(InstructionAddReq) > max_protocol_size)
			max_protocol_size = sizeof(InstructionAddReq);

		if (sizeof(InstructionAddAck) > max_protocol_size)
			max_protocol_size = sizeof(InstructionAddAck);

		if (sizeof(InstructionDeleteReq) > max_protocol_size)
			max_protocol_size = sizeof(InstructionDeleteReq);

		if (sizeof(InstructionDeleteAck) > max_protocol_size)
			max_protocol_size = sizeof(InstructionDeleteAck);

		if (sizeof(InstructionModfityReq) > max_protocol_size)
			max_protocol_size = sizeof(InstructionModfityReq);

		if (sizeof(InstructionModifyAck) > max_protocol_size)
			max_protocol_size = sizeof(InstructionModifyAck);

		if (sizeof(InstructionDefaultReq) > max_protocol_size)
			max_protocol_size = sizeof(InstructionDefaultReq);

		if (sizeof(InstructionDefaultAck) > max_protocol_size)
			max_protocol_size = sizeof(InstructionDefaultAck);

		if (sizeof(InstructionAttachReq) > max_protocol_size)
			max_protocol_size = sizeof(InstructionAttachReq);

		if (sizeof(InstructionAttachAck) > max_protocol_size)
			max_protocol_size = sizeof(InstructionAttachAck);

		if (sizeof(InstructionAttachNtf) > max_protocol_size)
			max_protocol_size = sizeof(InstructionAttachNtf);

		if (sizeof(InstructionDetachReq) > max_protocol_size)
			max_protocol_size = sizeof(InstructionDetachReq);

		if (sizeof(InstructionDetachAck) > max_protocol_size)
			max_protocol_size = sizeof(InstructionDetachAck);

		if (sizeof(InstructionDetachNtf) > max_protocol_size)
			max_protocol_size = sizeof(InstructionDetachNtf);

		if (sizeof(PlayerDetailNtf) > max_protocol_size)
			max_protocol_size = sizeof(PlayerDetailNtf);

		if (sizeof(MapDynBlockPtNtf) > max_protocol_size)
			max_protocol_size = sizeof(MapDynBlockPtNtf);

		if (sizeof(GuardQueryNtf) > max_protocol_size)
			max_protocol_size = sizeof(GuardQueryNtf);

		if (sizeof(BuyBackNtfEx) > max_protocol_size)
			max_protocol_size = sizeof(BuyBackNtfEx);

		if (sizeof(GuildCustomNtf) > max_protocol_size)
			max_protocol_size = sizeof(GuildCustomNtf);

		if (sizeof(PreTurnRoundNtf) > max_protocol_size)
			max_protocol_size = sizeof(PreTurnRoundNtf);

		if (sizeof(FighterSpecialPetNtf) > max_protocol_size)
			max_protocol_size = sizeof(FighterSpecialPetNtf);

		m_protocol_buffer = S_MALLOC(max_protocol_size);
	}

	virtual ~CClientGS()
	{
		if (m_protocol_buffer)
		{
			S_FREE(m_protocol_buffer);
			m_protocol_buffer = 0;
		}
	}

	template<typename T>
	bool BuildProtocol(Protocol<T>& proto, NetEnCode& net_data)
	{
		if (proto.module_id != 102)
			return false;

		net_data.AddIntegral(proto.module_id);
		net_data.AddIntegral(proto.protocol_id);

		return static_cast<T&>(proto).EnCode(net_data);
	}

	bool BuildProtocol(protocol_base* proto, NetEnCode& net_data)
	{
		if (proto->ModuleId() != 102)
			return false;

		net_data.AddIntegral(proto->ModuleId());
		net_data.AddIntegral(proto->ProtocolId());

		return proto->EnCodeEx(net_data);
	}

	const char* ProtocolName(unsigned short protocol_id) const
	{
		static char unknow_protocol[32];

		switch (protocol_id)
		{
		case 1:
		{
			return KeepAliveReq::SName();
		}
		break;
		case 2:
		{
			return KeepAliveAck::SName();
		}
		break;
		case 3:
		{
			return AttrNtf::SName();
		}
		break;
		case 4:
		{
			return PlayerAppearNtf::SName();
		}
		break;
		case 5:
		{
			return NPCAppearNtf::SName();
		}
		break;
		case 6:
		{
			return ItemAppearNtf::SName();
		}
		break;
		case 7:
		{
			return ObjDisAppearNtf::SName();
		}
		break;
		case 8:
		{
			return ObjMoveNtf::SName();
		}
		break;
		case 9:
		{
			return EnterMapNtf::SName();
		}
		break;
		case 10:
		{
			return MoveReq::SName();
		}
		break;
		case 11:
		{
			return MoveAck::SName();
		}
		break;
		case 12:
		{
			return JumpMapReq::SName();
		}
		break;
		case 13:
		{
			return JumpMapAck::SName();
		}
		break;
		case 14:
		{
			return AddJumpMapRegionNtf::SName();
		}
		break;
		case 15:
		{
			return DelJumpMapRegionNtf::SName();
		}
		break;
		case 16:
		{
			return ItemAddNtf::SName();
		}
		break;
		case 17:
		{
			return ItemUpdateNtf::SName();
		}
		break;
		case 18:
		{
			return ItemDestroyNtf::SName();
		}
		break;
		case 19:
		{
			return TipsMsgNtf::SName();
		}
		break;
		case 20:
		{
			return TopMsgNtf::SName();
		}
		break;
		case 21:
		{
			return SysMsgNtf::SName();
		}
		break;
		case 22:
		{
			return PopupMsgNtf::SName();
		}
		break;
		case 23:
		{
			return ItemContainerNtf::SName();
		}
		break;
		case 24:
		{
			return ItemContainerUpdateNtf::SName();
		}
		break;
		case 25:
		{
			return SubmitForm::SName();
		}
		break;
		case 26:
		{
			return ShowFormNtf::SName();
		}
		break;
		case 27:
		{
			return ExecuteGMReq::SName();
		}
		break;
		case 28:
		{
			return FightBeginNtf::SName();
		}
		break;
		case 29:
		{
			return TurnRoundNtf::SName();
		}
		break;
		case 30:
		{
			return FightOperateListNtf::SName();
		}
		break;
		case 31:
		{
			return FightOperateReq::SName();
		}
		break;
		case 32:
		{
			return FightOperateAck::SName();
		}
		break;
		case 33:
		{
			return FightOperateNtf::SName();
		}
		break;
		case 34:
		{
			return FightDisplayNtf::SName();
		}
		break;
		case 35:
		{
			return FightDisplayCompleteNtf::SName();
		}
		break;
		case 36:
		{
			return FightAutoReq::SName();
		}
		break;
		case 37:
		{
			return FightAutoAck::SName();
		}
		break;
		case 38:
		{
			return FightAutoNtf::SName();
		}
		break;
		case 39:
		{
			return FightAutoSkillReq::SName();
		}
		break;
		case 40:
		{
			return FightAutoSkillAck::SName();
		}
		break;
		case 41:
		{
			return FightEndNtf::SName();
		}
		break;
		case 42:
		{
			return AddFighterNtf::SName();
		}
		break;
		case 43:
		{
			return DelFighterNtf::SName();
		}
		break;
		case 44:
		{
			return AddFightPetData::SName();
		}
		break;
		case 45:
		{
			return UpdateFightPetData::SName();
		}
		break;
		case 46:
		{
			return PlayerKillReq::SName();
		}
		break;
		case 47:
		{
			return PlayerKillAck::SName();
		}
		break;
		case 48:
		{
			return EnterFightViewReq::SName();
		}
		break;
		case 49:
		{
			return EnterFightViewAck::SName();
		}
		break;
		case 50:
		{
			return LeaveFightViewReq::SName();
		}
		break;
		case 51:
		{
			return LeaveFightViewAck::SName();
		}
		break;
		case 52:
		{
			return TeamLeaderOprReq::SName();
		}
		break;
		case 53:
		{
			return TeamNtf::SName();
		}
		break;
		case 54:
		{
			return TeamLeaderNtf::SName();
		}
		break;
		case 55:
		{
			return TeamDestroyNtf::SName();
		}
		break;
		case 56:
		{
			return TeamMemberNtf::SName();
		}
		break;
		case 57:
		{
			return TeamMemberLeaveNtf::SName();
		}
		break;
		case 58:
		{
			return NpcSelectReq::SName();
		}
		break;
		case 59:
		{
			return NpcSelectAck::SName();
		}
		break;
		case 60:
		{
			return NpcTalkReq::SName();
		}
		break;
		case 61:
		{
			return NpcTalkAck::SName();
		}
		break;
		case 62:
		{
			return InviteMsgNtf::SName();
		}
		break;
		case 63:
		{
			return ReplyInvite::SName();
		}
		break;
		case 64:
		{
			return MoveItem::SName();
		}
		break;
		case 65:
		{
			return UseItem::SName();
		}
		break;
		case 66:
		{
			return RearrangeItem::SName();
		}
		break;
		case 67:
		{
			return SkillContainerNtf::SName();
		}
		break;
		case 68:
		{
			return AddSkillNtf::SName();
		}
		break;
		case 69:
		{
			return UpdateSkillNtf::SName();
		}
		break;
		case 70:
		{
			return DelSkillNtf::SName();
		}
		break;
		case 71:
		{
			return PetAppearNtf::SName();
		}
		break;
		case 72:
		{
			return PetContainerNtf::SName();
		}
		break;
		case 73:
		{
			return PetContainerUpdateNtf::SName();
		}
		break;
		case 74:
		{
			return PetAddNtf::SName();
		}
		break;
		case 75:
		{
			return PetDestroyNtf::SName();
		}
		break;
		case 76:
		{
			return SetPetLineup::SName();
		}
		break;
		case 77:
		{
			return ShowPet::SName();
		}
		break;
		case 78:
		{
			return ReleasePet::SName();
		}
		break;
		case 79:
		{
			return MovePet::SName();
		}
		break;
		case 80:
		{
			return ShopOpenNtf::SName();
		}
		break;
		case 81:
		{
			return ShopBuyNtf::SName();
		}
		break;
		case 82:
		{
			return SellNtf::SName();
		}
		break;
		case 83:
		{
			return BuyBackNtf::SName();
		}
		break;
		case 84:
		{
			return BuyBackListNtf::SName();
		}
		break;
		case 85:
		{
			return TeamAttrNtf::SName();
		}
		break;
		case 86:
		{
			return TipsMsgExNtf::SName();
		}
		break;
		case 87:
		{
			return ItemNewAddNtf::SName();
		}
		break;
		case 88:
		{
			return QuestContainerNtf::SName();
		}
		break;
		case 89:
		{
			return QuestAddNtf::SName();
		}
		break;
		case 90:
		{
			return QuestStateNtf::SName();
		}
		break;
		case 91:
		{
			return QuestNpcStateNtf::SName();
		}
		break;
		case 92:
		{
			return QuestTrackCountNtf::SName();
		}
		break;
		case 93:
		{
			return QuestTalkSelectReq::SName();
		}
		break;
		case 94:
		{
			return QuestTalkSelectAck::SName();
		}
		break;
		case 95:
		{
			return ObjStrCustomNtf::SName();
		}
		break;
		case 96:
		{
			return ObjIntCustomNtf::SName();
		}
		break;
		case 97:
		{
			return ObjDynAttrNtf::SName();
		}
		break;
		case 98:
		{
			return CommitQuestItemRsp::SName();
		}
		break;
		case 99:
		{
			return CommitQuestItemNtf::SName();
		}
		break;
		case 100:
		{
			return CommitQuestPetRsp::SName();
		}
		break;
		case 101:
		{
			return CommitQuestPetNtf::SName();
		}
		break;
		case 102:
		{
			return AbandonQuest::SName();
		}
		break;
		case 103:
		{
			return SkillTipsReq::SName();
		}
		break;
		case 104:
		{
			return SkillTipsAck::SName();
		}
		break;
		case 105:
		{
			return TeamLeaderOprNtf::SName();
		}
		break;
		case 106:
		{
			return KeepAliveCtrlNtf::SName();
		}
		break;
		case 107:
		{
			return NetDelayReq::SName();
		}
		break;
		case 108:
		{
			return NetDelayAck::SName();
		}
		break;
		case 109:
		{
			return SystemSetupNtf::SName();
		}
		break;
		case 110:
		{
			return BuffListNtf::SName();
		}
		break;
		case 111:
		{
			return BuffAddNtf::SName();
		}
		break;
		case 112:
		{
			return BuffDurationNtf::SName();
		}
		break;
		case 113:
		{
			return BuffDynAttrNtf::SName();
		}
		break;
		case 114:
		{
			return StopBuff::SName();
		}
		break;
		case 115:
		{
			return BuffDelNtf::SName();
		}
		break;
		case 116:
		{
			return ActivityListReq::SName();
		}
		break;
		case 117:
		{
			return ActivityListAck::SName();
		}
		break;
		case 118:
		{
			return ActivityJoinNtf::SName();
		}
		break;
		case 119:
		{
			return GuildListNtf::SName();
		}
		break;
		case 120:
		{
			return GuildNtf::SName();
		}
		break;
		case 121:
		{
			return GuildBaseNtf::SName();
		}
		break;
		case 122:
		{
			return GuildNoticeNtf::SName();
		}
		break;
		case 123:
		{
			return GuildBriefNtf::SName();
		}
		break;
		case 124:
		{
			return GuildMemberListNtf::SName();
		}
		break;
		case 125:
		{
			return GuildMemberNtf::SName();
		}
		break;
		case 126:
		{
			return GuildApplicantListNtf::SName();
		}
		break;
		case 127:
		{
			return GuildOperationNtf::SName();
		}
		break;
		case 128:
		{
			return GetTimestampReq::SName();
		}
		break;
		case 129:
		{
			return GetTimestampAck::SName();
		}
		break;
		case 130:
		{
			return ContactListNtf::SName();
		}
		break;
		case 131:
		{
			return AddContactNtf::SName();
		}
		break;
		case 132:
		{
			return UpdateContactNtf::SName();
		}
		break;
		case 133:
		{
			return DelContactNtf::SName();
		}
		break;
		case 134:
		{
			return AddContactMessageNtf::SName();
		}
		break;
		case 135:
		{
			return ItemQueryNtf::SName();
		}
		break;
		case 136:
		{
			return PetQueryNtf::SName();
		}
		break;
		case 137:
		{
			return ContactInfoNtf::SName();
		}
		break;
		case 138:
		{
			return MailListNtf::SName();
		}
		break;
		case 139:
		{
			return AddMailNtf::SName();
		}
		break;
		case 140:
		{
			return DelMailNtf::SName();
		}
		break;
		case 141:
		{
			return MailBodyNtf::SName();
		}
		break;
		case 142:
		{
			return UpdateMailBodyNtf::SName();
		}
		break;
		case 143:
		{
			return UpdateMailHeadNtf::SName();
		}
		break;
		case 144:
		{
			return RanklistReq::SName();
		}
		break;
		case 145:
		{
			return RanklistAck::SName();
		}
		break;
		case 146:
		{
			return GetRankReq::SName();
		}
		break;
		case 147:
		{
			return GetRankAck::SName();
		}
		break;
		case 148:
		{
			return TitleContainerNtf::SName();
		}
		break;
		case 149:
		{
			return TitleAddNtf::SName();
		}
		break;
		case 150:
		{
			return TitleDelNtf::SName();
		}
		break;
		case 151:
		{
			return AgentKeyReq::SName();
		}
		break;
		case 152:
		{
			return AgentKeyAck::SName();
		}
		break;
		case 153:
		{
			return HeadMsgNtf::SName();
		}
		break;
		case 154:
		{
			return AutoContainerNtf::SName();
		}
		break;
		case 155:
		{
			return PlayerQueryNtf::SName();
		}
		break;
		case 156:
		{
			return UseAllItem::SName();
		}
		break;
		case 157:
		{
			return GuardContainerNtf::SName();
		}
		break;
		case 158:
		{
			return GuardAddNtf::SName();
		}
		break;
		case 159:
		{
			return SetGuardLineup::SName();
		}
		break;
		case 160:
		{
			return PetNewAddNtf::SName();
		}
		break;
		case 161:
		{
			return TeamPlatformNtf::SName();
		}
		break;
		case 162:
		{
			return TeamApplicantsNtf::SName();
		}
		break;
		case 163:
		{
			return TeamOperationNtf::SName();
		}
		break;
		case 164:
		{
			return TeamTargetNtf::SName();
		}
		break;
		case 165:
		{
			return ChangedNameNtf::SName();
		}
		break;
		case 166:
		{
			return CustomDataNtf::SName();
		}
		break;
		case 167:
		{
			return SpeedCheckNtf::SName();
		}
		break;
		case 168:
		{
			return ConsoleMsgNtf::SName();
		}
		break;
		case 169:
		{
			return PetSwapNtf::SName();
		}
		break;
		case 170:
		{
			return GuardDestroyNtf::SName();
		}
		break;
		case 171:
		{
			return ActivateGuard::SName();
		}
		break;
		case 172:
		{
			return ReleaseGuard::SName();
		}
		break;
		case 173:
		{
			return TeamMemberSwapNtf::SName();
		}
		break;
		case 174:
		{
			return GuardSwapNtf::SName();
		}
		break;
		case 175:
		{
			return PetReplaceNtf::SName();
		}
		break;
		case 176:
		{
			return GuardAppearNtf::SName();
		}
		break;
		case 177:
		{
			return InstructionContainerNtf::SName();
		}
		break;
		case 178:
		{
			return InstructionAddReq::SName();
		}
		break;
		case 179:
		{
			return InstructionAddAck::SName();
		}
		break;
		case 180:
		{
			return InstructionDeleteReq::SName();
		}
		break;
		case 181:
		{
			return InstructionDeleteAck::SName();
		}
		break;
		case 182:
		{
			return InstructionModfityReq::SName();
		}
		break;
		case 183:
		{
			return InstructionModifyAck::SName();
		}
		break;
		case 184:
		{
			return InstructionDefaultReq::SName();
		}
		break;
		case 185:
		{
			return InstructionDefaultAck::SName();
		}
		break;
		case 186:
		{
			return InstructionAttachReq::SName();
		}
		break;
		case 187:
		{
			return InstructionAttachAck::SName();
		}
		break;
		case 188:
		{
			return InstructionAttachNtf::SName();
		}
		break;
		case 189:
		{
			return InstructionDetachReq::SName();
		}
		break;
		case 190:
		{
			return InstructionDetachAck::SName();
		}
		break;
		case 191:
		{
			return InstructionDetachNtf::SName();
		}
		break;
		case 192:
		{
			return PlayerDetailNtf::SName();
		}
		break;
		case 193:
		{
			return MapDynBlockPtNtf::SName();
		}
		break;
		case 194:
		{
			return GuardQueryNtf::SName();
		}
		break;
		case 195:
		{
			return BuyBackNtfEx::SName();
		}
		break;
		case 196:
		{
			return GuildCustomNtf::SName();
		}
		break;
		case 197:
		{
			return PreTurnRoundNtf::SName();
		}
		break;
		case 198:
		{
			return FighterSpecialPetNtf::SName();
		}
		break;
		default:
		{
			snprintf(unknow_protocol, sizeof(unknow_protocol), u8"Unknow Protocol Id = %d", protocol_id);
			return unknow_protocol;
		}
		}
	}

	bool HandleProtocol(NetDeCode& net_data)
	{
		unsigned short m_id = 0;
		unsigned short p_id = 0;
		size_t net_data_pos = net_data.CurPos();

		if (!net_data.DelIntegral(m_id) || !net_data.DelIntegral(p_id))
		{
			net_data.Reset(net_data_pos);
			return false;
		}

		if (m_id != 102)
		{
			net_data.Reset(net_data_pos);
			return false;
		}

		switch(p_id)
		{
		case 1:
		{
			KeepAliveReq* proto = new(m_protocol_buffer) KeepAliveReq();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_KeepAliveReq(*proto);
				proto->~KeepAliveReq();
				return true;
			}
			else
			{
				proto->~KeepAliveReq();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 2:
		{
			KeepAliveAck* proto = new(m_protocol_buffer) KeepAliveAck();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_KeepAliveAck(*proto);
				proto->~KeepAliveAck();
				return true;
			}
			else
			{
				proto->~KeepAliveAck();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 3:
		{
			AttrNtf* proto = new(m_protocol_buffer) AttrNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_AttrNtf(*proto);
				proto->~AttrNtf();
				return true;
			}
			else
			{
				proto->~AttrNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 4:
		{
			PlayerAppearNtf* proto = new(m_protocol_buffer) PlayerAppearNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_PlayerAppearNtf(*proto);
				proto->~PlayerAppearNtf();
				return true;
			}
			else
			{
				proto->~PlayerAppearNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 5:
		{
			NPCAppearNtf* proto = new(m_protocol_buffer) NPCAppearNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_NPCAppearNtf(*proto);
				proto->~NPCAppearNtf();
				return true;
			}
			else
			{
				proto->~NPCAppearNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 6:
		{
			ItemAppearNtf* proto = new(m_protocol_buffer) ItemAppearNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_ItemAppearNtf(*proto);
				proto->~ItemAppearNtf();
				return true;
			}
			else
			{
				proto->~ItemAppearNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 7:
		{
			ObjDisAppearNtf* proto = new(m_protocol_buffer) ObjDisAppearNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_ObjDisAppearNtf(*proto);
				proto->~ObjDisAppearNtf();
				return true;
			}
			else
			{
				proto->~ObjDisAppearNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 8:
		{
			ObjMoveNtf* proto = new(m_protocol_buffer) ObjMoveNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_ObjMoveNtf(*proto);
				proto->~ObjMoveNtf();
				return true;
			}
			else
			{
				proto->~ObjMoveNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 9:
		{
			EnterMapNtf* proto = new(m_protocol_buffer) EnterMapNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_EnterMapNtf(*proto);
				proto->~EnterMapNtf();
				return true;
			}
			else
			{
				proto->~EnterMapNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 10:
		{
			MoveReq* proto = new(m_protocol_buffer) MoveReq();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_MoveReq(*proto);
				proto->~MoveReq();
				return true;
			}
			else
			{
				proto->~MoveReq();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 11:
		{
			MoveAck* proto = new(m_protocol_buffer) MoveAck();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_MoveAck(*proto);
				proto->~MoveAck();
				return true;
			}
			else
			{
				proto->~MoveAck();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 12:
		{
			JumpMapReq* proto = new(m_protocol_buffer) JumpMapReq();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_JumpMapReq(*proto);
				proto->~JumpMapReq();
				return true;
			}
			else
			{
				proto->~JumpMapReq();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 13:
		{
			JumpMapAck* proto = new(m_protocol_buffer) JumpMapAck();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_JumpMapAck(*proto);
				proto->~JumpMapAck();
				return true;
			}
			else
			{
				proto->~JumpMapAck();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 14:
		{
			AddJumpMapRegionNtf* proto = new(m_protocol_buffer) AddJumpMapRegionNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_AddJumpMapRegionNtf(*proto);
				proto->~AddJumpMapRegionNtf();
				return true;
			}
			else
			{
				proto->~AddJumpMapRegionNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 15:
		{
			DelJumpMapRegionNtf* proto = new(m_protocol_buffer) DelJumpMapRegionNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_DelJumpMapRegionNtf(*proto);
				proto->~DelJumpMapRegionNtf();
				return true;
			}
			else
			{
				proto->~DelJumpMapRegionNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 16:
		{
			ItemAddNtf* proto = new(m_protocol_buffer) ItemAddNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_ItemAddNtf(*proto);
				proto->~ItemAddNtf();
				return true;
			}
			else
			{
				proto->~ItemAddNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 17:
		{
			ItemUpdateNtf* proto = new(m_protocol_buffer) ItemUpdateNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_ItemUpdateNtf(*proto);
				proto->~ItemUpdateNtf();
				return true;
			}
			else
			{
				proto->~ItemUpdateNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 18:
		{
			ItemDestroyNtf* proto = new(m_protocol_buffer) ItemDestroyNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_ItemDestroyNtf(*proto);
				proto->~ItemDestroyNtf();
				return true;
			}
			else
			{
				proto->~ItemDestroyNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 19:
		{
			TipsMsgNtf* proto = new(m_protocol_buffer) TipsMsgNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_TipsMsgNtf(*proto);
				proto->~TipsMsgNtf();
				return true;
			}
			else
			{
				proto->~TipsMsgNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 20:
		{
			TopMsgNtf* proto = new(m_protocol_buffer) TopMsgNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_TopMsgNtf(*proto);
				proto->~TopMsgNtf();
				return true;
			}
			else
			{
				proto->~TopMsgNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 21:
		{
			SysMsgNtf* proto = new(m_protocol_buffer) SysMsgNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_SysMsgNtf(*proto);
				proto->~SysMsgNtf();
				return true;
			}
			else
			{
				proto->~SysMsgNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 22:
		{
			PopupMsgNtf* proto = new(m_protocol_buffer) PopupMsgNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_PopupMsgNtf(*proto);
				proto->~PopupMsgNtf();
				return true;
			}
			else
			{
				proto->~PopupMsgNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 23:
		{
			ItemContainerNtf* proto = new(m_protocol_buffer) ItemContainerNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_ItemContainerNtf(*proto);
				proto->~ItemContainerNtf();
				return true;
			}
			else
			{
				proto->~ItemContainerNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 24:
		{
			ItemContainerUpdateNtf* proto = new(m_protocol_buffer) ItemContainerUpdateNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_ItemContainerUpdateNtf(*proto);
				proto->~ItemContainerUpdateNtf();
				return true;
			}
			else
			{
				proto->~ItemContainerUpdateNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 25:
		{
			SubmitForm* proto = new(m_protocol_buffer) SubmitForm();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_SubmitForm(*proto);
				proto->~SubmitForm();
				return true;
			}
			else
			{
				proto->~SubmitForm();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 26:
		{
			ShowFormNtf* proto = new(m_protocol_buffer) ShowFormNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_ShowFormNtf(*proto);
				proto->~ShowFormNtf();
				return true;
			}
			else
			{
				proto->~ShowFormNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 27:
		{
			ExecuteGMReq* proto = new(m_protocol_buffer) ExecuteGMReq();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_ExecuteGMReq(*proto);
				proto->~ExecuteGMReq();
				return true;
			}
			else
			{
				proto->~ExecuteGMReq();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 28:
		{
			FightBeginNtf* proto = new(m_protocol_buffer) FightBeginNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_FightBeginNtf(*proto);
				proto->~FightBeginNtf();
				return true;
			}
			else
			{
				proto->~FightBeginNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 29:
		{
			TurnRoundNtf* proto = new(m_protocol_buffer) TurnRoundNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_TurnRoundNtf(*proto);
				proto->~TurnRoundNtf();
				return true;
			}
			else
			{
				proto->~TurnRoundNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 30:
		{
			FightOperateListNtf* proto = new(m_protocol_buffer) FightOperateListNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_FightOperateListNtf(*proto);
				proto->~FightOperateListNtf();
				return true;
			}
			else
			{
				proto->~FightOperateListNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 31:
		{
			FightOperateReq* proto = new(m_protocol_buffer) FightOperateReq();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_FightOperateReq(*proto);
				proto->~FightOperateReq();
				return true;
			}
			else
			{
				proto->~FightOperateReq();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 32:
		{
			FightOperateAck* proto = new(m_protocol_buffer) FightOperateAck();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_FightOperateAck(*proto);
				proto->~FightOperateAck();
				return true;
			}
			else
			{
				proto->~FightOperateAck();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 33:
		{
			FightOperateNtf* proto = new(m_protocol_buffer) FightOperateNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_FightOperateNtf(*proto);
				proto->~FightOperateNtf();
				return true;
			}
			else
			{
				proto->~FightOperateNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 34:
		{
			FightDisplayNtf* proto = new(m_protocol_buffer) FightDisplayNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_FightDisplayNtf(*proto);
				proto->~FightDisplayNtf();
				return true;
			}
			else
			{
				proto->~FightDisplayNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 35:
		{
			FightDisplayCompleteNtf* proto = new(m_protocol_buffer) FightDisplayCompleteNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_FightDisplayCompleteNtf(*proto);
				proto->~FightDisplayCompleteNtf();
				return true;
			}
			else
			{
				proto->~FightDisplayCompleteNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 36:
		{
			FightAutoReq* proto = new(m_protocol_buffer) FightAutoReq();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_FightAutoReq(*proto);
				proto->~FightAutoReq();
				return true;
			}
			else
			{
				proto->~FightAutoReq();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 37:
		{
			FightAutoAck* proto = new(m_protocol_buffer) FightAutoAck();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_FightAutoAck(*proto);
				proto->~FightAutoAck();
				return true;
			}
			else
			{
				proto->~FightAutoAck();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 38:
		{
			FightAutoNtf* proto = new(m_protocol_buffer) FightAutoNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_FightAutoNtf(*proto);
				proto->~FightAutoNtf();
				return true;
			}
			else
			{
				proto->~FightAutoNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 39:
		{
			FightAutoSkillReq* proto = new(m_protocol_buffer) FightAutoSkillReq();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_FightAutoSkillReq(*proto);
				proto->~FightAutoSkillReq();
				return true;
			}
			else
			{
				proto->~FightAutoSkillReq();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 40:
		{
			FightAutoSkillAck* proto = new(m_protocol_buffer) FightAutoSkillAck();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_FightAutoSkillAck(*proto);
				proto->~FightAutoSkillAck();
				return true;
			}
			else
			{
				proto->~FightAutoSkillAck();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 41:
		{
			FightEndNtf* proto = new(m_protocol_buffer) FightEndNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_FightEndNtf(*proto);
				proto->~FightEndNtf();
				return true;
			}
			else
			{
				proto->~FightEndNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 42:
		{
			AddFighterNtf* proto = new(m_protocol_buffer) AddFighterNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_AddFighterNtf(*proto);
				proto->~AddFighterNtf();
				return true;
			}
			else
			{
				proto->~AddFighterNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 43:
		{
			DelFighterNtf* proto = new(m_protocol_buffer) DelFighterNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_DelFighterNtf(*proto);
				proto->~DelFighterNtf();
				return true;
			}
			else
			{
				proto->~DelFighterNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 44:
		{
			AddFightPetData* proto = new(m_protocol_buffer) AddFightPetData();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_AddFightPetData(*proto);
				proto->~AddFightPetData();
				return true;
			}
			else
			{
				proto->~AddFightPetData();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 45:
		{
			UpdateFightPetData* proto = new(m_protocol_buffer) UpdateFightPetData();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_UpdateFightPetData(*proto);
				proto->~UpdateFightPetData();
				return true;
			}
			else
			{
				proto->~UpdateFightPetData();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 46:
		{
			PlayerKillReq* proto = new(m_protocol_buffer) PlayerKillReq();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_PlayerKillReq(*proto);
				proto->~PlayerKillReq();
				return true;
			}
			else
			{
				proto->~PlayerKillReq();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 47:
		{
			PlayerKillAck* proto = new(m_protocol_buffer) PlayerKillAck();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_PlayerKillAck(*proto);
				proto->~PlayerKillAck();
				return true;
			}
			else
			{
				proto->~PlayerKillAck();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 48:
		{
			EnterFightViewReq* proto = new(m_protocol_buffer) EnterFightViewReq();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_EnterFightViewReq(*proto);
				proto->~EnterFightViewReq();
				return true;
			}
			else
			{
				proto->~EnterFightViewReq();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 49:
		{
			EnterFightViewAck* proto = new(m_protocol_buffer) EnterFightViewAck();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_EnterFightViewAck(*proto);
				proto->~EnterFightViewAck();
				return true;
			}
			else
			{
				proto->~EnterFightViewAck();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 50:
		{
			LeaveFightViewReq* proto = new(m_protocol_buffer) LeaveFightViewReq();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_LeaveFightViewReq(*proto);
				proto->~LeaveFightViewReq();
				return true;
			}
			else
			{
				proto->~LeaveFightViewReq();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 51:
		{
			LeaveFightViewAck* proto = new(m_protocol_buffer) LeaveFightViewAck();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_LeaveFightViewAck(*proto);
				proto->~LeaveFightViewAck();
				return true;
			}
			else
			{
				proto->~LeaveFightViewAck();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 52:
		{
			TeamLeaderOprReq* proto = new(m_protocol_buffer) TeamLeaderOprReq();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_TeamLeaderOprReq(*proto);
				proto->~TeamLeaderOprReq();
				return true;
			}
			else
			{
				proto->~TeamLeaderOprReq();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 53:
		{
			TeamNtf* proto = new(m_protocol_buffer) TeamNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_TeamNtf(*proto);
				proto->~TeamNtf();
				return true;
			}
			else
			{
				proto->~TeamNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 54:
		{
			TeamLeaderNtf* proto = new(m_protocol_buffer) TeamLeaderNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_TeamLeaderNtf(*proto);
				proto->~TeamLeaderNtf();
				return true;
			}
			else
			{
				proto->~TeamLeaderNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 55:
		{
			TeamDestroyNtf* proto = new(m_protocol_buffer) TeamDestroyNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_TeamDestroyNtf(*proto);
				proto->~TeamDestroyNtf();
				return true;
			}
			else
			{
				proto->~TeamDestroyNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 56:
		{
			TeamMemberNtf* proto = new(m_protocol_buffer) TeamMemberNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_TeamMemberNtf(*proto);
				proto->~TeamMemberNtf();
				return true;
			}
			else
			{
				proto->~TeamMemberNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 57:
		{
			TeamMemberLeaveNtf* proto = new(m_protocol_buffer) TeamMemberLeaveNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_TeamMemberLeaveNtf(*proto);
				proto->~TeamMemberLeaveNtf();
				return true;
			}
			else
			{
				proto->~TeamMemberLeaveNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 58:
		{
			NpcSelectReq* proto = new(m_protocol_buffer) NpcSelectReq();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_NpcSelectReq(*proto);
				proto->~NpcSelectReq();
				return true;
			}
			else
			{
				proto->~NpcSelectReq();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 59:
		{
			NpcSelectAck* proto = new(m_protocol_buffer) NpcSelectAck();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_NpcSelectAck(*proto);
				proto->~NpcSelectAck();
				return true;
			}
			else
			{
				proto->~NpcSelectAck();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 60:
		{
			NpcTalkReq* proto = new(m_protocol_buffer) NpcTalkReq();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_NpcTalkReq(*proto);
				proto->~NpcTalkReq();
				return true;
			}
			else
			{
				proto->~NpcTalkReq();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 61:
		{
			NpcTalkAck* proto = new(m_protocol_buffer) NpcTalkAck();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_NpcTalkAck(*proto);
				proto->~NpcTalkAck();
				return true;
			}
			else
			{
				proto->~NpcTalkAck();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 62:
		{
			InviteMsgNtf* proto = new(m_protocol_buffer) InviteMsgNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_InviteMsgNtf(*proto);
				proto->~InviteMsgNtf();
				return true;
			}
			else
			{
				proto->~InviteMsgNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 63:
		{
			ReplyInvite* proto = new(m_protocol_buffer) ReplyInvite();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_ReplyInvite(*proto);
				proto->~ReplyInvite();
				return true;
			}
			else
			{
				proto->~ReplyInvite();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 64:
		{
			MoveItem* proto = new(m_protocol_buffer) MoveItem();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_MoveItem(*proto);
				proto->~MoveItem();
				return true;
			}
			else
			{
				proto->~MoveItem();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 65:
		{
			UseItem* proto = new(m_protocol_buffer) UseItem();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_UseItem(*proto);
				proto->~UseItem();
				return true;
			}
			else
			{
				proto->~UseItem();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 66:
		{
			RearrangeItem* proto = new(m_protocol_buffer) RearrangeItem();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_RearrangeItem(*proto);
				proto->~RearrangeItem();
				return true;
			}
			else
			{
				proto->~RearrangeItem();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 67:
		{
			SkillContainerNtf* proto = new(m_protocol_buffer) SkillContainerNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_SkillContainerNtf(*proto);
				proto->~SkillContainerNtf();
				return true;
			}
			else
			{
				proto->~SkillContainerNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 68:
		{
			AddSkillNtf* proto = new(m_protocol_buffer) AddSkillNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_AddSkillNtf(*proto);
				proto->~AddSkillNtf();
				return true;
			}
			else
			{
				proto->~AddSkillNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 69:
		{
			UpdateSkillNtf* proto = new(m_protocol_buffer) UpdateSkillNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_UpdateSkillNtf(*proto);
				proto->~UpdateSkillNtf();
				return true;
			}
			else
			{
				proto->~UpdateSkillNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 70:
		{
			DelSkillNtf* proto = new(m_protocol_buffer) DelSkillNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_DelSkillNtf(*proto);
				proto->~DelSkillNtf();
				return true;
			}
			else
			{
				proto->~DelSkillNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 71:
		{
			PetAppearNtf* proto = new(m_protocol_buffer) PetAppearNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_PetAppearNtf(*proto);
				proto->~PetAppearNtf();
				return true;
			}
			else
			{
				proto->~PetAppearNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 72:
		{
			PetContainerNtf* proto = new(m_protocol_buffer) PetContainerNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_PetContainerNtf(*proto);
				proto->~PetContainerNtf();
				return true;
			}
			else
			{
				proto->~PetContainerNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 73:
		{
			PetContainerUpdateNtf* proto = new(m_protocol_buffer) PetContainerUpdateNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_PetContainerUpdateNtf(*proto);
				proto->~PetContainerUpdateNtf();
				return true;
			}
			else
			{
				proto->~PetContainerUpdateNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 74:
		{
			PetAddNtf* proto = new(m_protocol_buffer) PetAddNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_PetAddNtf(*proto);
				proto->~PetAddNtf();
				return true;
			}
			else
			{
				proto->~PetAddNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 75:
		{
			PetDestroyNtf* proto = new(m_protocol_buffer) PetDestroyNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_PetDestroyNtf(*proto);
				proto->~PetDestroyNtf();
				return true;
			}
			else
			{
				proto->~PetDestroyNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 76:
		{
			SetPetLineup* proto = new(m_protocol_buffer) SetPetLineup();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_SetPetLineup(*proto);
				proto->~SetPetLineup();
				return true;
			}
			else
			{
				proto->~SetPetLineup();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 77:
		{
			ShowPet* proto = new(m_protocol_buffer) ShowPet();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_ShowPet(*proto);
				proto->~ShowPet();
				return true;
			}
			else
			{
				proto->~ShowPet();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 78:
		{
			ReleasePet* proto = new(m_protocol_buffer) ReleasePet();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_ReleasePet(*proto);
				proto->~ReleasePet();
				return true;
			}
			else
			{
				proto->~ReleasePet();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 79:
		{
			MovePet* proto = new(m_protocol_buffer) MovePet();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_MovePet(*proto);
				proto->~MovePet();
				return true;
			}
			else
			{
				proto->~MovePet();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 80:
		{
			ShopOpenNtf* proto = new(m_protocol_buffer) ShopOpenNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_ShopOpenNtf(*proto);
				proto->~ShopOpenNtf();
				return true;
			}
			else
			{
				proto->~ShopOpenNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 81:
		{
			ShopBuyNtf* proto = new(m_protocol_buffer) ShopBuyNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_ShopBuyNtf(*proto);
				proto->~ShopBuyNtf();
				return true;
			}
			else
			{
				proto->~ShopBuyNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 82:
		{
			SellNtf* proto = new(m_protocol_buffer) SellNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_SellNtf(*proto);
				proto->~SellNtf();
				return true;
			}
			else
			{
				proto->~SellNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 83:
		{
			BuyBackNtf* proto = new(m_protocol_buffer) BuyBackNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_BuyBackNtf(*proto);
				proto->~BuyBackNtf();
				return true;
			}
			else
			{
				proto->~BuyBackNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 84:
		{
			BuyBackListNtf* proto = new(m_protocol_buffer) BuyBackListNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_BuyBackListNtf(*proto);
				proto->~BuyBackListNtf();
				return true;
			}
			else
			{
				proto->~BuyBackListNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 85:
		{
			TeamAttrNtf* proto = new(m_protocol_buffer) TeamAttrNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_TeamAttrNtf(*proto);
				proto->~TeamAttrNtf();
				return true;
			}
			else
			{
				proto->~TeamAttrNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 86:
		{
			TipsMsgExNtf* proto = new(m_protocol_buffer) TipsMsgExNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_TipsMsgExNtf(*proto);
				proto->~TipsMsgExNtf();
				return true;
			}
			else
			{
				proto->~TipsMsgExNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 87:
		{
			ItemNewAddNtf* proto = new(m_protocol_buffer) ItemNewAddNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_ItemNewAddNtf(*proto);
				proto->~ItemNewAddNtf();
				return true;
			}
			else
			{
				proto->~ItemNewAddNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 88:
		{
			QuestContainerNtf* proto = new(m_protocol_buffer) QuestContainerNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_QuestContainerNtf(*proto);
				proto->~QuestContainerNtf();
				return true;
			}
			else
			{
				proto->~QuestContainerNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 89:
		{
			QuestAddNtf* proto = new(m_protocol_buffer) QuestAddNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_QuestAddNtf(*proto);
				proto->~QuestAddNtf();
				return true;
			}
			else
			{
				proto->~QuestAddNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 90:
		{
			QuestStateNtf* proto = new(m_protocol_buffer) QuestStateNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_QuestStateNtf(*proto);
				proto->~QuestStateNtf();
				return true;
			}
			else
			{
				proto->~QuestStateNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 91:
		{
			QuestNpcStateNtf* proto = new(m_protocol_buffer) QuestNpcStateNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_QuestNpcStateNtf(*proto);
				proto->~QuestNpcStateNtf();
				return true;
			}
			else
			{
				proto->~QuestNpcStateNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 92:
		{
			QuestTrackCountNtf* proto = new(m_protocol_buffer) QuestTrackCountNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_QuestTrackCountNtf(*proto);
				proto->~QuestTrackCountNtf();
				return true;
			}
			else
			{
				proto->~QuestTrackCountNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 93:
		{
			QuestTalkSelectReq* proto = new(m_protocol_buffer) QuestTalkSelectReq();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_QuestTalkSelectReq(*proto);
				proto->~QuestTalkSelectReq();
				return true;
			}
			else
			{
				proto->~QuestTalkSelectReq();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 94:
		{
			QuestTalkSelectAck* proto = new(m_protocol_buffer) QuestTalkSelectAck();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_QuestTalkSelectAck(*proto);
				proto->~QuestTalkSelectAck();
				return true;
			}
			else
			{
				proto->~QuestTalkSelectAck();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 95:
		{
			ObjStrCustomNtf* proto = new(m_protocol_buffer) ObjStrCustomNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_ObjStrCustomNtf(*proto);
				proto->~ObjStrCustomNtf();
				return true;
			}
			else
			{
				proto->~ObjStrCustomNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 96:
		{
			ObjIntCustomNtf* proto = new(m_protocol_buffer) ObjIntCustomNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_ObjIntCustomNtf(*proto);
				proto->~ObjIntCustomNtf();
				return true;
			}
			else
			{
				proto->~ObjIntCustomNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 97:
		{
			ObjDynAttrNtf* proto = new(m_protocol_buffer) ObjDynAttrNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_ObjDynAttrNtf(*proto);
				proto->~ObjDynAttrNtf();
				return true;
			}
			else
			{
				proto->~ObjDynAttrNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 98:
		{
			CommitQuestItemRsp* proto = new(m_protocol_buffer) CommitQuestItemRsp();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_CommitQuestItemRsp(*proto);
				proto->~CommitQuestItemRsp();
				return true;
			}
			else
			{
				proto->~CommitQuestItemRsp();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 99:
		{
			CommitQuestItemNtf* proto = new(m_protocol_buffer) CommitQuestItemNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_CommitQuestItemNtf(*proto);
				proto->~CommitQuestItemNtf();
				return true;
			}
			else
			{
				proto->~CommitQuestItemNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 100:
		{
			CommitQuestPetRsp* proto = new(m_protocol_buffer) CommitQuestPetRsp();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_CommitQuestPetRsp(*proto);
				proto->~CommitQuestPetRsp();
				return true;
			}
			else
			{
				proto->~CommitQuestPetRsp();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 101:
		{
			CommitQuestPetNtf* proto = new(m_protocol_buffer) CommitQuestPetNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_CommitQuestPetNtf(*proto);
				proto->~CommitQuestPetNtf();
				return true;
			}
			else
			{
				proto->~CommitQuestPetNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 102:
		{
			AbandonQuest* proto = new(m_protocol_buffer) AbandonQuest();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_AbandonQuest(*proto);
				proto->~AbandonQuest();
				return true;
			}
			else
			{
				proto->~AbandonQuest();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 103:
		{
			SkillTipsReq* proto = new(m_protocol_buffer) SkillTipsReq();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_SkillTipsReq(*proto);
				proto->~SkillTipsReq();
				return true;
			}
			else
			{
				proto->~SkillTipsReq();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 104:
		{
			SkillTipsAck* proto = new(m_protocol_buffer) SkillTipsAck();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_SkillTipsAck(*proto);
				proto->~SkillTipsAck();
				return true;
			}
			else
			{
				proto->~SkillTipsAck();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 105:
		{
			TeamLeaderOprNtf* proto = new(m_protocol_buffer) TeamLeaderOprNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_TeamLeaderOprNtf(*proto);
				proto->~TeamLeaderOprNtf();
				return true;
			}
			else
			{
				proto->~TeamLeaderOprNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 106:
		{
			KeepAliveCtrlNtf* proto = new(m_protocol_buffer) KeepAliveCtrlNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_KeepAliveCtrlNtf(*proto);
				proto->~KeepAliveCtrlNtf();
				return true;
			}
			else
			{
				proto->~KeepAliveCtrlNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 107:
		{
			NetDelayReq* proto = new(m_protocol_buffer) NetDelayReq();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_NetDelayReq(*proto);
				proto->~NetDelayReq();
				return true;
			}
			else
			{
				proto->~NetDelayReq();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 108:
		{
			NetDelayAck* proto = new(m_protocol_buffer) NetDelayAck();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_NetDelayAck(*proto);
				proto->~NetDelayAck();
				return true;
			}
			else
			{
				proto->~NetDelayAck();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 109:
		{
			SystemSetupNtf* proto = new(m_protocol_buffer) SystemSetupNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_SystemSetupNtf(*proto);
				proto->~SystemSetupNtf();
				return true;
			}
			else
			{
				proto->~SystemSetupNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 110:
		{
			BuffListNtf* proto = new(m_protocol_buffer) BuffListNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_BuffListNtf(*proto);
				proto->~BuffListNtf();
				return true;
			}
			else
			{
				proto->~BuffListNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 111:
		{
			BuffAddNtf* proto = new(m_protocol_buffer) BuffAddNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_BuffAddNtf(*proto);
				proto->~BuffAddNtf();
				return true;
			}
			else
			{
				proto->~BuffAddNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 112:
		{
			BuffDurationNtf* proto = new(m_protocol_buffer) BuffDurationNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_BuffDurationNtf(*proto);
				proto->~BuffDurationNtf();
				return true;
			}
			else
			{
				proto->~BuffDurationNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 113:
		{
			BuffDynAttrNtf* proto = new(m_protocol_buffer) BuffDynAttrNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_BuffDynAttrNtf(*proto);
				proto->~BuffDynAttrNtf();
				return true;
			}
			else
			{
				proto->~BuffDynAttrNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 114:
		{
			StopBuff* proto = new(m_protocol_buffer) StopBuff();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_StopBuff(*proto);
				proto->~StopBuff();
				return true;
			}
			else
			{
				proto->~StopBuff();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 115:
		{
			BuffDelNtf* proto = new(m_protocol_buffer) BuffDelNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_BuffDelNtf(*proto);
				proto->~BuffDelNtf();
				return true;
			}
			else
			{
				proto->~BuffDelNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 116:
		{
			ActivityListReq* proto = new(m_protocol_buffer) ActivityListReq();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_ActivityListReq(*proto);
				proto->~ActivityListReq();
				return true;
			}
			else
			{
				proto->~ActivityListReq();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 117:
		{
			ActivityListAck* proto = new(m_protocol_buffer) ActivityListAck();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_ActivityListAck(*proto);
				proto->~ActivityListAck();
				return true;
			}
			else
			{
				proto->~ActivityListAck();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 118:
		{
			ActivityJoinNtf* proto = new(m_protocol_buffer) ActivityJoinNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_ActivityJoinNtf(*proto);
				proto->~ActivityJoinNtf();
				return true;
			}
			else
			{
				proto->~ActivityJoinNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 119:
		{
			GuildListNtf* proto = new(m_protocol_buffer) GuildListNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_GuildListNtf(*proto);
				proto->~GuildListNtf();
				return true;
			}
			else
			{
				proto->~GuildListNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 120:
		{
			GuildNtf* proto = new(m_protocol_buffer) GuildNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_GuildNtf(*proto);
				proto->~GuildNtf();
				return true;
			}
			else
			{
				proto->~GuildNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 121:
		{
			GuildBaseNtf* proto = new(m_protocol_buffer) GuildBaseNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_GuildBaseNtf(*proto);
				proto->~GuildBaseNtf();
				return true;
			}
			else
			{
				proto->~GuildBaseNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 122:
		{
			GuildNoticeNtf* proto = new(m_protocol_buffer) GuildNoticeNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_GuildNoticeNtf(*proto);
				proto->~GuildNoticeNtf();
				return true;
			}
			else
			{
				proto->~GuildNoticeNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 123:
		{
			GuildBriefNtf* proto = new(m_protocol_buffer) GuildBriefNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_GuildBriefNtf(*proto);
				proto->~GuildBriefNtf();
				return true;
			}
			else
			{
				proto->~GuildBriefNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 124:
		{
			GuildMemberListNtf* proto = new(m_protocol_buffer) GuildMemberListNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_GuildMemberListNtf(*proto);
				proto->~GuildMemberListNtf();
				return true;
			}
			else
			{
				proto->~GuildMemberListNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 125:
		{
			GuildMemberNtf* proto = new(m_protocol_buffer) GuildMemberNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_GuildMemberNtf(*proto);
				proto->~GuildMemberNtf();
				return true;
			}
			else
			{
				proto->~GuildMemberNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 126:
		{
			GuildApplicantListNtf* proto = new(m_protocol_buffer) GuildApplicantListNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_GuildApplicantListNtf(*proto);
				proto->~GuildApplicantListNtf();
				return true;
			}
			else
			{
				proto->~GuildApplicantListNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 127:
		{
			GuildOperationNtf* proto = new(m_protocol_buffer) GuildOperationNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_GuildOperationNtf(*proto);
				proto->~GuildOperationNtf();
				return true;
			}
			else
			{
				proto->~GuildOperationNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 128:
		{
			GetTimestampReq* proto = new(m_protocol_buffer) GetTimestampReq();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_GetTimestampReq(*proto);
				proto->~GetTimestampReq();
				return true;
			}
			else
			{
				proto->~GetTimestampReq();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 129:
		{
			GetTimestampAck* proto = new(m_protocol_buffer) GetTimestampAck();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_GetTimestampAck(*proto);
				proto->~GetTimestampAck();
				return true;
			}
			else
			{
				proto->~GetTimestampAck();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 130:
		{
			ContactListNtf* proto = new(m_protocol_buffer) ContactListNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_ContactListNtf(*proto);
				proto->~ContactListNtf();
				return true;
			}
			else
			{
				proto->~ContactListNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 131:
		{
			AddContactNtf* proto = new(m_protocol_buffer) AddContactNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_AddContactNtf(*proto);
				proto->~AddContactNtf();
				return true;
			}
			else
			{
				proto->~AddContactNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 132:
		{
			UpdateContactNtf* proto = new(m_protocol_buffer) UpdateContactNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_UpdateContactNtf(*proto);
				proto->~UpdateContactNtf();
				return true;
			}
			else
			{
				proto->~UpdateContactNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 133:
		{
			DelContactNtf* proto = new(m_protocol_buffer) DelContactNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_DelContactNtf(*proto);
				proto->~DelContactNtf();
				return true;
			}
			else
			{
				proto->~DelContactNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 134:
		{
			AddContactMessageNtf* proto = new(m_protocol_buffer) AddContactMessageNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_AddContactMessageNtf(*proto);
				proto->~AddContactMessageNtf();
				return true;
			}
			else
			{
				proto->~AddContactMessageNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 135:
		{
			ItemQueryNtf* proto = new(m_protocol_buffer) ItemQueryNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_ItemQueryNtf(*proto);
				proto->~ItemQueryNtf();
				return true;
			}
			else
			{
				proto->~ItemQueryNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 136:
		{
			PetQueryNtf* proto = new(m_protocol_buffer) PetQueryNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_PetQueryNtf(*proto);
				proto->~PetQueryNtf();
				return true;
			}
			else
			{
				proto->~PetQueryNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 137:
		{
			ContactInfoNtf* proto = new(m_protocol_buffer) ContactInfoNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_ContactInfoNtf(*proto);
				proto->~ContactInfoNtf();
				return true;
			}
			else
			{
				proto->~ContactInfoNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 138:
		{
			MailListNtf* proto = new(m_protocol_buffer) MailListNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_MailListNtf(*proto);
				proto->~MailListNtf();
				return true;
			}
			else
			{
				proto->~MailListNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 139:
		{
			AddMailNtf* proto = new(m_protocol_buffer) AddMailNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_AddMailNtf(*proto);
				proto->~AddMailNtf();
				return true;
			}
			else
			{
				proto->~AddMailNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 140:
		{
			DelMailNtf* proto = new(m_protocol_buffer) DelMailNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_DelMailNtf(*proto);
				proto->~DelMailNtf();
				return true;
			}
			else
			{
				proto->~DelMailNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 141:
		{
			MailBodyNtf* proto = new(m_protocol_buffer) MailBodyNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_MailBodyNtf(*proto);
				proto->~MailBodyNtf();
				return true;
			}
			else
			{
				proto->~MailBodyNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 142:
		{
			UpdateMailBodyNtf* proto = new(m_protocol_buffer) UpdateMailBodyNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_UpdateMailBodyNtf(*proto);
				proto->~UpdateMailBodyNtf();
				return true;
			}
			else
			{
				proto->~UpdateMailBodyNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 143:
		{
			UpdateMailHeadNtf* proto = new(m_protocol_buffer) UpdateMailHeadNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_UpdateMailHeadNtf(*proto);
				proto->~UpdateMailHeadNtf();
				return true;
			}
			else
			{
				proto->~UpdateMailHeadNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 144:
		{
			RanklistReq* proto = new(m_protocol_buffer) RanklistReq();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_RanklistReq(*proto);
				proto->~RanklistReq();
				return true;
			}
			else
			{
				proto->~RanklistReq();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 145:
		{
			RanklistAck* proto = new(m_protocol_buffer) RanklistAck();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_RanklistAck(*proto);
				proto->~RanklistAck();
				return true;
			}
			else
			{
				proto->~RanklistAck();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 146:
		{
			GetRankReq* proto = new(m_protocol_buffer) GetRankReq();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_GetRankReq(*proto);
				proto->~GetRankReq();
				return true;
			}
			else
			{
				proto->~GetRankReq();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 147:
		{
			GetRankAck* proto = new(m_protocol_buffer) GetRankAck();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_GetRankAck(*proto);
				proto->~GetRankAck();
				return true;
			}
			else
			{
				proto->~GetRankAck();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 148:
		{
			TitleContainerNtf* proto = new(m_protocol_buffer) TitleContainerNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_TitleContainerNtf(*proto);
				proto->~TitleContainerNtf();
				return true;
			}
			else
			{
				proto->~TitleContainerNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 149:
		{
			TitleAddNtf* proto = new(m_protocol_buffer) TitleAddNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_TitleAddNtf(*proto);
				proto->~TitleAddNtf();
				return true;
			}
			else
			{
				proto->~TitleAddNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 150:
		{
			TitleDelNtf* proto = new(m_protocol_buffer) TitleDelNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_TitleDelNtf(*proto);
				proto->~TitleDelNtf();
				return true;
			}
			else
			{
				proto->~TitleDelNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 151:
		{
			AgentKeyReq* proto = new(m_protocol_buffer) AgentKeyReq();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_AgentKeyReq(*proto);
				proto->~AgentKeyReq();
				return true;
			}
			else
			{
				proto->~AgentKeyReq();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 152:
		{
			AgentKeyAck* proto = new(m_protocol_buffer) AgentKeyAck();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_AgentKeyAck(*proto);
				proto->~AgentKeyAck();
				return true;
			}
			else
			{
				proto->~AgentKeyAck();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 153:
		{
			HeadMsgNtf* proto = new(m_protocol_buffer) HeadMsgNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_HeadMsgNtf(*proto);
				proto->~HeadMsgNtf();
				return true;
			}
			else
			{
				proto->~HeadMsgNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 154:
		{
			AutoContainerNtf* proto = new(m_protocol_buffer) AutoContainerNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_AutoContainerNtf(*proto);
				proto->~AutoContainerNtf();
				return true;
			}
			else
			{
				proto->~AutoContainerNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 155:
		{
			PlayerQueryNtf* proto = new(m_protocol_buffer) PlayerQueryNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_PlayerQueryNtf(*proto);
				proto->~PlayerQueryNtf();
				return true;
			}
			else
			{
				proto->~PlayerQueryNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 156:
		{
			UseAllItem* proto = new(m_protocol_buffer) UseAllItem();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_UseAllItem(*proto);
				proto->~UseAllItem();
				return true;
			}
			else
			{
				proto->~UseAllItem();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 157:
		{
			GuardContainerNtf* proto = new(m_protocol_buffer) GuardContainerNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_GuardContainerNtf(*proto);
				proto->~GuardContainerNtf();
				return true;
			}
			else
			{
				proto->~GuardContainerNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 158:
		{
			GuardAddNtf* proto = new(m_protocol_buffer) GuardAddNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_GuardAddNtf(*proto);
				proto->~GuardAddNtf();
				return true;
			}
			else
			{
				proto->~GuardAddNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 159:
		{
			SetGuardLineup* proto = new(m_protocol_buffer) SetGuardLineup();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_SetGuardLineup(*proto);
				proto->~SetGuardLineup();
				return true;
			}
			else
			{
				proto->~SetGuardLineup();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 160:
		{
			PetNewAddNtf* proto = new(m_protocol_buffer) PetNewAddNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_PetNewAddNtf(*proto);
				proto->~PetNewAddNtf();
				return true;
			}
			else
			{
				proto->~PetNewAddNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 161:
		{
			TeamPlatformNtf* proto = new(m_protocol_buffer) TeamPlatformNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_TeamPlatformNtf(*proto);
				proto->~TeamPlatformNtf();
				return true;
			}
			else
			{
				proto->~TeamPlatformNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 162:
		{
			TeamApplicantsNtf* proto = new(m_protocol_buffer) TeamApplicantsNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_TeamApplicantsNtf(*proto);
				proto->~TeamApplicantsNtf();
				return true;
			}
			else
			{
				proto->~TeamApplicantsNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 163:
		{
			TeamOperationNtf* proto = new(m_protocol_buffer) TeamOperationNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_TeamOperationNtf(*proto);
				proto->~TeamOperationNtf();
				return true;
			}
			else
			{
				proto->~TeamOperationNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 164:
		{
			TeamTargetNtf* proto = new(m_protocol_buffer) TeamTargetNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_TeamTargetNtf(*proto);
				proto->~TeamTargetNtf();
				return true;
			}
			else
			{
				proto->~TeamTargetNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 165:
		{
			ChangedNameNtf* proto = new(m_protocol_buffer) ChangedNameNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_ChangedNameNtf(*proto);
				proto->~ChangedNameNtf();
				return true;
			}
			else
			{
				proto->~ChangedNameNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 166:
		{
			CustomDataNtf* proto = new(m_protocol_buffer) CustomDataNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_CustomDataNtf(*proto);
				proto->~CustomDataNtf();
				return true;
			}
			else
			{
				proto->~CustomDataNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 167:
		{
			SpeedCheckNtf* proto = new(m_protocol_buffer) SpeedCheckNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_SpeedCheckNtf(*proto);
				proto->~SpeedCheckNtf();
				return true;
			}
			else
			{
				proto->~SpeedCheckNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 168:
		{
			ConsoleMsgNtf* proto = new(m_protocol_buffer) ConsoleMsgNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_ConsoleMsgNtf(*proto);
				proto->~ConsoleMsgNtf();
				return true;
			}
			else
			{
				proto->~ConsoleMsgNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 169:
		{
			PetSwapNtf* proto = new(m_protocol_buffer) PetSwapNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_PetSwapNtf(*proto);
				proto->~PetSwapNtf();
				return true;
			}
			else
			{
				proto->~PetSwapNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 170:
		{
			GuardDestroyNtf* proto = new(m_protocol_buffer) GuardDestroyNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_GuardDestroyNtf(*proto);
				proto->~GuardDestroyNtf();
				return true;
			}
			else
			{
				proto->~GuardDestroyNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 171:
		{
			ActivateGuard* proto = new(m_protocol_buffer) ActivateGuard();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_ActivateGuard(*proto);
				proto->~ActivateGuard();
				return true;
			}
			else
			{
				proto->~ActivateGuard();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 172:
		{
			ReleaseGuard* proto = new(m_protocol_buffer) ReleaseGuard();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_ReleaseGuard(*proto);
				proto->~ReleaseGuard();
				return true;
			}
			else
			{
				proto->~ReleaseGuard();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 173:
		{
			TeamMemberSwapNtf* proto = new(m_protocol_buffer) TeamMemberSwapNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_TeamMemberSwapNtf(*proto);
				proto->~TeamMemberSwapNtf();
				return true;
			}
			else
			{
				proto->~TeamMemberSwapNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 174:
		{
			GuardSwapNtf* proto = new(m_protocol_buffer) GuardSwapNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_GuardSwapNtf(*proto);
				proto->~GuardSwapNtf();
				return true;
			}
			else
			{
				proto->~GuardSwapNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 175:
		{
			PetReplaceNtf* proto = new(m_protocol_buffer) PetReplaceNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_PetReplaceNtf(*proto);
				proto->~PetReplaceNtf();
				return true;
			}
			else
			{
				proto->~PetReplaceNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 176:
		{
			GuardAppearNtf* proto = new(m_protocol_buffer) GuardAppearNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_GuardAppearNtf(*proto);
				proto->~GuardAppearNtf();
				return true;
			}
			else
			{
				proto->~GuardAppearNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 177:
		{
			InstructionContainerNtf* proto = new(m_protocol_buffer) InstructionContainerNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_InstructionContainerNtf(*proto);
				proto->~InstructionContainerNtf();
				return true;
			}
			else
			{
				proto->~InstructionContainerNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 178:
		{
			InstructionAddReq* proto = new(m_protocol_buffer) InstructionAddReq();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_InstructionAddReq(*proto);
				proto->~InstructionAddReq();
				return true;
			}
			else
			{
				proto->~InstructionAddReq();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 179:
		{
			InstructionAddAck* proto = new(m_protocol_buffer) InstructionAddAck();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_InstructionAddAck(*proto);
				proto->~InstructionAddAck();
				return true;
			}
			else
			{
				proto->~InstructionAddAck();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 180:
		{
			InstructionDeleteReq* proto = new(m_protocol_buffer) InstructionDeleteReq();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_InstructionDeleteReq(*proto);
				proto->~InstructionDeleteReq();
				return true;
			}
			else
			{
				proto->~InstructionDeleteReq();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 181:
		{
			InstructionDeleteAck* proto = new(m_protocol_buffer) InstructionDeleteAck();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_InstructionDeleteAck(*proto);
				proto->~InstructionDeleteAck();
				return true;
			}
			else
			{
				proto->~InstructionDeleteAck();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 182:
		{
			InstructionModfityReq* proto = new(m_protocol_buffer) InstructionModfityReq();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_InstructionModfityReq(*proto);
				proto->~InstructionModfityReq();
				return true;
			}
			else
			{
				proto->~InstructionModfityReq();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 183:
		{
			InstructionModifyAck* proto = new(m_protocol_buffer) InstructionModifyAck();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_InstructionModifyAck(*proto);
				proto->~InstructionModifyAck();
				return true;
			}
			else
			{
				proto->~InstructionModifyAck();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 184:
		{
			InstructionDefaultReq* proto = new(m_protocol_buffer) InstructionDefaultReq();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_InstructionDefaultReq(*proto);
				proto->~InstructionDefaultReq();
				return true;
			}
			else
			{
				proto->~InstructionDefaultReq();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 185:
		{
			InstructionDefaultAck* proto = new(m_protocol_buffer) InstructionDefaultAck();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_InstructionDefaultAck(*proto);
				proto->~InstructionDefaultAck();
				return true;
			}
			else
			{
				proto->~InstructionDefaultAck();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 186:
		{
			InstructionAttachReq* proto = new(m_protocol_buffer) InstructionAttachReq();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_InstructionAttachReq(*proto);
				proto->~InstructionAttachReq();
				return true;
			}
			else
			{
				proto->~InstructionAttachReq();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 187:
		{
			InstructionAttachAck* proto = new(m_protocol_buffer) InstructionAttachAck();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_InstructionAttachAck(*proto);
				proto->~InstructionAttachAck();
				return true;
			}
			else
			{
				proto->~InstructionAttachAck();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 188:
		{
			InstructionAttachNtf* proto = new(m_protocol_buffer) InstructionAttachNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_InstructionAttachNtf(*proto);
				proto->~InstructionAttachNtf();
				return true;
			}
			else
			{
				proto->~InstructionAttachNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 189:
		{
			InstructionDetachReq* proto = new(m_protocol_buffer) InstructionDetachReq();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_InstructionDetachReq(*proto);
				proto->~InstructionDetachReq();
				return true;
			}
			else
			{
				proto->~InstructionDetachReq();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 190:
		{
			InstructionDetachAck* proto = new(m_protocol_buffer) InstructionDetachAck();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_InstructionDetachAck(*proto);
				proto->~InstructionDetachAck();
				return true;
			}
			else
			{
				proto->~InstructionDetachAck();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 191:
		{
			InstructionDetachNtf* proto = new(m_protocol_buffer) InstructionDetachNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_InstructionDetachNtf(*proto);
				proto->~InstructionDetachNtf();
				return true;
			}
			else
			{
				proto->~InstructionDetachNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 192:
		{
			PlayerDetailNtf* proto = new(m_protocol_buffer) PlayerDetailNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_PlayerDetailNtf(*proto);
				proto->~PlayerDetailNtf();
				return true;
			}
			else
			{
				proto->~PlayerDetailNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 193:
		{
			MapDynBlockPtNtf* proto = new(m_protocol_buffer) MapDynBlockPtNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_MapDynBlockPtNtf(*proto);
				proto->~MapDynBlockPtNtf();
				return true;
			}
			else
			{
				proto->~MapDynBlockPtNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 194:
		{
			GuardQueryNtf* proto = new(m_protocol_buffer) GuardQueryNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_GuardQueryNtf(*proto);
				proto->~GuardQueryNtf();
				return true;
			}
			else
			{
				proto->~GuardQueryNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 195:
		{
			BuyBackNtfEx* proto = new(m_protocol_buffer) BuyBackNtfEx();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_BuyBackNtfEx(*proto);
				proto->~BuyBackNtfEx();
				return true;
			}
			else
			{
				proto->~BuyBackNtfEx();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 196:
		{
			GuildCustomNtf* proto = new(m_protocol_buffer) GuildCustomNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_GuildCustomNtf(*proto);
				proto->~GuildCustomNtf();
				return true;
			}
			else
			{
				proto->~GuildCustomNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 197:
		{
			PreTurnRoundNtf* proto = new(m_protocol_buffer) PreTurnRoundNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_PreTurnRoundNtf(*proto);
				proto->~PreTurnRoundNtf();
				return true;
			}
			else
			{
				proto->~PreTurnRoundNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		case 198:
		{
			FighterSpecialPetNtf* proto = new(m_protocol_buffer) FighterSpecialPetNtf();
			if (proto->DeCode(net_data))
			{
				static_cast<D*>(this)->OnRecv_FighterSpecialPetNtf(*proto);
				proto->~FighterSpecialPetNtf();
				return true;
			}
			else
			{
				proto->~FighterSpecialPetNtf();
				net_data.Reset(net_data_pos);
				return false;
			}
		}
		break;
		default:
			return false;
		}

	}

	static inline unsigned short GetModuleID(void){ return 102; }

	static inline unsigned short GetProtocolNum(void){ return 198; }

	static const unsigned short module_id = 102;

	static const unsigned short protocol_num = 198;

//===============以下协议回调函数需要使用者来实现===============
	void OnRecv_KeepAliveReq(KeepAliveReq& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_KeepAliveAck(KeepAliveAck& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_AttrNtf(AttrNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_PlayerAppearNtf(PlayerAppearNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_NPCAppearNtf(NPCAppearNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_ItemAppearNtf(ItemAppearNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_ObjDisAppearNtf(ObjDisAppearNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_ObjMoveNtf(ObjMoveNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_EnterMapNtf(EnterMapNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_MoveReq(MoveReq& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_MoveAck(MoveAck& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_JumpMapReq(JumpMapReq& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_JumpMapAck(JumpMapAck& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_AddJumpMapRegionNtf(AddJumpMapRegionNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_DelJumpMapRegionNtf(DelJumpMapRegionNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_ItemAddNtf(ItemAddNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_ItemUpdateNtf(ItemUpdateNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_ItemDestroyNtf(ItemDestroyNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_TipsMsgNtf(TipsMsgNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_TopMsgNtf(TopMsgNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_SysMsgNtf(SysMsgNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_PopupMsgNtf(PopupMsgNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_ItemContainerNtf(ItemContainerNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_ItemContainerUpdateNtf(ItemContainerUpdateNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_SubmitForm(SubmitForm& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_ShowFormNtf(ShowFormNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_ExecuteGMReq(ExecuteGMReq& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_FightBeginNtf(FightBeginNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_TurnRoundNtf(TurnRoundNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_FightOperateListNtf(FightOperateListNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_FightOperateReq(FightOperateReq& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_FightOperateAck(FightOperateAck& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_FightOperateNtf(FightOperateNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_FightDisplayNtf(FightDisplayNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_FightDisplayCompleteNtf(FightDisplayCompleteNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_FightAutoReq(FightAutoReq& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_FightAutoAck(FightAutoAck& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_FightAutoNtf(FightAutoNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_FightAutoSkillReq(FightAutoSkillReq& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_FightAutoSkillAck(FightAutoSkillAck& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_FightEndNtf(FightEndNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_AddFighterNtf(AddFighterNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_DelFighterNtf(DelFighterNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_AddFightPetData(AddFightPetData& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_UpdateFightPetData(UpdateFightPetData& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_PlayerKillReq(PlayerKillReq& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_PlayerKillAck(PlayerKillAck& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_EnterFightViewReq(EnterFightViewReq& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_EnterFightViewAck(EnterFightViewAck& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_LeaveFightViewReq(LeaveFightViewReq& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_LeaveFightViewAck(LeaveFightViewAck& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_TeamLeaderOprReq(TeamLeaderOprReq& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_TeamNtf(TeamNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_TeamLeaderNtf(TeamLeaderNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_TeamDestroyNtf(TeamDestroyNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_TeamMemberNtf(TeamMemberNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_TeamMemberLeaveNtf(TeamMemberLeaveNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_NpcSelectReq(NpcSelectReq& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_NpcSelectAck(NpcSelectAck& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_NpcTalkReq(NpcTalkReq& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_NpcTalkAck(NpcTalkAck& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_InviteMsgNtf(InviteMsgNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_ReplyInvite(ReplyInvite& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_MoveItem(MoveItem& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_UseItem(UseItem& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_RearrangeItem(RearrangeItem& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_SkillContainerNtf(SkillContainerNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_AddSkillNtf(AddSkillNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_UpdateSkillNtf(UpdateSkillNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_DelSkillNtf(DelSkillNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_PetAppearNtf(PetAppearNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_PetContainerNtf(PetContainerNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_PetContainerUpdateNtf(PetContainerUpdateNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_PetAddNtf(PetAddNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_PetDestroyNtf(PetDestroyNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_SetPetLineup(SetPetLineup& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_ShowPet(ShowPet& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_ReleasePet(ReleasePet& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_MovePet(MovePet& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_ShopOpenNtf(ShopOpenNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_ShopBuyNtf(ShopBuyNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_SellNtf(SellNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_BuyBackNtf(BuyBackNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_BuyBackListNtf(BuyBackListNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_TeamAttrNtf(TeamAttrNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_TipsMsgExNtf(TipsMsgExNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_ItemNewAddNtf(ItemNewAddNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_QuestContainerNtf(QuestContainerNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_QuestAddNtf(QuestAddNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_QuestStateNtf(QuestStateNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_QuestNpcStateNtf(QuestNpcStateNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_QuestTrackCountNtf(QuestTrackCountNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_QuestTalkSelectReq(QuestTalkSelectReq& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_QuestTalkSelectAck(QuestTalkSelectAck& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_ObjStrCustomNtf(ObjStrCustomNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_ObjIntCustomNtf(ObjIntCustomNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_ObjDynAttrNtf(ObjDynAttrNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_CommitQuestItemRsp(CommitQuestItemRsp& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_CommitQuestItemNtf(CommitQuestItemNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_CommitQuestPetRsp(CommitQuestPetRsp& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_CommitQuestPetNtf(CommitQuestPetNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_AbandonQuest(AbandonQuest& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_SkillTipsReq(SkillTipsReq& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_SkillTipsAck(SkillTipsAck& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_TeamLeaderOprNtf(TeamLeaderOprNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_KeepAliveCtrlNtf(KeepAliveCtrlNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_NetDelayReq(NetDelayReq& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_NetDelayAck(NetDelayAck& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_SystemSetupNtf(SystemSetupNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_BuffListNtf(BuffListNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_BuffAddNtf(BuffAddNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_BuffDurationNtf(BuffDurationNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_BuffDynAttrNtf(BuffDynAttrNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_StopBuff(StopBuff& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_BuffDelNtf(BuffDelNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_ActivityListReq(ActivityListReq& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_ActivityListAck(ActivityListAck& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_ActivityJoinNtf(ActivityJoinNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_GuildListNtf(GuildListNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_GuildNtf(GuildNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_GuildBaseNtf(GuildBaseNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_GuildNoticeNtf(GuildNoticeNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_GuildBriefNtf(GuildBriefNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_GuildMemberListNtf(GuildMemberListNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_GuildMemberNtf(GuildMemberNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_GuildApplicantListNtf(GuildApplicantListNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_GuildOperationNtf(GuildOperationNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_GetTimestampReq(GetTimestampReq& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_GetTimestampAck(GetTimestampAck& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_ContactListNtf(ContactListNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_AddContactNtf(AddContactNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_UpdateContactNtf(UpdateContactNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_DelContactNtf(DelContactNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_AddContactMessageNtf(AddContactMessageNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_ItemQueryNtf(ItemQueryNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_PetQueryNtf(PetQueryNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_ContactInfoNtf(ContactInfoNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_MailListNtf(MailListNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_AddMailNtf(AddMailNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_DelMailNtf(DelMailNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_MailBodyNtf(MailBodyNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_UpdateMailBodyNtf(UpdateMailBodyNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_UpdateMailHeadNtf(UpdateMailHeadNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_RanklistReq(RanklistReq& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_RanklistAck(RanklistAck& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_GetRankReq(GetRankReq& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_GetRankAck(GetRankAck& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_TitleContainerNtf(TitleContainerNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_TitleAddNtf(TitleAddNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_TitleDelNtf(TitleDelNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_AgentKeyReq(AgentKeyReq& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_AgentKeyAck(AgentKeyAck& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_HeadMsgNtf(HeadMsgNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_AutoContainerNtf(AutoContainerNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_PlayerQueryNtf(PlayerQueryNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_UseAllItem(UseAllItem& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_GuardContainerNtf(GuardContainerNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_GuardAddNtf(GuardAddNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_SetGuardLineup(SetGuardLineup& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_PetNewAddNtf(PetNewAddNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_TeamPlatformNtf(TeamPlatformNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_TeamApplicantsNtf(TeamApplicantsNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_TeamOperationNtf(TeamOperationNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_TeamTargetNtf(TeamTargetNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_ChangedNameNtf(ChangedNameNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_CustomDataNtf(CustomDataNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_SpeedCheckNtf(SpeedCheckNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_ConsoleMsgNtf(ConsoleMsgNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_PetSwapNtf(PetSwapNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_GuardDestroyNtf(GuardDestroyNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_ActivateGuard(ActivateGuard& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_ReleaseGuard(ReleaseGuard& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_TeamMemberSwapNtf(TeamMemberSwapNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_GuardSwapNtf(GuardSwapNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_PetReplaceNtf(PetReplaceNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_GuardAppearNtf(GuardAppearNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_InstructionContainerNtf(InstructionContainerNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_InstructionAddReq(InstructionAddReq& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_InstructionAddAck(InstructionAddAck& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_InstructionDeleteReq(InstructionDeleteReq& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_InstructionDeleteAck(InstructionDeleteAck& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_InstructionModfityReq(InstructionModfityReq& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_InstructionModifyAck(InstructionModifyAck& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_InstructionDefaultReq(InstructionDefaultReq& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_InstructionDefaultAck(InstructionDefaultAck& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_InstructionAttachReq(InstructionAttachReq& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_InstructionAttachAck(InstructionAttachAck& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_InstructionAttachNtf(InstructionAttachNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_InstructionDetachReq(InstructionDetachReq& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_InstructionDetachAck(InstructionDetachAck& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_InstructionDetachNtf(InstructionDetachNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_PlayerDetailNtf(PlayerDetailNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_MapDynBlockPtNtf(MapDynBlockPtNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_GuardQueryNtf(GuardQueryNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_BuyBackNtfEx(BuyBackNtfEx& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_GuildCustomNtf(GuildCustomNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_PreTurnRoundNtf(PreTurnRoundNtf& rstProtocol){ (void)(rstProtocol); };
	void OnRecv_FighterSpecialPetNtf(FighterSpecialPetNtf& rstProtocol){ (void)(rstProtocol); };
private:
	 void* m_protocol_buffer;

};
